{"pages":[],"posts":[{"title":"博客搭建指南","text":"平台本博客网站的平台如下。 Hexo Icarus Gitee 搭建 HexoHexo 官网为了搭建 Hexo 环境, 用户需要先配置好 Node.js 以及 Git 环境。 新建一个文件夹，用来存放项目文件 进入该文件夹, 打开 Git Bash hexo init npm install npm install hexo-deployer-git --save hexo g hexo s 1npm install 可能针对某个特定的包报错, 可以先安装报错的包[npm install xxx --ignore-scripts] 切换 Icarus 主题Icarus 官方文档 Gitte Page 完成同步 创建 gitte 账户, 并添加本地主机的 ssh 公钥1234// Gittessh -T git@gitte.com// Githubssh -T git@github.com 修改_config.yml配置文件12345deploy: type: git # 可以指定多个 repo repo: git@gitee.com:chengming0313/chengming0313.git branch: master hexo d上传静态文件(.deploy_git) Gitte 新建分支 hexo hexo 设为默认分支 git clone xxx只保留.git文件夹, 删除其它所有文件夹 将博客的源文件复制过来(除了 .deploy_git)记得删除 themes 下主题里的 .git文件夹 上传源文件到 hexo 分支123git add .git commit -m &quot;init&quot;git push 更换本地主机 git clone xxx npm install npm install hexo-deployer-git --save hexo g hexo s hexo d","link":"/2021/04/06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"},{"title":"C++ 初始化类型","text":"参考资料CPP Reference知乎回答 初始化类型 list initialization aggregate initialization value initialization default initialization zero initialization direct initialization copy initialization 1. list initialization [new] T [objectName] {arg1, arg2, …} list initialization 分为两种, 一种是 aggregate type，它会利用 args 对其中的成员逐个初始化, args 不够会对剩余的成员进行 value initialization。另一种是 非 aggerate type，它会调用最匹配的构造函数。 123456789101112131415161718192021// 列表初始化// 非 aggregate 类型, 直接查找匹配的构造函数std::string str1{ &quot;123&quot; };std::string str2 = { &quot;456&quot; };std::string str3 = std::string{ &quot;789&quot; };std::string *str4 = new std::string{ &quot;xxx&quot; };std::cout &lt;&lt; str1 &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; &quot; &quot; &lt;&lt; str3 &lt;&lt; &quot; &quot; &lt;&lt; *str4 &lt;&lt; '\\n';// aggregate initialization, 使用{}中的参数逐个初始化, 不足的使用 value// initializationstd::vector&lt;int&gt; c1{ 1, 2, 3, 4 };std::array&lt;int, 8&gt; c2 = { 4, 5, 6, 7 };for (auto item : c1) { std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n';for (auto item : c2) { std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n'; 1234// 结果123 456 789 xxx1 2 3 44 5 6 7 0 0 0 0 2. value initialization 对于class 类型的变量, value initialization 会优先考虑用户自定义的默认构造函数, 否则先进行 value initialization，再调用合成的默认构造函数 对于非class类型的变量，直接进行 value initialization 123456789101112131415161718// class 类型变量，用户自定义默认构造函数class A {public: A() : _data(999) {} void Print() { std::cout &lt;&lt; _data &lt;&lt; '\\n'; }private: int _data;};A a1{};A a2 = {};A a3 = A{};A *a4 = new A{};a1.Print();a2.Print();a3.Print();a4-&gt;Print(); 12345// 结果999999999999 12345678910111213141516171819202122232425// class 类型变量，合成默认构造函数class A {public: A() = default; void Print() { std::cout &lt;&lt; _data &lt;&lt; '\\n'; }private: int _data;};// value initializationA a1{};A a2 = {};A a3 = A{};A *a4 = new A{};a1.Print();a2.Print();a3.Print();a4-&gt;Print();// default initializationA a5;A a6 = A();A *a7 = new A();a5.Print();a6.Print();a7-&gt;Print(); 1234567891011// 结果// value initialization0000// default initialization495097600 6. direct initialization7. copy initialization 注意有些时候编译器会对copy initializaiton进行优化。 例 1 12345678910111213141516// example 1class A {public: A(int data) : _data(data) { std::cout &lt;&lt; &quot;data constructor...\\n&quot;; } A(A const &amp;x) { this-&gt;_data = x._data; std::cout &lt;&lt; &quot;copy constructor...\\n&quot;; }private: int _data;};// main functionA a = 999; A a = A(999); 12345// result// 第一行 : 隐式转换 999 -&gt; A// 第二行 : 等价于 A a(999);data constructor...data constructor... 12345678// 取消 g++ 优化 : g++ -o test test.cpp -fno-elide-constructors// result// 第一行 : 先隐式转换执行 A(999)，然后调用 copy ctor// 第二行 ： 先调用 普通ctor，再调用 copy ctordata constructor...copy constructor...data constructor...copy constructor... 例 2 12345678// example 2// 返回值优化A get() { return A();}void usage03() { A a = get();} 1234567891011// usage03()// g++编译器会对函数返回值优化, 这里并不会创建临时变量来存放返回值0x79fdef constructor // a0x79fdef destructor // a 析构// -fno-elide-constructors, 取消 g++ 优化0x78fd8f constructor // get() 中的匿名对象0x78fddf copy constructor // 临时对象存储返回值0x78fd8f destructor // 匿名对象析构0x78fdde copy constructor // a0x78fddf destructor // 临时对象析构0x78fdde destructor // a 析构","link":"/2021/04/11/CppInitializationType/"},{"title":"C++ const","text":"本系列参考第三方文档 C++那些事 const const 含义 定义一个 const 变量 const 的一些特性 指针与 const 函数与 const 类与 const 1. const 含义 const 用来修饰变量，表示变量的值不可改变(赋值), 是一个 只读变量 。 const 修饰的变量不一定是一个 常量表达式 , 常量表达式除了要求值不可更改之外, 还要求在编译过程中就能得到计算结果。 一般使用 constexpr 来修饰一个常量表达式, 编译器会对变量进行验证。不符合要求会报错。 声明 constexpr 的类型有所限制, 必须属于 字面值类型 。 2. 定义一个 const 变量 const 变量必须初始化 const 变量不能赋值 const 修饰的 类变量 , 只有在 构造函数 完成后才算真正具有 const 属性。 123const int i1; // error: uninitialized const 'i1'const int i = 0;i = 1; // error: assignment of read-only variable 'i' 3. const 的一些特性 用 const 代替 #define如下, #define 定义的 SIZE_NUM, 在 预处理过程 就已经被 10 替换, 不会进入 符号表。程序出现问题时不好定位。 12#define SIZE_NUM = 10const int SIZE_NUM = 10; const 变量默认为文件局部变量 非 const 变量不同文件访问 123456789101112131415// g++ -o main main.cpp other.cpp// other.cppint i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;extern int i;int main() { std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} const 变量不同文件访问 const 变量需要显式使用 extern 定义, 才能跨文件访问 1234567891011121314151617// other.cppextern const int i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;// 这里不用 const 声明也能够通过, i = 200 不会报错, 但是// 程序运行时会出错extern const int i;int main() { // i = 200; std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} 4. 指针与 const const 总是优先与它左侧的符号配对 12345const char * a; // pointer to const charchar const char * a; // 同上char *const a; // const pointer to charchar const *const a; // const pointer to const charconst char *const a; // 同上 指向常量的指针（底层 const） 可以不用初始化, 不能通过指针解引用去修改它的值 12345char const * a; // 底层 const 可以不用初始化char ch = 'a';a = &amp;ch;*a = 'x'; // error, 不能通过指针修改它的值 可以指向非 const 的变量 12345int i = 10;int const *pi = &amp;i;std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n';std::cout &lt;&lt; ++i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n'; 1210 1011 11 不能用 void * 指向 const 变量, 必须使用 const void * 123const int a = 10;void const *ptr1 = &amp;a;void * ptr2 = &amp;a; // error 常量指针（顶层 const） 必须初始化, 指针不能修改 1234int a = 10;int *const ptr = &amp;a;int *const ptr2; // error: uninitialized const 'ptr2'ptr = nullptr; // error: assignment of read-only variable 'ptr' error: const T * —-&gt; T * const 12int const a = 10;int *const ptr = &amp;a; // error: invalid conversion from 'const int*' to 'int*' 5. const 变量的拷贝操作 顶层 const 对象可以拷贝给非顶层 const 对象 1234const int ci = 100;int i = ci; // i: 100int *const p1 = &amp;i;int * p2 = p1; 非顶层 const 对象也可以拷给顶层 const 对象 12345// -&gt; 顶层 constint j = 200;const int cj = j;int * ptr1 = &amp;j;int *const ptr2 = ptr1; 底层 const 对象不能拷给非底层 const 对象 1234567891011int const &amp;cr1 = 100;int &amp;r1 = cr1; // error: binding reference of type 'int&amp;' to 'const int' discards qualifiersint const *p3 = &amp;ci;int * p4 = p3; // error: invalid conversion from 'const int*' to 'int*'// T const * const -&gt;int const *const p5 = &amp;ci;int * p6 = p5; // error: invalid conversion from 'const int*' to 'int*'int const * p7 = p5;int *const p8 = p5; // error: invalid conversion from 'const int*' to 'int*' 非底层 const 对象可以拷给底层 const 对象 1234567int &amp; r2 = j;int const &amp;cr2 = r2;int * ptr3 = &amp;j;int const *ptr4 = ptr3;int const *const ptr5 = ptr3; 6. 函数与 const6.1 修饰返回值 return by const value，一般情况下,，没有意义。一些特殊情况下是有意义的, 详见Effective C++ 条款21。 123const int get() {return 1;} // 无意义// 这是有意义的, 防止出现 (a * b) = c;const Rational operator*(Rational const &amp;lhs, Rational const &amp;rhs); return by const reference 返回普通引用, 可以修改返回值, 可以作为左值使用 1234567891011121314std::string &amp;Get(std::string &amp;a) { return a;}int main() { std::string str = &quot;123456&quot;; // 这里要用 &amp;, 不然不是引用 std::string &amp;str2 = Get(str); str2 = &quot;xxxxxx&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; Get(str) = &quot;hello world&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; return 0;} 12xxxxxx xxxxxxhello world hello world 返回常量引用，不能修改 12345678int main() { std::string str = &quot;123456&quot;; // 这里要用 const &amp; std::string const &amp;str2 = GetConst(str); std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; std::cout &lt;&lt; GetConst(str).length() &lt;&lt; std::endl; return 0;} return by T const * 1234567int const *Get(int *p) { return p;}int a = 10;int const *p1 = Get(&amp;a);int * p2 = Get(&amp;a); // error return by T * const1234567int *const Get2(int *p) { return p;}int a = 10;int *const p3 = Get2(&amp;a);int * p4 = Get2(&amp;a); 6.2 修饰参数 普通的 顶层 const (不是 T const &amp;)使用普通的 顶层 const 作为函数参数，没有意义, 函数收到的是一个副本。 12void fun1(int const val);void fun2(int *const ptr); 底层 const通过传入 T const * 的方式, 使得函数能够通过指针访问函数体外的对象, 又保证了数据的不可修改。 1void fun1(int const *p); T const &amp;pass by const reference 能让函数直接通过变量名访问作用域外的对象, 还能保证数据的 read only 1void fun1(std::string const &amp;str); 对于类类型的变量来说, 使用pass by value 的方式传值, 在拷贝过程中对象的拷贝构造以及析构都会消耗时间, 效率较低。我们可以使用 pass by pointer to const 以及 pass by const reference 来提高效率, 同时保证数据的安全性。 7. 类与 const const member function 普通的member function 中的 this pointer 类型为 T *, 而 const member function 中的 this pointer 类型为 T const *。 对于 const object来说, 它不能用来给普通的this pointer初始化, 它只能给const member function中T const *类型的this pointer初始化。 对于普通的 object, 它即可以使用const member function, 又可以使用普通的 member function。因为T * 既可以给 T * 初始化, 又可以给 T const * 初始化。 除了函数参数列表, 是否是 const member function, 也可以进行重载. 普通的 object 默认调用 非 const member function. 12345678910111213class A {public: void print() const { std::cout &lt;&lt; &quot;const print()\\n&quot;; } void print() { std::cout &lt;&lt; &quot;print()\\n&quot;; }};int main() { A a; A const ca; a.print(); ca.print(); return 0;} 123// 结果print()const print() const 成员 这里讨论一下类内初始值与初始值列表的优先级。初始值列表的优先级比类内初始值要高。只有没有为该成员设定初始值列表时, 它才会使用类内初始值进行初始化。 1234567891011121314class A {public: A() : _a(1) {} void Print() { std::cout &lt;&lt; _a &lt;&lt; &quot;\\n&quot;; }private: int _a = 0;};int main() { A a; a.Print(); return 0;} 12// 结果1 类中的 const 成员可以使用类内初始值的方式初始化 1const int _a = 999; 类中的 const 成员可以使用初始值列表的方式初始化 12const int _a;A() : _a(999) {} 不能在构造函数中用赋值表达式初始化 const 成员, 在进入构造函数体之前, 成员的初始化过程已经结束。 12const int _a;A() { _a = 999; } // error 当要表示类中共享的常量时, 通常使用 static const 修饰 使用类内初始值的方式定义 static const 1static const int _a = 999; // 类内初始值的方式初始化 static const 变量 采用与一般 static 变量一样的方法, 类内声明, 类外定义 1234// in classstatic const int _a;// 类的实现文件const int A::_a = 999; // 需要去除 static 符号","link":"/2021/04/11/C-const/"},{"title":"引用本地图片","text":"在hexo博客中引用本地图片 npm hexo-asset-image --save 替换/node_modules/hexo-asset-image/index.js内容 修改_config.xml 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg 1. npm hexo-asset-image --save2. 替换/node_modules/hexo-asset-image/index.js内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) { return str.split(m, i).join(m).length;}var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function (data) { var config = hexo.config; if (config.post_asset_folder) { var link = data.permalink; if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for (var i = 0; i &lt; toprocess.length; i++) { var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function () { if ($(this).attr('src')) { // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if (!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) { // For &quot;about&quot; page, the first part of &quot;src&quot; can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function (elem) { return elem != ''; }); var srcArray = src.split('/').filter(function (elem) { return elem != '' &amp;&amp; elem != '.'; }); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + config.root + link + src); } } else { console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); } }); data[key] = $.html(); } }}); 3. 修改_config.xml4. 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg","link":"/2021/04/12/%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"},{"title":"array","text":"1. 数组特点数组：一种 线性表 数据结构，存储的 元素类型相同 ，在内存中 顺序存储 。 数组最重要的一个性质就是 根据下标随机访问时间复杂度为 O(1) ，例如 a[i] 的寻址公式如下： 1address = baseAddress + i * typeSize 对于二维数组 a[i][j] 来说，多了一个列数 N (java 中的二维数组可以不一致) 1address = baseAddress + (j + i * N) * typeSize 由于需要维护 数组 元素之间的有序性，向数组插入以及删除元素时需要将后面的元素移动位置。因此头部插入以及删除的效率低下，时间复杂度都为 O(n)。而尾部插入以及删除的时间复杂度为 O(1)。 2. 静态数组与动态数组C++ 以及 Java 中的内置数组都是静态数组，不可扩容。 C++ STL提供了std::vector, 而 Java 提供了 ArrayList，它们都是动态数组，容量不够时，可以申请新的空间将原数组的元素拷贝过去。它们都采取了 增倍扩容, 而不是 定量扩容，vector 动态增大 2 倍, ArrayList 动态增大 1.5 倍。 3. 数组越界访问C++ 中越界访问会导致 未定义错误(UB)，有时程序不会报错(正常读写非数字的地址内容)，有时会导致 Segment fault。 例如下面的程序，如果 i 定义在 arr 的前面，那么程序会不断打印hello world，而如果定义在 arr 后面，则只会打印 4 次 hello world. c++ 的内存分区如下 12345678910111213int main() { // int i = 0; int arr[3] = { 0 }; int i = 0; std::cout &lt;&lt; &amp;i &lt;&lt; &quot; &quot; &lt;&lt; &amp;arr[3] &lt;&lt; std::endl; for (; i &lt;= 3; ++i) { arr[i] = 1; std::cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; std::endl; std::cout &lt;&lt; &quot;hello world\\n&quot;; } return 0;}","link":"/2021/05/26/array/"},{"title":"linkedList","text":"1. 链表特点链表：一种 线性表 数据结构，存储的 元素类型相同 ，在内存中 离散分布 。 链表的常见结构：单向链表、循环链表、双向链表、双向循环链表 链表与数组的区别如下图。 2. 时间复杂度站在宏观角度，链表的插入以及删除操作效率高，而数组的插入以及删除操作效率低。当然这只是不严谨的说法，针对不同的应用场景，链表的插入以及删除操作时间复杂度一样可以达到 O(n), 而数组的插入以及删除操作也可以是 O(1)。 例如单链表在结点 n 前插入结点 x ：第一步遍历到 n 的前驱结点，第二步插入 x。时间复杂度为 O(n) + O(1) = O(n)。 在数组的尾部插入以及删除元素（不涉及数组容量的改变）：O(1) 但是从宏观角度来看，数组的插入以及删除操作涉及到一系列元素的移动，而链表的插入以及删除操作只涉及到相邻的几个结点的改变。 因此链表以及数组的宏观操作时间复杂度如下图。 3. 双向链表与单向链表双向链表比起单向链表，每个结点多了一个前驱指针。这使得双向链表中的结点访问其前驱结点的时间复杂度为 O(1)，而单向链表访问其前驱结点的时间复杂度为 O(n)。 4. 哨兵结点哨兵的目的是解决边界问题。单向链表中的插入以及删除操作需要修改前驱结点的 next 指针。链表中的表头结点没有前驱结点，因此程序中需要对插入、删除表头结点时进行边界处理。导致代码实现起来比较繁琐，容易出错。 12345// 1. p 后插入结点 xx-&gt;next = p;p-&gt;next = x;// 2. 删除 p 后的结点p-&gt;next = p-&gt;next-&gt;next; 123456789// 插入表头结点if (p == nullptr) { x-&gt;next = head; head = x;}// 删除表头结点if (p == nullptr &amp;&amp; head != nullptr) { head = head-&gt;next;} 通过在表头结点前添加一个哨兵结点，解决插入表头结点以及删除表头结点的边界处理问题。 可以看到，上述的插入、删除结点需要获取当前结点的前驱结点，有时候这比较麻烦。删除结点时，可以获取将后继结点的值保存到当前结点，通过删除后继结点的方式来删除当前结点。插入结点时，我们可以交换插入结点与当前的结点的数据，通过在其后插入结点，完成结点的插入。这种方式，实际上是将之前的插入、删除操作向后推移了一个结点，因此当插入、删除表尾结点时，要进行边界处理。 我们可以通过在表尾结点后增加一个哨兵结点去除边界情况的处理。 这种方式存在着缺陷，可能导致之前的结点指针失效，例如 p 指向待删除结点，q 指向后继结点，经过删除操作后，p 没有失效，q 成了空悬指针。 链表常见的边界处理 链表为空，能否正常工作 链表只包含单个结点，代码能否正常工作 链表只包含两个结点，代码能否正常工作 代码在处理表头结点和表尾结点时，能否正常工作","link":"/2021/05/27/linkedList/"},{"title":"leetcode-02-06","text":"编写一个函数，检查输入的单链表是否是回文的。 LeetCode 1. 解题思路 使用快慢指针找链表中点 奇数链表找到的就是中点 偶数链表找到的是前半个链表的末尾结点 反转后半个链表 循环遍历两个链表，判断是否有不一样的值 恢复后半个链表 快慢指针找链表中的特定位置的结点特别常见，例如中间位置的结点以及倒数第 k 个结点。 2. 复杂度分析时间复杂度 : O(n) O(n / 2) + O(n / 2) + O(n / 2) + O(n / 2) = O(n) 空间复杂度 : O(1) 额外用到的空间为常数大小 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool isPalindrome(ListNode* head) { if (!head) return true; ListNode *slow = head, *fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } // 链表结点为奇数时，slow 指向中间结点 // 链表结点为偶数时，slow 指向前半个链表末尾结点 ListNode *second = reverseList(slow-&gt;next); bool palindrome = true; for (ListNode *p = head, *q = second; q != nullptr; p = p-&gt;next, q = q-&gt;next) { if (p-&gt;val != q-&gt;val) { palindrome = false; break; } } // 恢复链表 slow-&gt;next = reverseList(second); return palindrome; } ListNode* reverseList(ListNode* head) { ListNode *prev = nullptr, *cur = head, *next = nullptr; while (cur != nullptr) { next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; } return prev; }};","link":"/2021/05/27/leetcode-02-06/"},{"title":"Windows terminal ssh 免密登录 Linux","text":"1. 修改设置- 打开 windows terminal 的 配置文件(json)- 找到 profiles 属性- powershell中通过 new_guid 生成新的 guid- 添加代码123456{ &quot;guid&quot;: &quot;{3a4f3a4b-f4bc-46c6-9b65-94a3a223f3f9}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;UbuntuDesktop&quot;, &quot;commandline&quot;: &quot;ssh cmtang@192.168.29.128&quot;} 2. Linux 存储 windows 公钥- sudo apt install openssh-server- windows 生成 ssh 密钥，C:\\Users\\Chengming\\.ssh- ~/.ssh/authorized_keys 中添加 windows 公钥 id_rsa.pub","link":"/2021/05/28/WindowsTerminal-ssh-linux/"},{"title":"链表常见操作","text":"单向链表反转 LeetCode 206 这里注意，next 的指针是放在 while 循环里赋值的，为了空链表也能正常工作。 123456789ListNode* reverseList(ListNode* head) { ListNode *cur = head, *prev = nullptr, *next = nullptr; while (cur != nullptr) { next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; } } 链表是否有环 LeetCode 141使用快慢指针，必须对空链表进行边界处理。 1234567891011bool hasCycle(ListNode *head) { if (!head) return false; ListNode *slow = head, *fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; // 忽略指针都指向 head 的情况 if (fast == slow) return true; } return false;} 两个有序的链表合并 LeetCode 21边界处理：表头结点的插入 1234567891011121314151617ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode preHead; ListNode *cur = &amp;preHead; while (l1 &amp;&amp; l2) { if (l1-&gt;val &lt;= l2-&gt;val) { cur-&gt;next = l1; l1 = l1-&gt;next; } else { cur-&gt;next = l2; l2 = l2-&gt;next; } cur = cur-&gt;next; } cur-&gt;next = l1 ? l1 : l2; return preHead.next;} 删除链表倒数第 n 个结点 LeetCode 19边界处理：n == size 时 12345678910111213ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode preHead(-1, head); ListNode *slow = &amp;preHead, *fast = &amp;preHead; while (n-- &gt; 0) { fast = fast-&gt;next; } while (fast-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next; } slow-&gt;next = slow-&gt;next-&gt;next; return preHead.next;} 求链表的中间结点 LeetCode 876边界处理：空链表 12345678910ListNode* middleNode(ListNode* head) { if (head == nullptr) return head; ListNode *slow = head, *fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } if (fast-&gt;next) return slow-&gt;next; else return slow;}","link":"/2021/05/28/common-linkedlist-op/"},{"title":"Linux C 系统开发 I&#x2F;O 篇","text":"I/O (input &amp; output)I/O 是一切实现的基础。它分为 stdio (标准IO) 和 sysio (文件IO、系统调用IO)。优先使用 stdio。sysio 取决于操作系统内核，windows 和 linux 提供的文件 io 是不一致的。而 stdio 是 c 中提供的，stdio 依赖于底层的 sysio。windosw 和 linux 是兼容的，例如 fopen linux 环境中依赖于 open，windows 环境下依赖于 openfile。 stdioman 手册第三章 类型FILE 函数stream open &amp; close functions12345678910111213#include &lt;stdio.h&gt;FILE *fopen(const char *pathname, const char *mode);FILE *fdopen(int fd, const char *mode);FILE *freopen(const char *pathname, const char *mode, FILE *stream);Feature Test Macro Requirements for glibc (see feature_test_macros(7)):fdopen(): _POSIX_C_SOURCEint fclose(FILE *stream); fopen 中的 mode 如果使用 r、r+, 则指定的文件必须存在。同时 linux 没有二进制流和文本流的区别。 fopen 返回的 FILE 指针指向的内存在堆上，通过 fclose 释放堆空间。 1234567891011121314151617181920212223#include &lt;stdio.h&gt; // perror#include &lt;stdlib.h&gt;#include &lt;errno.h&gt; // errno#include &lt;string.h&gt; // strerrorint main() { FILE *fp; fp = fopen(&quot;tmp&quot;, &quot;r&quot;); if (fp == NULL) { // fprintf(stderr, &quot;fopen() failed! errno = %d\\n&quot;, errno); // perror(&quot;fopen()&quot;); fprintf(stderr, &quot;fopen(): %s\\n&quot;, strerror(errno)); exit(1); } puts(&quot;OK&quot;); fclose(fp); exit(0);} 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main() { FILE *fp = NULL; int count = 0; while (1) { fp = fopen(&quot;tmp&quot;, &quot;w&quot;); if (fp == NULL) { perror(&quot;fopen(): &quot;); break; } ++count; } fprintf(stdout, &quot;count = %d\\n&quot;, count); exit(0);} 每个进程默认最多能够打开 1024 个文件，默认已经打开了三个文件：stdin, stdout, stderr 12fopen(): : Too many open filescount = 1021 文件权限默认公式：0666 &amp; ~umask，umask 越大，生成的文件权限越小。 input of characters and strings123456789101112#include &lt;stdio.h&gt;int fgetc(FILE *stream);int getc(FILE *stream);int getchar(void);int ungetc(int c, FILE *stream);// 缺点：只能读取指定大小的内容。char *fgets(char *s, int size, FILE *stream); fgetc 读取失败返回 EOF，fgets 读取失败返回 NULL。 fgets - 读取 `size - 1` 个字符，例如 `abcde`，size 为 5, s 为 `abcd\\0` - 读取到 `\\n`，例如 `abc`, size 为 5, s 为 `abc\\n\\0` output of characters and strings123456789int fputc(int c, FILE *stream);int putc(int c, FILE *stream);int putchar(int c);int fputs(const char *s, FILE *stream);int puts(const char *s); binary stream input/output12345#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 1234// afread(buffer, 1, 10, fp);// bfread(buffer, 10, 1, fp); fp 指向的数据量不小于10个字节 - a 返回 10， 读取到 10 个字节. - b 返回 1，读取到 10 个字节. fp 指向的数据量只有 10 个字节. - a: 返回 5, 读取到 5 个字节. - b：返回 0, 这时不知道自己读取了几个字节. 建议 fread 以及 fwrite 中的 size 设定为 1, 即块大小永远设定为 1. formatted output conversion123456789101112#include &lt;stdio.h&gt;// 标准输出int printf(const char *format, ...);// 文件输出int fprintf(FILE *stream, const char *format, ...);// 文件描述符int dprintf(int fd, const char *format, ...);// 字符串int sprintf(char *str, const char *format, ...);// 指定大小的字符串, 防止数组越界int snprintf(char *str, size_t size, const char *format, ...); formatted input conversion缺点：读取字符串时，不知道目标字符串的大小。 12345#include &lt;stdio.h&gt;int scanf(const char *format, ...);int fscanf(FILE *stream, const char *format, ...);int sscanf(const char *str, const char *format, ...); reposition a streamfseek 以及 ftell 缺点：参数类型以及返回类型为 long，32 位平台下，只能支持 2GB 左右大小的文件。 1234567#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence);long ftell(FILE *stream);void rewind(FILE *stream); fflush() 问题man fopen 显示 no manual entry123// 安装标准 c 的帮助文档sudo apt-get install libc-devsudo apt-get install glibc-doc 执行文件时，需要加 ./执行文件时不会在当前目录查找。","link":"/2021/05/28/linux-c-io/"},{"title":"LeetCode 042 接雨水","text":"给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 方法一：暴力法（按列求和）求出数组每个元素能接多少雨水。 解题思路 当前元素能不能接水，接多少水。取决于当前元素左边的最高边界（左边的木板）以及右边的最高边界（右边的木板）。 只有两边的边界都大于当前列的高度，当前列才能存储雨水。 当前列存储的雨水量为两个边界的最小值与当前高度的差值。 算法 step.1 雨水量 ans = 0 step.2 循环遍历每列 height[i] step.3 找出当前列的两个边界 left、right step.4 计算当前列存储的雨水量 ans += min(left, right) - height[i] 复杂度分析 时间复杂度：O(n^2) 空间复杂度：O(1) 实现123456789101112131415161718192021class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int ans = 0, size = height.size(); // 两端的列一定存不下雨水 for (int i = 1; i &lt; size - 1; ++i) { int left = 0, right = 0; // 计算左边边界 for (int j = i - 1; j &gt;= 0; --j) { left = std::max(left, height[j]); } // 计算右边边界 for (int j = i + 1; j &lt; size; ++j) { right = std::max(right, height[j]); } int hi = std::min(left, right); ans += hi &gt; height[i] ? hi - height[i] : 0; } return ans; }}; 方法二：动态规划解题思路空间换时间：方法一中找当前列的左右边界时，重新遍历了左右的所有元素。经过思考，可以用递归定义左右边界： left[n] = max(left[n-1], height[n-1]) right[n] = max(right[n+1], height[n+1]) 第 n 列的左右边界分别依赖 n-1 的左边界，以及 n+1 的右边界。我们可以用两个数组保存左右边界，这样一来，遍历每列的时间复杂度就降到了 O(n)，只要保证计算两个数组的时间复杂度为 O(n)，这样总体的时间复杂度就会降为 O(n)。 算法 step.1 雨水量 ans = 0 step.2 计算左边界数组 left[]，从左向右计算。 step.3 计算右边界数组 right[]，从右向左计算。 step.2 循环遍历每列 height[i] step.4 计算当前列存储的雨水量 ans += min(left[i], right[i]) - height[i] 复杂度分析时间复杂度：O(n) + O(n) + O(n) = O(n)空间复杂度：O(n) 实现123456789101112131415161718192021class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int ans = 0, size = height.size(); // left[i]: i 的左边界 // right[i]: i 的右边界 std::unique_ptr&lt;int[]&gt; left(new int[size]()), right(new int[size]()); for (int i = 1; i &lt; size; ++i) { left[i] = std::max(left[i - 1], height[i -1]); } for (int i = size - 2; i &gt;= 0; --i) { right[i] = std::max(right[i + 1], height[i + 1]); } // 两端的列一定存不下雨水 for (int i = 1; i &lt; size - 1; ++i) { int hi = std::min(left[i], right[i]); ans += hi &gt; height[i] ? hi - height[i] : 0; } return ans; }}; 方法三：双指针解题思路方法二中，left、right 数组中的元素只会使用一次，因此可以考虑在循环所有列时同步更新 left、right，将空间复杂度降为 O(1)。对于 left 数组很简单就能代替, 而 right 数组的更新方向与循环所有列的方向相反。我们可以使用双指针来完成 left、right 的更新。 算法 step.1 双指针 left = 0, right = size - 1。 step.2 left 的左边界 maxLeft = 0, right 的右边界 maxRight = 0。 step.3 当 maxLeft &lt; maxRight 时，说明 left 的最小边界为 maxLeft。相反说明 right 的最小边界为 maxRight。 step.4 计算 left 或者 right 的存水量，移动相应的指针, 直到所有的列都已经遍历。 复杂度分析时间复杂度：O(n) 空间复杂度：O(1) 实现1234567891011121314151617181920212223class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int ans = 0, size = height.size(); int maxLeft = 0, maxRight = 0; int left = 0, right = size - 1; while (left &lt;= right) { // 此时 left 的最小边界为 maxLeft if (maxLeft &lt; maxRight) { ans += maxLeft &gt; height[left] ? maxLeft - height[left] : 0; maxLeft = std::max(maxLeft, height[left]); left++; } // 此时 right 的最小边界为 maxRight else { ans += maxRight &gt; height[right] ? maxRight - height[right] : 0; maxRight = std::max(maxRight, height[right]); right--; } } return ans; }};","link":"/2021/06/02/leetcode-042/"},{"title":"leetcode 025 k个一组翻转链表","text":"给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 进阶： - 你可以设计一个只使用常数额外空间的算法来解决此问题吗？ - 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 方法一：暴力翻转解题思路在遍历的过程中，将当前遍历的结点保存到数组中，直到遍历完一组，根据刚刚保存的数组对这一组链表进行翻转。如果链表遍历完成，但是剩余元素不足一组，直接返回。翻转结点时只翻转结点的值，不需要真的翻转结点。 算法 step.1 创建一个 kvec 保存链表结点，大小为 k。 step.2 循环遍历结点，设置一个计数值 i = 0，每遍历一个结点，将指针存入 kvec，i + 1 step.3 当 i == k 时，说明遍历完一组结点，开始对该组结点，进行翻转。 step.4 定义左指针 m = 0, 右指针 n = k - 1, 交换 m、n 指向结点的值。交换完成。 m 右移, n 左移，直至 m &gt;= n。 step.5 清空 kvec，继续遍历结点。 复杂度分析时间复杂度：n * O(1) = O(n) ，每遍历一组结点(k个)，才会进行一次循环用以反转 k 个结点，采用均摊分析的思想，因此每个结点的遍历只需要 O(1) 的时间复杂度。 空间复杂度: O(k)，额外创建了一个容量为 k 的 vector 用来保存一组结点。 实现123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseKGroup(ListNode* head, int k) { std::vector&lt;ListNode *&gt; kvec{}; kvec.reserve(k); ListNode *cur = head; for (int i = 0; cur != nullptr; cur = cur-&gt;next) { kvec.push_back(cur); ++i; if (i == k) { for (int m = 0, n = k - 1; m &lt; n; ++m, --n) { std::swap(kvec[m]-&gt;val, kvec[n]-&gt;val); } i = 0; kvec.clear(); } } return head; }}; 递归翻转解题思路链表的题目往往可以与递归联系在一起，因为链表可以用递归的方式定义 (一个结点后挂着另一个链表)。 问题拆分成子问题：对给定链表的前 k 个结点翻转，对剩下的子链表再次进行 k 个结点翻转。 递归基：链表不足 k 个，不需要翻转，直接返回。 算法复杂度分析时间复杂度：该递归为线性递归，栈的层数为 n / k 取上界，而每次调用的时间复杂度为 O(k)，因此时间复杂度为 O(n) 空间复杂度：栈的层数为 n / k 取上界，而每次调用的空间复杂度为 O(1)，因此空间复杂度为 O(n / k) 实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode *nextHead = head; int nodeNum = 0; while (nodeNum &lt; k) { // 剩余结点不足 k 个，不需要翻转直接返回 (平凡情况) if (nextHead == nullptr) { return head; } nextHead = nextHead-&gt;next; ++nodeNum; } // 翻转后面的链表 nextHead = reverseKGroup(nextHead, k); // 翻转链表开头的 k 个结点 head = reverseTopKGroup(head, k, nextHead); return head; } ListNode *reverseTopKGroup(ListNode *head, int k, ListNode *nextHead) { // head 至少有 k 个结点 ListNode *prev = nullptr, *cur = head, *next = nullptr; for (int i = 0; i &lt; k; ++i) { next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; } head-&gt;next = nextHead; return prev; }};","link":"/2021/06/03/leetcode-025/"},{"title":"leetcode-160","text":"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 方法一：栈解题思路判断两个链表的相交，因为长度可能不一致，需要从链表尾部开始进行比较。根据这个思路借助栈来完成链表的反序遍历。 算法step.1 创建栈 sa, sb 分别存储链表 a 和链表 b 的结点step.2 遍历链表 a 和链表 b, 将结点压入栈中step.3 创建变量 res = nullptr 存储结果step.4 若 sa 和 sb 不为空，弹出栈顶元素，栈顶元素相同，更新 resstep.5 若栈空或者栈顶元素不相同, 直接返回 res 复杂度分析时间复杂度：O(m + n)空间复杂度：O(m + n) 实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *a = headA, *b = headB; std::stack&lt;ListNode *&gt; sa, sb; while (a != nullptr) { sa.push(a); a = a-&gt;next; } while (b != nullptr) { sb.push(b); b = b-&gt;next; } ListNode *res = nullptr; while (!sa.empty() &amp;&amp; !sb.empty()) { if (sa.top() == sb.top()) { res = sa.top(); } else { break; } sa.pop(); sb.pop(); } return res; }}; 方法二：哈希表复杂度分析时间复杂度：O(m + n)空间复杂度：O(m) 实现123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { std::unordered_set&lt;ListNode *&gt; as; for (auto cur = headA; cur != nullptr; cur = cur-&gt;next) { as.insert(cur); } for (auto cur = headB; cur != nullptr; cur = cur-&gt;next) { if (as.find(cur) != as.cend()) { return cur; } } return nullptr; } }; 方法三：双指针解题思路 存在相交结点(k != 0)： 链表长度不相等(k1 != k2): k1 - 1 + k + 1 + k2 + 1 = k2 - 1 + k + 1 + k2 + 1(都指向第一个相交结点) 链表长度相等(k1 == k2): k1 = k2(都指向第一个相交结点) 不存在相交结点(k == 0): 链表长度不相等(k1 != k2): k1 + k2 + 1 = k2 + k1 + 1(都为nullptr) 链表长度相等(k1 == k2): k1 == k2 (都为nullptr) 算法复杂度分析时间复杂度：O(m + n)空间复杂度：O(1) 实现12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *a = headA, *b = headB; while (a != b) { a = a ? a-&gt;next : headB; b = b ? b-&gt;next : headA; } return a; } };","link":"/2021/06/04/leetcode-160/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Gitee","slug":"Gitee","link":"/tags/Gitee/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Windows Terminal","slug":"Windows-Terminal","link":"/tags/Windows-Terminal/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"LinuxC 系统开发","slug":"LinuxC-系统开发","link":"/tags/LinuxC-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"C++那些事","slug":"C-那些事","link":"/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Linux系统编程","slug":"Linux系统编程","link":"/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}]}