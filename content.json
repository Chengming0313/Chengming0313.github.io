{"pages":[],"posts":[{"title":"C++ Primer 5th 第七章课后习题","text":"环境提供的所有代码，如未说明, 则指的是 Windows Windows12gcc --version : gcc.exe (tdm64-1) 9.2.0g++ xxx -o xxx.exe -g -Wall -fexec-charset=GBK -std=c++11 Linux1gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44) 7.1.1 节练习EX7.1123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;struct Sales_data { std::string bookNo; std::string bookName; unsigned units_sold; double revenue;};int main() { Sales_data total; if (std::cin &gt;&gt; total.bookNo &gt;&gt; total.units_sold &gt;&gt; total.revenue) { Sales_data trans; while (std::cin &gt;&gt; trans.bookNo &gt;&gt; trans.units_sold &gt;&gt; trans.revenue) { if (total.bookNo == trans.bookNo) { total.units_sold += trans.units_sold; total.revenue += trans.revenue; } else { std::cout &lt;&lt; total.bookNo &lt;&lt; &quot; &quot; &lt;&lt; total.units_sold &lt;&lt; &quot; &quot; &lt;&lt; total.revenue / total.units_sold &lt;&lt; '\\n'; total = trans; } } std::cout &lt;&lt; total.bookNo &lt;&lt; &quot; &quot; &lt;&lt; total.units_sold &lt;&lt; &quot; &quot; &lt;&lt; total.revenue / total.units_sold &lt;&lt; '\\n'; } else { std::cerr &lt;&lt; &quot;No data!\\n&quot;; } return 0;} 7.1.2 节练习EX7.21","link":"/2021/04/06/C-Primer-5th-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"},{"title":"C++ Primer 5th 第一章课后习题","text":"环境 Windows12gcc --version : gcc.exe (tdm64-1) 9.2.0g++ xxx -o xxx.exe -g -Wall -fexec-charset=GBK -std=c++11 Linux1gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44) 1.1 节练习EX1.1 查阅你使用的编译器的文档, 确定它所使用的文件命名约定, 编译并运行第 2 页的 main 程序. Windows直接使用 g++ ex1_1.cpp 默认生成 a.exe可执行文件通过 -o 指定输出文件名, g++ ex1_1.cpp -o ex1_1.exe Linux直接使用 g++ ex1_1.cpp 默认生成 a.out可执行文件通过 -o 指定输出文件名, g++ ex1_1.cpp -o ex1_1Linux 可执行文件没有后缀名要求EX1.2 改写程序, 让它返回 -1 。返回值 -1 通常被当作程序错误的标识。重新编译并运行你的程序, 观察你的系统如何处理 main 返回的错误标识. Windows123failed to launch (exit code: 1)PS F:\\Project\\CodeProject\\CODE_CPP\\CPP_Primer\\ch01&gt; echo $?False Linux12[cheng@VM-4-15-centos ch01]$ echo $?255 1.2 节练习EX1.3 编写程序, 在标准输出上打印Hello, World.12345#include &lt;iostream&gt;int main() { std::cout &lt;&lt; &quot;Hello, World&quot; &lt;&lt; std::endl; return 0;}","link":"/2021/04/06/C-Primer-5th-%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"},{"title":"C++ Primer 5th 第七章笔记","text":"类 抽象数据类型 class + struct 访问控制 public private protected 类的其它特性 类的作用域 构造函数 类的静态成员 抽象数据类型定义抽象数据类型 使用 struct 或者 class 来定义一个类(抽象数据类型)C++中, 抽象数据类型 和 类 含义相同吗?struct 与 class 的区别在于成员的默认访问权限以及继承类型123456789struct A { int _data; void print() { std::cout &lt;&lt; &quot;hello\\n&quot;; }};class B { int _data; void print() { std::cout &lt;&lt; &quot;hello\\n&quot;; }}; 123456A a;B b;std::cout &lt;&lt; a._data &lt;&lt; '\\n';a.print();std::cout &lt;&lt; b._data &lt;&lt; '\\n'; // errorb.print(); // error 头文件的组织结构一般来说, 类的声明和实现分开, 分为头文件以及源文件.123456789101112131415161718// 1. 防卫式声明#ifndef XXX_H#define XXX_H// 2. 前置声明#include &lt;string&gt;class A;void fun1();// 3. 类的声明class A {};// 4. 部分函数的实现(`内联函数`、`模板函数`) + 非成员函数的声明// 有些函数的定义需要放在头文件中#endif member function member function 的声明必须在类的内部, 而它的定义可以在类的内部也可以在类的外部.定义在类内部的 member function 隐式 inline(可以显式使用 inline 修饰) 外部定义成员变量以及函数时, 需要使用 ClassName:: 修饰变量或者函数名 this pointer member function 通过 this pointer 来隐式地访问调用它的 object return bookNo; = return this-&gt;bookNo; 当出现重名时, 可以使用 this 显式访问 data member 以及 member function 需要返回对象的引用时, 使用 return *this this pointer 的类型为 T * const const member function 与 this pointer1std::string isbn() const {return bookNo;} const member funciton 中的 this pointer 类型为 T const * const因此普通对象不能调用 const member function, 而 const 对象 可以调用所有成员函数 const member funtion 与 non-const member function 可以重载 构造函数 无论何时, 只要类的对象被创建, 就会执行构造函数 构造函数形式: 无返回类型 函数名和类名相同 只有构造函数执行完成, const 对象 才真正具有了 const 属性, 因此构造函数可以对 const 对象 写值 默认构造函数 以及 合成默认构造函数没有任何参数的构造函数叫做 默认构造函数用户没有 自定义构造函数 时, 编译器会自动生成一个 合成的默认构造函数 .使用 = default 要求编译器生成默认的构造函数 合成默认构造函数的缺点 定义在块中的内置类型或者复合类型默认初始化时, 值未定义 成员变量没有默认构造函数时, 无法默认初始化 初始值列表12345678910// 初始值列表A(int data1, int data2) : _data1(), _data2(data2) {}// 赋值A(int data1, int data2) { _data1 = data1; _data2 = data2;}// 类内初始值int _data1 = 0;int _data2 = 0; 最好使用初始值列表, 而不是 类内初始值 以及 函数体内赋值. 初始值列表 会覆盖 类内初始值. 函数体内赋值 会先初始化成员变量, 再赋值. 没有出现初始值列表的成员变量, 将通过 类内初始值 或者执行 默认初始化 . Big Three(拷贝构造 拷贝赋值 析构) 用户没有定义时, 编译器会自动合成 管理动态内存的类通常不能依赖于编译器自动合成的函数 (浅拷贝)","link":"/2021/04/06/C-Primer-5th-%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%AC%94%E8%AE%B0/"},{"title":"博客搭建指南","text":"平台本博客网站的平台如下。 Hexo Icarus Gitee 搭建 HexoHexo 官网为了搭建 Hexo 环境, 用户需要先配置好 Node.js 以及 Git 环境。 新建一个文件夹，用来存放项目文件 进入该文件夹, 打开 Git Bash hexo init npm install npm install hexo-deployer-git --save hexo g hexo s 1npm install 可能针对某个特定的包报错, 可以先安装报错的包[npm install xxx --ignore-scripts] 切换 Icarus 主题Icarus 官方文档 Gitte Page 完成同步 创建 gitte 账户, 并添加本地主机的 ssh 公钥1234// Gittessh -T git@gitte.com// Githubssh -T git@github.com 修改_config.yml配置文件12345deploy: type: git # 可以指定多个 repo repo: git@gitee.com:chengming0313/chengming0313.git branch: master hexo d上传静态文件(.deploy_git) Gitte 新建分支 hexo hexo 设为默认分支 git clone xxx只保留.git文件夹, 删除其它所有文件夹 将博客的源文件复制过来(除了 .deploy_git)记得删除 themes 下主题里的 .git文件夹 上传源文件到 hexo 分支123git add .git commit -m &quot;init&quot;git push 更换本地主机 git clone xxx npm install npm install hexo-deployer-git --save hexo g hexo s hexo d","link":"/2021/04/06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"},{"title":"C++ 初始化类型","text":"参考资料CPP Reference知乎回答 初始化类型 list initialization aggregate initialization value initialization default initialization zero initialization direct initialization copy initialization 1. list initialization [new] T [objectName] {arg1, arg2, …} list initialization 分为两种, 一种是 aggregate type，它会利用 args 对其中的成员逐个初始化, args 不够会对剩余的成员进行 value initialization。另一种是 非 aggerate type，它会调用最匹配的构造函数。 123456789101112131415161718192021// 列表初始化// 非 aggregate 类型, 直接查找匹配的构造函数std::string str1{ &quot;123&quot; };std::string str2 = { &quot;456&quot; };std::string str3 = std::string{ &quot;789&quot; };std::string *str4 = new std::string{ &quot;xxx&quot; };std::cout &lt;&lt; str1 &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; &quot; &quot; &lt;&lt; str3 &lt;&lt; &quot; &quot; &lt;&lt; *str4 &lt;&lt; '\\n';// aggregate initialization, 使用{}中的参数逐个初始化, 不足的使用 value// initializationstd::vector&lt;int&gt; c1{ 1, 2, 3, 4 };std::array&lt;int, 8&gt; c2 = { 4, 5, 6, 7 };for (auto item : c1) { std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n';for (auto item : c2) { std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n'; 1234// 结果123 456 789 xxx1 2 3 44 5 6 7 0 0 0 0 2. value initialization 对于class 类型的变量, value initialization 会优先考虑用户自定义的默认构造函数, 否则先进行 value initialization，再调用合成的默认构造函数 对于非class类型的变量，直接进行 value initialization 123456789101112131415161718// class 类型变量，用户自定义默认构造函数class A {public: A() : _data(999) {} void Print() { std::cout &lt;&lt; _data &lt;&lt; '\\n'; }private: int _data;};A a1{};A a2 = {};A a3 = A{};A *a4 = new A{};a1.Print();a2.Print();a3.Print();a4-&gt;Print(); 12345// 结果999999999999 12345678910111213141516171819202122232425// class 类型变量，合成默认构造函数class A {public: A() = default; void Print() { std::cout &lt;&lt; _data &lt;&lt; '\\n'; }private: int _data;};// value initializationA a1{};A a2 = {};A a3 = A{};A *a4 = new A{};a1.Print();a2.Print();a3.Print();a4-&gt;Print();// default initializationA a5;A a6 = A();A *a7 = new A();a5.Print();a6.Print();a7-&gt;Print(); 1234567891011// 结果// value initialization0000// default initialization495097600 6. direct initialization7. copy initialization 注意有些时候编译器会对copy initializaiton进行优化。 例 1 12345678910111213141516// example 1class A {public: A(int data) : _data(data) { std::cout &lt;&lt; &quot;data constructor...\\n&quot;; } A(A const &amp;x) { this-&gt;_data = x._data; std::cout &lt;&lt; &quot;copy constructor...\\n&quot;; }private: int _data;};// main functionA a = 999; A a = A(999); 12345// result// 第一行 : 隐式转换 999 -&gt; A// 第二行 : 等价于 A a(999);data constructor...data constructor... 12345678// 取消 g++ 优化 : g++ -o test test.cpp -fno-elide-constructors// result// 第一行 : 先隐式转换执行 A(999)，然后调用 copy ctor// 第二行 ： 先调用 普通ctor，再调用 copy ctordata constructor...copy constructor...data constructor...copy constructor... 例 2 12345678// example 2// 返回值优化A get() { return A();}void usage03() { A a = get();} 1234567891011// usage03()// g++编译器会对函数返回值优化, 这里并不会创建临时变量来存放返回值0x79fdef constructor // a0x79fdef destructor // a 析构// -fno-elide-constructors, 取消 g++ 优化0x78fd8f constructor // get() 中的匿名对象0x78fddf copy constructor // 临时对象存储返回值0x78fd8f destructor // 匿名对象析构0x78fdde copy constructor // a0x78fddf destructor // 临时对象析构0x78fdde destructor // a 析构","link":"/2021/04/11/CppInitializationType/"},{"title":"C++ const","text":"本系列参考第三方文档 C++那些事 const const 含义 定义一个 const 变量 const 的一些特性 指针与 const 函数与 const 类与 const 1. const 含义 const 用来修饰变量，表示变量的值不可改变(赋值), 是一个 只读变量 。 const 修饰的变量不一定是一个 常量表达式 , 常量表达式除了要求值不可更改之外, 还要求在编译过程中就能得到计算结果。 一般使用 constexpr 来修饰一个常量表达式, 编译器会对变量进行验证。不符合要求会报错。 声明 constexpr 的类型有所限制, 必须属于 字面值类型 。 2. 定义一个 const 变量 const 变量必须初始化 const 变量不能赋值 const 修饰的 类变量 , 只有在 构造函数 完成后才算真正具有 const 属性。 123const int i1; // error: uninitialized const 'i1'const int i = 0;i = 1; // error: assignment of read-only variable 'i' 3. const 的一些特性 用 const 代替 #define如下, #define 定义的 SIZE_NUM, 在 预处理过程 就已经被 10 替换, 不会进入 符号表。程序出现问题时不好定位。 12#define SIZE_NUM = 10const int SIZE_NUM = 10; const 变量默认为文件局部变量 非 const 变量不同文件访问 123456789101112131415// g++ -o main main.cpp other.cpp// other.cppint i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;extern int i;int main() { std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} const 变量不同文件访问 const 变量需要显式使用 extern 定义, 才能跨文件访问 1234567891011121314151617// other.cppextern const int i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;// 这里不用 const 声明也能够通过, i = 200 不会报错, 但是// 程序运行时会出错extern const int i;int main() { // i = 200; std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} 4. 指针与 const const 总是优先与它左侧的符号配对 12345const char * a; // pointer to const charchar const char * a; // 同上char *const a; // const pointer to charchar const *const a; // const pointer to const charconst char *const a; // 同上 指向常量的指针（底层 const） 可以不用初始化, 不能通过指针解引用去修改它的值 12345char const * a; // 底层 const 可以不用初始化char ch = 'a';a = &amp;ch;*a = 'x'; // error, 不能通过指针修改它的值 可以指向非 const 的变量 12345int i = 10;int const *pi = &amp;i;std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n';std::cout &lt;&lt; ++i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n'; 1210 1011 11 不能用 void * 指向 const 变量, 必须使用 const void * 123const int a = 10;void const *ptr1 = &amp;a;void * ptr2 = &amp;a; // error 常量指针（顶层 const） 必须初始化, 指针不能修改 1234int a = 10;int *const ptr = &amp;a;int *const ptr2; // error: uninitialized const 'ptr2'ptr = nullptr; // error: assignment of read-only variable 'ptr' error: const T * —-&gt; T * const 12int const a = 10;int *const ptr = &amp;a; // error: invalid conversion from 'const int*' to 'int*' 5. const 变量的拷贝操作 顶层 const 对象可以拷贝给非顶层 const 对象 1234const int ci = 100;int i = ci; // i: 100int *const p1 = &amp;i;int * p2 = p1; 非顶层 const 对象也可以拷给顶层 const 对象 12345// -&gt; 顶层 constint j = 200;const int cj = j;int * ptr1 = &amp;j;int *const ptr2 = ptr1; 底层 const 对象不能拷给非底层 const 对象 1234567891011int const &amp;cr1 = 100;int &amp;r1 = cr1; // error: binding reference of type 'int&amp;' to 'const int' discards qualifiersint const *p3 = &amp;ci;int * p4 = p3; // error: invalid conversion from 'const int*' to 'int*'// T const * const -&gt;int const *const p5 = &amp;ci;int * p6 = p5; // error: invalid conversion from 'const int*' to 'int*'int const * p7 = p5;int *const p8 = p5; // error: invalid conversion from 'const int*' to 'int*' 非底层 const 对象可以拷给底层 const 对象 1234567int &amp; r2 = j;int const &amp;cr2 = r2;int * ptr3 = &amp;j;int const *ptr4 = ptr3;int const *const ptr5 = ptr3; 6. 函数与 const6.1 修饰返回值 return by const value，一般情况下,，没有意义。一些特殊情况下是有意义的, 详见Effective C++ 条款21。 123const int get() {return 1;} // 无意义// 这是有意义的, 防止出现 (a * b) = c;const Rational operator*(Rational const &amp;lhs, Rational const &amp;rhs); return by const reference 返回普通引用, 可以修改返回值, 可以作为左值使用 1234567891011121314std::string &amp;Get(std::string &amp;a) { return a;}int main() { std::string str = &quot;123456&quot;; // 这里要用 &amp;, 不然不是引用 std::string &amp;str2 = Get(str); str2 = &quot;xxxxxx&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; Get(str) = &quot;hello world&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; return 0;} 12xxxxxx xxxxxxhello world hello world 返回常量引用，不能修改 12345678int main() { std::string str = &quot;123456&quot;; // 这里要用 const &amp; std::string const &amp;str2 = GetConst(str); std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; std::cout &lt;&lt; GetConst(str).length() &lt;&lt; std::endl; return 0;} return by T const * 1234567int const *Get(int *p) { return p;}int a = 10;int const *p1 = Get(&amp;a);int * p2 = Get(&amp;a); // error return by T * const1234567int *const Get2(int *p) { return p;}int a = 10;int *const p3 = Get2(&amp;a);int * p4 = Get2(&amp;a); 6.2 修饰参数 普通的 顶层 const (不是 T const &amp;)使用普通的 顶层 const 作为函数参数，没有意义, 函数收到的是一个副本。 12void fun1(int const val);void fun2(int *const ptr); 底层 const通过传入 T const * 的方式, 使得函数能够通过指针访问函数体外的对象, 又保证了数据的不可修改。 1void fun1(int const *p); T const &amp;pass by const reference 能让函数直接通过变量名访问作用域外的对象, 还能保证数据的 read only 1void fun1(std::string const &amp;str); 对于类类型的变量来说, 使用pass by value 的方式传值, 在拷贝过程中对象的拷贝构造以及析构都会消耗时间, 效率较低。我们可以使用 pass by pointer to const 以及 pass by const reference 来提高效率, 同时保证数据的安全性。 7. 类与 const const member function 普通的member function 中的 this pointer 类型为 T *, 而 const member function 中的 this pointer 类型为 T const *。 对于 const object来说, 它不能用来给普通的this pointer初始化, 它只能给const member function中T const *类型的this pointer初始化。 对于普通的 object, 它即可以使用const member function, 又可以使用普通的 member function。因为T * 既可以给 T * 初始化, 又可以给 T const * 初始化。 除了函数参数列表, 是否是 const member function, 也可以进行重载. 普通的 object 默认调用 非 const member function. 12345678910111213class A {public: void print() const { std::cout &lt;&lt; &quot;const print()\\n&quot;; } void print() { std::cout &lt;&lt; &quot;print()\\n&quot;; }};int main() { A a; A const ca; a.print(); ca.print(); return 0;} 123// 结果print()const print() const 成员 这里讨论一下类内初始值与初始值列表的优先级。初始值列表的优先级比类内初始值要高。只有没有为该成员设定初始值列表时, 它才会使用类内初始值进行初始化。 1234567891011121314class A {public: A() : _a(1) {} void Print() { std::cout &lt;&lt; _a &lt;&lt; &quot;\\n&quot;; }private: int _a = 0;};int main() { A a; a.Print(); return 0;} 12// 结果1 类中的 const 成员可以使用类内初始值的方式初始化 1const int _a = 999; 类中的 const 成员可以使用初始值列表的方式初始化 12const int _a;A() : _a(999) {} 不能在构造函数中用赋值表达式初始化 const 成员, 在进入构造函数体之前, 成员的初始化过程已经结束。 12const int _a;A() { _a = 999; } // error 当要表示类中共享的常量时, 通常使用 static const 修饰 使用类内初始值的方式定义 static const 1static const int _a = 999; // 类内初始值的方式初始化 static const 变量 采用与一般 static 变量一样的方法, 类内声明, 类外定义 1234// in classstatic const int _a;// 类的实现文件const int A::_a = 999; // 需要去除 static 符号","link":"/2021/04/11/C-const/"},{"title":"引用本地图片","text":"在hexo博客中引用本地图片 npm hexo-asset-image --save 替换/node_modules/hexo-asset-image/index.js内容 修改_config.xml 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg 1. npm hexo-asset-image --save2. 替换/node_modules/hexo-asset-image/index.js内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) { return str.split(m, i).join(m).length;}var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function (data) { var config = hexo.config; if (config.post_asset_folder) { var link = data.permalink; if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for (var i = 0; i &lt; toprocess.length; i++) { var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function () { if ($(this).attr('src')) { // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if (!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) { // For &quot;about&quot; page, the first part of &quot;src&quot; can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function (elem) { return elem != ''; }); var srcArray = src.split('/').filter(function (elem) { return elem != '' &amp;&amp; elem != '.'; }); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + config.root + link + src); } } else { console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); } }); data[key] = $.html(); } }}); 3. 修改_config.xml4. 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg","link":"/2021/04/12/%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"},{"title":"Cpp5thExercise9","text":"C++ Primer 5th 第九章 习题环境 Windows 12gcc --version : gcc.exe (tdm64-1) 9.2.0g++ xxx -o xxx.exe -g -Wall -fexec-charset=GBK -std=c++11 Linux 1gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44) 9.1 节练习 9.1 123456优先级：vector -&gt; deque -&gt; list(a) vector : 先在尾部插入, 然后排序(b) deque: 在尾部插入，头部删除(c) vector, 元素较小且数目较多, 不要使用 list 或者 forward_list， 9.2 节练习 9.2 1std::list&lt;std::deque&lt;int&gt;&gt; c; 9.2.1 节练习 9.3 121. 他们指向同一个容器中的元素，或者末尾元素后一个位置2. 递增 begin 一定能够得到 end 9.4 1234567bool find(std::vector&lt;int&gt;::const_iterator begin, std::vector&lt;int&gt;::const_iterator end, int target) { while (begin != end) { if (*begin == target) return true; ++begin; } return false;} 9.5 1234567std::vector&lt;int&gt;::const_iterator find(std::vector&lt;int&gt;::const_iterator begin, std::vector&lt;int&gt;::const_iterator end, int target) { while (begin != end) { if (*begin == target) return begin; ++begin; } return false;} 9.6 1234list&lt;int&gt; lst1;list&lt;int&gt;::iterator iter1 = lst1.begin(), iter2 = lst1.end();while (iter1 != iter2)// ... 9.2.2 节练习 9.7 1vector&lt;int&gt;::size_type 9.8 1list&lt;string&gt;::const_iterator、list&lt;string&gt;::iterator 9.2.3 节练习 9.9 123begin 实际上有两个，非const 返回的是 xxx::iterator, const 返回 xxx::const_iteratorcbegin 无论是不是 const 对象, 返回的是 xxx::const_iterator如果不需要修改元素，推荐使用 cbegin 9.10 1234vector&lt;int&gt; v1;const vector&lt;int&gt; v2; auto it1 = v1.begin(), it2 = v2.begin(); // vector&lt;int&gt;::iterator，vector&lt;int&gt;::const_iteratorauto it3 = v1.cbegin(), it4 = v4.begin(); // vector&lt;int&gt;::const_iterator，vector&lt;int&gt;::const_iterator 9.2.4 节练习 9.11 1234567891011121314151617std::vector&lt;int&gt; c1; // 空std::vector&lt;int&gt; t1{ 1, 2, 3 };std::vector&lt;int&gt; c2(t1); // 1, 2, 3std::vector&lt;int&gt; c3 = t1; // 1, 2, 3// c4 与 c5 差别？// 直接初始化与拷贝初始化？std::vector&lt;int&gt; c4{ 4, 5, 6 }; // 4, 5, 6std::vector&lt;int&gt; c5 = { 4, 5, 6 }; // 4, 5, 6std::vector&lt;int&gt; t2{ 7, 8, 9 };std::vector&lt;int&gt; c6(t2.cbegin(), t2.cend() - 1); // 7, 8std::vector&lt;int&gt; c7(5); // 0, 0, 0, 0, 0std::vector&lt;int&gt; c8(3, 9); // 9, 9, 9 9.12 12copy ctor 复制所有的元素iterator ctor 只会复制 [begin, end) 之间的元素 9.13 123456// 使用迭代器初始化容器, 元素类型必须要相容std::list&lt;int&gt; lst{ 1, 2, 3, 4 };std::vector&lt;double&gt; v1(lst.cbegin(), lst.cend());std::vector&lt;int&gt; v2{ 6, 7, 8, 9 };std::vector&lt;double&gt; v3(v2.cbegin(), v2.cend()); 9.14 123std::list&lt;const char *&gt; lst{ &quot;123&quot;, &quot;456&quot;, &quot;789&quot; };std::vector&lt;std::string&gt; v;v.assign(lst.cbegin(), lst.cend()); 9.2.7 节练习 9.15 123456789101112131415std::vector&lt;int&gt; v1{ 1, 2, 3, 4 };std::vector&lt;int&gt; v2{ 1, 2, 3, 4 };std::vector&lt;int&gt; v3{ 1, 2, 3, 4 };std::vector&lt;int&gt; v4{ 2, 3, 4 };if (v1 == v2) std::cout &lt;&lt; &quot;v1 equal to v2\\n&quot;;else std::cout &lt;&lt; &quot;v1 not equal to v2\\n&quot;;if (v3 == v4) std::cout &lt;&lt; &quot;v3 equal to v4\\n&quot;;else std::cout &lt;&lt; &quot;v3 not equal to v4\\n&quot;; 9.16 12345678910std::list&lt;int&gt; lst1{ 1, 2, 3, 4 };std::vector&lt;int&gt; v1{ 1, 2, 3, 4 };// error，相等运算符必须是同类型的容器// if (lst1 == v1)if (std::vector&lt;int&gt;(lst1.cbegin(), lst1.cend()) == v1) std::cout &lt;&lt; &quot;equal\\n&quot;;else std::cout &lt;&lt; &quot;not equal\\n&quot;; 9.17 1234answer:1. c1 以及 c2 的容器类型必须相同2. c1 以及 c2 不能是无序关联容器3. c1 以及 c2 中的元素必须支持 op &lt; 9.3.1 节练习 9.18 Write a program to read a sequence of strings from the standard input into a deque. Use iterators to write a loop to print the elements in the deque. 12345678std::deque&lt;std::string&gt; dq;for (std::string str; std::cin &gt;&gt; str; dq.push_back(str)) {};for (auto iter = dq.cbegin(); iter != dq.cend(); ++iter) { std::cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n'; 9.19 12Rewrite the program from the previous exercise to use a list.List the changes you needed to make. 123456789std::list&lt;std::string&gt; lst;for (std::string str; std::cin &gt;&gt; str;) { lst.push_back(str);}for (auto iter = lst.cbegin(); iter != lst.cend(); ++iter) { std::cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n'; 1answer: 只需要将容器类型换成 std::list 即可。 9.20 Write a program to copy elements from a list into two deques. The even-valued elements should go into one deque and the odd ones into the other. 1234567891011std::list&lt;int&gt; lst{ 1, 2, 3, 4, 5, 6, 7 };std::deque&lt;int&gt; dq1, dq2;for (auto n : lst) { // even-valued elements to dq1 if ((n &amp; 1) == 0) { dq1.push_back(n); } else { dq2.push_back(n); }} 9.21 Explain how the loop from page 345 that used the return from insert to addelements to a list would work if we inserted into a vector instead. 1answer: 使用 vector 与 list 的效果一样 12345std::vector&lt;std::string&gt; vec;auto iter = vec.begin();while (std::cin &gt;&gt; word) { iter = vec.insert(iter, word);} 9.22 Assuming iv is a vector of ints, what is wrong with the following program? How might you correct the problem(s)? 1234std::vector&lt;int&gt;::iterator iter = iv.begin(), mid = iv.begin() + iv.size() / 2;while (iter != mid) if (*iter == someVal) iv.insert(iter, someVal * 2); 12answer: 1. 循环不会终止, 因为 iter 没有递增 2. insert 之后, vector 的迭代器会失效, 需要重新赋值 123456789101112// 修改void InsertDoubleVal(std::vector&lt;int&gt; &amp;iv, int target) { auto cursor = iv.size() / 2; for (auto iter = iv.cbegin(), mid = iv.cbegin() + cursor; iter != mid; ++iter, mid = iv.begin() + cursor) { if (*iter == target) { iter = iv.insert(iter, target * 2); ++iter; ++cursor; } }} 9.3.2 节练习 9.23 ln the first program in this section on page 346, what would the values of val, val2, val3, and val4 be if c.size() is 1? 123456if (!c.empty()) { auto val = *c.begin(), val2 = c.front(); auto last = c.end(); auto val3 = *(--last); auto val4 = c.back();} 1answer: val, val2. val3, val4 的值相等 9.24 Write a program that fetches the first element in a vector using at, the subscript operator, front, and begin. Test your program on an empty vector. 12345678910111213141516// result cppstd::vector&lt;int&gt; iv{ 1, 2, 3 };if (!iv.empty()) { std::cout &lt;&lt; &quot;at(0) : &quot; &lt;&lt; iv.at(0) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;[0] : &quot; &lt;&lt; iv[0] &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;front() : &quot; &lt;&lt; iv.front() &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;*begin(): &quot; &lt;&lt; *iv.begin() &lt;&lt; '\\n';}std::vector&lt;int&gt; iv2;// terminating with uncaught exception of type std::out_of_rangestd::cout &lt;&lt; &quot;at(0) : &quot; &lt;&lt; iv2.at(0) &lt;&lt; '\\n'; // segmentation faultstd::cout &lt;&lt; &quot;[0] : &quot; &lt;&lt; iv2[0] &lt;&lt; '\\n';std::cout &lt;&lt; &quot;front() : &quot; &lt;&lt; iv2.front() &lt;&lt; '\\n';std::cout &lt;&lt; &quot;*begin(): &quot; &lt;&lt; *iv2.begin() &lt;&lt; '\\n'; 9.3.3 节练习 9.25 In the program on page 349 that erased a range of elements, what happens ifelem1 and elem2 are equal? What if elem2 or both elem1 and elem2 are theoff-the-end iterator? 1elem1 = slist.erase(elem1, elem2); 123answer: 1. elem1 等于 elem2，什么都没做 2. elem2 等于尾后迭代器，删除 elem1 及其之后的所有元素。 3. elem1 以及 elem2 都等于尾后迭代器, 什么都没做。 9.26 1234567891011121314// result cppfor (auto iter = iv.cbegin(); iter != iv.cend();) { if ((*iter &amp; 0x1) == 0) iter = iv.erase(iter); else ++iter;}for (auto iter = ilst.cbegin(); iter != ilst.cend();) { if ((*iter &amp; 0x1) == 1) iter = ilst.erase(iter); else ++iter;} 9.27 Write a program to find and remove the odd-valued elements in a forward_list. 12345678910std::forward_list&lt;int&gt; flst{ 1, 2, 3, 4, 5, 6, 7, 8 };for (auto prev = flst.cbefore_begin(), curr = flst.cbegin(); curr != flst.cend();) { if ((*curr &amp; 0x1) == 1) { curr = flst.erase_after(prev); } else { prev = curr; ++curr; }} 9.28 Write a function that takes a forward_list and two additional string arguments.The function should find the first string and insert the second immediately following the first. lf the first string is not found, then insert the second string atthe end of the list. 1234567891011void InsertString(std::forward_list&lt;std::string&gt; &amp;flst, std::string const &amp;str1, std::string const &amp;str2) { auto prev = flst.cbefore_begin(); for (auto curr = flst.cbegin(); curr != flst.cend(); ++prev, ++curr) { if ((*curr) == str1) { flst.insert_after(curr, str2); return; } } flst.insert_after(prev, str2);}","link":"/2021/04/12/Cpp5thExercise9/"}],"tags":[{"name":"-C++ -习题","slug":"C-习题","link":"/tags/C-%E4%B9%A0%E9%A2%98/"},{"name":"-C++ -笔记","slug":"C-笔记","link":"/tags/C-%E7%AC%94%E8%AE%B0/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Gitee","slug":"Gitee","link":"/tags/Gitee/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"-Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"C++ Primer 5th","slug":"C-Primer-5th","link":"/categories/C-Primer-5th/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"C++那些事","slug":"C-那些事","link":"/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]}