{"pages":[],"posts":[{"title":"博客搭建指南","text":"平台本博客网站的平台如下。 Hexo Icarus Gitee 搭建 HexoHexo 官网为了搭建 Hexo 环境, 用户需要先配置好 Node.js 以及 Git 环境。 新建一个文件夹，用来存放项目文件 进入该文件夹, 打开 Git Bash hexo init npm install npm install hexo-deployer-git --save hexo g hexo s 1npm install 可能针对某个特定的包报错, 可以先安装报错的包[npm install xxx --ignore-scripts] 切换 Icarus 主题Icarus 官方文档 Gitte Page 完成同步 创建 gitte 账户, 并添加本地主机的 ssh 公钥1234// Gittessh -T git@gitte.com// Githubssh -T git@github.com 修改_config.yml配置文件12345deploy: type: git # 可以指定多个 repo repo: git@gitee.com:chengming0313/chengming0313.git branch: master hexo d上传静态文件(.deploy_git) Gitte 新建分支 hexo hexo 设为默认分支 git clone xxx只保留.git文件夹, 删除其它所有文件夹 将博客的源文件复制过来(除了 .deploy_git)记得删除 themes 下主题里的 .git文件夹 上传源文件到 hexo 分支123git add .git commit -m &quot;init&quot;git push 更换本地主机 git clone xxx npm install npm install hexo-deployer-git --save hexo g hexo s hexo d","link":"/2021/04/06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"},{"title":"C++ Primer 5th 第一章课后习题","text":"环境 Windows12gcc --version : gcc.exe (tdm64-1) 9.2.0g++ xxx -o xxx.exe -g -Wall -fexec-charset=GBK -std=c++11 Linux1gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44) 1.1 节练习EX1.1 查阅你使用的编译器的文档, 确定它所使用的文件命名约定, 编译并运行第 2 页的 main 程序. Windows直接使用 g++ ex1_1.cpp 默认生成 a.exe可执行文件通过 -o 指定输出文件名, g++ ex1_1.cpp -o ex1_1.exe Linux直接使用 g++ ex1_1.cpp 默认生成 a.out可执行文件通过 -o 指定输出文件名, g++ ex1_1.cpp -o ex1_1Linux 可执行文件没有后缀名要求EX1.2 改写程序, 让它返回 -1 。返回值 -1 通常被当作程序错误的标识。重新编译并运行你的程序, 观察你的系统如何处理 main 返回的错误标识. Windows123failed to launch (exit code: 1)PS F:\\Project\\CodeProject\\CODE_CPP\\CPP_Primer\\ch01&gt; echo $?False Linux12[cheng@VM-4-15-centos ch01]$ echo $?255 1.2 节练习EX1.3 编写程序, 在标准输出上打印Hello, World.12345#include &lt;iostream&gt;int main() { std::cout &lt;&lt; &quot;Hello, World&quot; &lt;&lt; std::endl; return 0;}","link":"/2021/04/06/C-Primer-5th-%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"},{"title":"C++ Primer 5th 第七章课后习题","text":"环境提供的所有代码，如未说明, 则指的是 Windows Windows12gcc --version : gcc.exe (tdm64-1) 9.2.0g++ xxx -o xxx.exe -g -Wall -fexec-charset=GBK -std=c++11 Linux1gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44) 7.1.1 节练习EX7.1123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;struct Sales_data { std::string bookNo; std::string bookName; unsigned units_sold; double revenue;};int main() { Sales_data total; if (std::cin &gt;&gt; total.bookNo &gt;&gt; total.units_sold &gt;&gt; total.revenue) { Sales_data trans; while (std::cin &gt;&gt; trans.bookNo &gt;&gt; trans.units_sold &gt;&gt; trans.revenue) { if (total.bookNo == trans.bookNo) { total.units_sold += trans.units_sold; total.revenue += trans.revenue; } else { std::cout &lt;&lt; total.bookNo &lt;&lt; &quot; &quot; &lt;&lt; total.units_sold &lt;&lt; &quot; &quot; &lt;&lt; total.revenue / total.units_sold &lt;&lt; '\\n'; total = trans; } } std::cout &lt;&lt; total.bookNo &lt;&lt; &quot; &quot; &lt;&lt; total.units_sold &lt;&lt; &quot; &quot; &lt;&lt; total.revenue / total.units_sold &lt;&lt; '\\n'; } else { std::cerr &lt;&lt; &quot;No data!\\n&quot;; } return 0;} 7.1.2 节练习EX7.21","link":"/2021/04/06/C-Primer-5th-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"},{"title":"C++ Primer 5th 第七章笔记","text":"类 抽象数据类型 class + struct 访问控制 public private protected 类的其它特性 类的作用域 构造函数 类的静态成员 抽象数据类型定义抽象数据类型 使用 struct 或者 class 来定义一个类(抽象数据类型)C++中, 抽象数据类型 和 类 含义相同吗?struct 与 class 的区别在于成员的默认访问权限以及继承类型123456789struct A { int _data; void print() { std::cout &lt;&lt; &quot;hello\\n&quot;; }};class B { int _data; void print() { std::cout &lt;&lt; &quot;hello\\n&quot;; }}; 123456A a;B b;std::cout &lt;&lt; a._data &lt;&lt; '\\n';a.print();std::cout &lt;&lt; b._data &lt;&lt; '\\n'; // errorb.print(); // error 头文件的组织结构一般来说, 类的声明和实现分开, 分为头文件以及源文件.123456789101112131415161718// 1. 防卫式声明#ifndef XXX_H#define XXX_H// 2. 前置声明#include &lt;string&gt;class A;void fun1();// 3. 类的声明class A {};// 4. 部分函数的实现(`内联函数`、`模板函数`) + 非成员函数的声明// 有些函数的定义需要放在头文件中#endif member function member function 的声明必须在类的内部, 而它的定义可以在类的内部也可以在类的外部.定义在类内部的 member function 隐式 inline(可以显式使用 inline 修饰) 外部定义成员变量以及函数时, 需要使用 ClassName:: 修饰变量或者函数名 this pointer member function 通过 this pointer 来隐式地访问调用它的 object return bookNo; = return this-&gt;bookNo; 当出现重名时, 可以使用 this 显式访问 data member 以及 member function 需要返回对象的引用时, 使用 return *this this pointer 的类型为 T * const const member function 与 this pointer1std::string isbn() const {return bookNo;} const member funciton 中的 this pointer 类型为 T const * const因此普通对象不能调用 const member function, 而 const 对象 可以调用所有成员函数 const member funtion 与 non-const member function 可以重载 构造函数 无论何时, 只要类的对象被创建, 就会执行构造函数 构造函数形式: 无返回类型 函数名和类名相同 只有构造函数执行完成, const 对象 才真正具有了 const 属性, 因此构造函数可以对 const 对象 写值 默认构造函数 以及 合成默认构造函数没有任何参数的构造函数叫做 默认构造函数用户没有 自定义构造函数 时, 编译器会自动生成一个 合成的默认构造函数 .使用 = default 要求编译器生成默认的构造函数 合成默认构造函数的缺点 定义在块中的内置类型或者复合类型默认初始化时, 值未定义 成员变量没有默认构造函数时, 无法默认初始化 初始值列表12345678910// 初始值列表A(int data1, int data2) : _data1(), _data2(data2) {}// 赋值A(int data1, int data2) { _data1 = data1; _data2 = data2;}// 类内初始值int _data1 = 0;int _data2 = 0; 最好使用初始值列表, 而不是 类内初始值 以及 函数体内赋值. 初始值列表 会覆盖 类内初始值. 函数体内赋值 会先初始化成员变量, 再赋值. 没有出现初始值列表的成员变量, 将通过 类内初始值 或者执行 默认初始化 . Big Three(拷贝构造 拷贝赋值 析构) 用户没有定义时, 编译器会自动合成 管理动态内存的类通常不能依赖于编译器自动合成的函数 (浅拷贝)","link":"/2021/04/06/C-Primer-5th-%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%AC%94%E8%AE%B0/"},{"title":"C++ const","text":"const const 含义 定义一个 const 变量 const 的一些特性 指针与 const 函数与 const 类与 const 1. const 含义 const 用来修饰变量，表示变量的值不可改变(赋值), 是一个 只读变量 。 const 修饰的变量不一定是一个 常量表达式 , 常量表达式除了要求值不可更改之外, 还要求在编译过程中就能得到计算结果。 一般使用 constexpr 来修饰一个常量表达式, 编译器会对变量进行验证。不符合要求会报错。 声明 constexpr 的类型有所限制, 必须属于 字面值类型 。 2. 定义一个 const 变量 const 变量必须初始化 const 变量不能赋值 const 修饰的 类变量 , 只有在 构造函数 完成后才算真正具有 const 属性。 123const int i1; // error: uninitialized const 'i1'const int i = 0;i = 1; // error: assignment of read-only variable 'i' 3. const 的一些特性 用 const 代替 #define如下, #define 定义的 SIZE_NUM, 在 预处理过程 就已经被 10 替换, 不会进入 符号表。程序出现问题时不好定位。 12#define SIZE_NUM = 10const int SIZE_NUM = 10; const 变量默认为文件局部变量 非 const 变量不同文件访问 123456789101112131415// g++ -o main main.cpp other.cpp// other.cppint i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;extern int i;int main() { std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} const 变量不同文件访问 const 变量需要显式使用 extern 定义, 才能跨文件访问 1234567891011121314151617// other.cppextern const int i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;// 这里不用 const 声明也能够通过, i = 200 不会报错, 但是// 程序运行时会出错extern const int i;int main() { // i = 200; std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} 4. 指针与 const const 总是优先与它左侧的符号配对 12345const char * a; // pointer to const charchar const char * a; // 同上char *const a; // const pointer to charchar const *const a; // const pointer to const charconst char *const a; // 同上 指向常量的指针（底层 const） 可以不用初始化, 不能通过指针解引用去修改它的值 12345char const * a; // 底层 const 可以不用初始化char ch = 'a';a = &amp;ch;*a = 'x'; // error, 不能通过指针修改它的值 可以指向非 const 的变量 12345int i = 10;int const *pi = &amp;i;std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n';std::cout &lt;&lt; ++i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n'; 1210 1011 11 不能用 void * 指向 const 变量, 必须使用 const void * 123const int a = 10;void const *ptr1 = &amp;a;void * ptr2 = &amp;a; // error 常量指针（顶层 const） 必须初始化, 指针不能修改 1234int a = 10;int *const ptr = &amp;a;int *const ptr2; // error: uninitialized const 'ptr2'ptr = nullptr; // error: assignment of read-only variable 'ptr' error: const T * —-&gt; T * const 12int const a = 10;int *const ptr = &amp;a; // error: invalid conversion from 'const int*' to 'int*' 5. const 变量的拷贝操作 顶层 const 对象可以拷贝给非顶层 const 对象 1234const int ci = 100;int i = ci; // i: 100int *const p1 = &amp;i;int * p2 = p1; 非顶层 const 对象也可以拷给顶层 const 对象 12345// -&gt; 顶层 constint j = 200;const int cj = j;int * ptr1 = &amp;j;int *const ptr2 = ptr1; 底层 const 对象不能拷给非底层 const 对象 1234567891011int const &amp;cr1 = 100;int &amp;r1 = cr1; // error: binding reference of type 'int&amp;' to 'const int' discards qualifiersint const *p3 = &amp;ci;int * p4 = p3; // error: invalid conversion from 'const int*' to 'int*'// T const * const -&gt;int const *const p5 = &amp;ci;int * p6 = p5; // error: invalid conversion from 'const int*' to 'int*'int const * p7 = p5;int *const p8 = p5; // error: invalid conversion from 'const int*' to 'int*' 非底层 const 对象可以拷给底层 const 对象 1234567int &amp; r2 = j;int const &amp;cr2 = r2;int * ptr3 = &amp;j;int const *ptr4 = ptr3;int const *const ptr5 = ptr3; 6. 函数与 const6.1 修饰返回值 return by const value , 没有意义。 1const int get() {return 1;} return by const reference 返回普通引用, 可以修改返回值, 可以作为左值使用 1234567891011121314std::string &amp;Get(std::string &amp;a) { return a;}int main() { std::string str = &quot;123456&quot;; // 这里要用 &amp;, 不然不是引用 std::string &amp;str2 = Get(str); str2 = &quot;xxxxxx&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; Get(str) = &quot;hello world&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; return 0;} 12xxxxxx xxxxxxhello world hello world 返回常量引用，不能修改 12345678int main() { std::string str = &quot;123456&quot;; // 这里要用 const &amp; std::string const &amp;str2 = GetConst(str); std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; std::cout &lt;&lt; GetConst(str).length() &lt;&lt; std::endl; return 0;} return by T const * 1234567int const *Get(int *p) { return p;}int a = 10;int const *p1 = Get(&amp;a);int * p2 = Get(&amp;a); // error return by T * const1234567int *const Get2(int *p) { return p;}int a = 10;int *const p3 = Get2(&amp;a);int * p4 = Get2(&amp;a); 6.2 修饰参数 普通的 顶层 const (不是 T const &amp;)使用普通的 顶层 const 作为函数参数，没有意义, 函数收到的是一个副本。 12void fun1(int const val);void fun2(int *const ptr); 底层 const通过传入 T const * 的方式, 使得函数能够通过指针访问函数体外的对象, 又保证了数据的不可修改。 1void fun1(int const *p); T const &amp;pass by const reference 能让函数直接通过变量名访问作用域外的对象, 还能保证数据的 read only 1void fun1(std::string const &amp;str); 对于类类型的变量来说, 使用pass by value 的方式传值, 在拷贝过程中对象的拷贝构造以及析构都会消耗时间, 效率较低。我们可以使用 pass by pointer to const 以及 pass by const reference 来提高效率, 同时保证数据的安全性。 7. 类与 const const member function 普通的member function 中的 this pointer 类型为 T *, 而 const member function 中的 this pointer 类型为 T const *。 对于 const object来说, 它不能用来给普通的this pointer初始化, 它只能给const member function中T const *类型的this pointer初始化。 对于普通的 object, 它即可以使用const member function, 又可以使用普通的 member function。因为T * 既可以给 T * 初始化, 又可以给 T const * 初始化。 除了函数参数列表, 是否是 const member function, 也可以进行重载. 普通的 object 默认调用 非 const member function. 12345678910111213class A {public: void print() const { std::cout &lt;&lt; &quot;const print()\\n&quot;; } void print() { std::cout &lt;&lt; &quot;print()\\n&quot;; }};int main() { A a; A const ca; a.print(); ca.print(); return 0;} 123// 结果print()const print() const 成员 这里讨论一下类内初始值与初始值列表的优先级。初始值列表的优先级比类内初始值要高。只有没有为该成员设定初始值列表时, 它才会使用类内初始值进行初始化。 1234567891011121314class A {public: A() : _a(1) {} void Print() { std::cout &lt;&lt; _a &lt;&lt; &quot;\\n&quot;; }private: int _a = 0;};int main() { A a; a.Print(); return 0;} 12// 结果1 类中的 const 成员可以使用类内初始值的方式初始化 1const int _a = 999; 类中的 const 成员可以使用初始值列表的方式初始化 12const int _a;A() : _a(999) {} 不能在构造函数中用赋值表达式初始化 const 成员, 在进入构造函数体之前, 成员的初始化过程已经结束。 12const int _a;A() { _a = 999; } // error 当要表示类中共享的常量时, 通常使用 static const 修饰 使用类内初始值的方式定义 static const 1static const int _a = 999; // 类内初始值的方式初始化 static const 变量 采用与一般 static 变量一样的方法, 类内声明, 类外定义 1234// in classstatic const int _a;// 类的实现文件const int A::_a = 999; // 需要去除 static 符号","link":"/2021/04/11/C-const/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Gitee","slug":"Gitee","link":"/tags/Gitee/"},{"name":"-C++ -习题","slug":"C-习题","link":"/tags/C-%E4%B9%A0%E9%A2%98/"},{"name":"-C++ -笔记","slug":"C-笔记","link":"/tags/C-%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"C++ Primer 5th","slug":"C-Primer-5th","link":"/categories/C-Primer-5th/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"C++那些事","slug":"C-那些事","link":"/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]}