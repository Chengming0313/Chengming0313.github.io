{"pages":[],"posts":[{"title":"博客搭建指南","text":"平台本博客网站的平台如下。 Hexo Icarus Gitee 搭建 HexoHexo 官网为了搭建 Hexo 环境, 用户需要先配置好 Node.js 以及 Git 环境。 新建一个文件夹，用来存放项目文件 进入该文件夹, 打开 Git Bash hexo init npm install npm install hexo-deployer-git --save hexo g hexo s 1npm install 可能针对某个特定的包报错, 可以先安装报错的包[npm install xxx --ignore-scripts] 切换 Icarus 主题Icarus 官方文档 Gitte Page 完成同步 创建 gitte 账户, 并添加本地主机的 ssh 公钥1234// Gittessh -T git@gitte.com// Githubssh -T git@github.com 修改_config.yml配置文件12345deploy: type: git # 可以指定多个 repo repo: git@gitee.com:chengming0313/chengming0313.git branch: master hexo d上传静态文件(.deploy_git) Gitte 新建分支 hexo hexo 设为默认分支 git clone xxx只保留.git文件夹, 删除其它所有文件夹 将博客的源文件复制过来(除了 .deploy_git)记得删除 themes 下主题里的 .git文件夹 上传源文件到 hexo 分支123git add .git commit -m &quot;init&quot;git push 更换本地主机 git clone xxx npm install npm install hexo-deployer-git --save hexo g hexo s hexo d","link":"/2021/04/06/Blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"},{"title":"引用本地图片","text":"在hexo博客中引用本地图片 npm hexo-asset-image --save 替换/node_modules/hexo-asset-image/index.js内容 修改_config.xml 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg 1. npm hexo-asset-image --save2. 替换/node_modules/hexo-asset-image/index.js内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) { return str.split(m, i).join(m).length;}var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function (data) { var config = hexo.config; if (config.post_asset_folder) { var link = data.permalink; if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for (var i = 0; i &lt; toprocess.length; i++) { var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function () { if ($(this).attr('src')) { // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if (!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) { // For &quot;about&quot; page, the first part of &quot;src&quot; can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function (elem) { return elem != ''; }); var srcArray = src.split('/').filter(function (elem) { return elem != '' &amp;&amp; elem != '.'; }); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + config.root + link + src); } } else { console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); } }); data[key] = $.html(); } }}); 3. 修改_config.xml4. 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg","link":"/2021/04/12/Blog/%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"},{"title":"C++ const","text":"本系列参考第三方文档 C++那些事 const const 含义 定义一个 const 变量 const 的一些特性 指针与 const 函数与 const 类与 const 1. const 含义 const 用来修饰变量，表示变量的值不可改变(赋值), 是一个 只读变量 。 const 修饰的变量不一定是一个 常量表达式 , 常量表达式除了要求值不可更改之外, 还要求在编译过程中就能得到计算结果。 一般使用 constexpr 来修饰一个常量表达式, 编译器会对变量进行验证。不符合要求会报错。 声明 constexpr 的类型有所限制, 必须属于 字面值类型 。 2. 定义一个 const 变量 const 变量必须初始化 const 变量不能赋值 const 修饰的 类变量 , 只有在 构造函数 完成后才算真正具有 const 属性。 123const int i1; // error: uninitialized const 'i1'const int i = 0;i = 1; // error: assignment of read-only variable 'i' 3. const 的一些特性 用 const 代替 #define如下, #define 定义的 SIZE_NUM, 在 预处理过程 就已经被 10 替换, 不会进入 符号表。程序出现问题时不好定位。 12#define SIZE_NUM = 10const int SIZE_NUM = 10; const 变量默认为文件局部变量 非 const 变量不同文件访问 123456789101112131415// g++ -o main main.cpp other.cpp// other.cppint i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;extern int i;int main() { std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} const 变量不同文件访问 const 变量需要显式使用 extern 定义, 才能跨文件访问 1234567891011121314151617// other.cppextern const int i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;// 这里不用 const 声明也能够通过, i = 200 不会报错, 但是// 程序运行时会出错extern const int i;int main() { // i = 200; std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} 4. 指针与 const const 总是优先与它左侧的符号配对 12345const char * a; // pointer to const charchar const char * a; // 同上char *const a; // const pointer to charchar const *const a; // const pointer to const charconst char *const a; // 同上 指向常量的指针（底层 const） 可以不用初始化, 不能通过指针解引用去修改它的值 12345char const * a; // 底层 const 可以不用初始化char ch = 'a';a = &amp;ch;*a = 'x'; // error, 不能通过指针修改它的值 可以指向非 const 的变量 12345int i = 10;int const *pi = &amp;i;std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n';std::cout &lt;&lt; ++i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n'; 1210 1011 11 不能用 void * 指向 const 变量, 必须使用 const void * 123const int a = 10;void const *ptr1 = &amp;a;void * ptr2 = &amp;a; // error 常量指针（顶层 const） 必须初始化, 指针不能修改 1234int a = 10;int *const ptr = &amp;a;int *const ptr2; // error: uninitialized const 'ptr2'ptr = nullptr; // error: assignment of read-only variable 'ptr' error: const T * —-&gt; T * const 12int const a = 10;int *const ptr = &amp;a; // error: invalid conversion from 'const int*' to 'int*' 5. const 变量的拷贝操作 顶层 const 对象可以拷贝给非顶层 const 对象 1234const int ci = 100;int i = ci; // i: 100int *const p1 = &amp;i;int * p2 = p1; 非顶层 const 对象也可以拷给顶层 const 对象 12345// -&gt; 顶层 constint j = 200;const int cj = j;int * ptr1 = &amp;j;int *const ptr2 = ptr1; 底层 const 对象不能拷给非底层 const 对象 1234567891011int const &amp;cr1 = 100;int &amp;r1 = cr1; // error: binding reference of type 'int&amp;' to 'const int' discards qualifiersint const *p3 = &amp;ci;int * p4 = p3; // error: invalid conversion from 'const int*' to 'int*'// T const * const -&gt;int const *const p5 = &amp;ci;int * p6 = p5; // error: invalid conversion from 'const int*' to 'int*'int const * p7 = p5;int *const p8 = p5; // error: invalid conversion from 'const int*' to 'int*' 非底层 const 对象可以拷给底层 const 对象 1234567int &amp; r2 = j;int const &amp;cr2 = r2;int * ptr3 = &amp;j;int const *ptr4 = ptr3;int const *const ptr5 = ptr3; 6. 函数与 const6.1 修饰返回值 return by const value，一般情况下,，没有意义。一些特殊情况下是有意义的, 详见Effective C++ 条款21。 123const int get() {return 1;} // 无意义// 这是有意义的, 防止出现 (a * b) = c;const Rational operator*(Rational const &amp;lhs, Rational const &amp;rhs); return by const reference 返回普通引用, 可以修改返回值, 可以作为左值使用 1234567891011121314std::string &amp;Get(std::string &amp;a) { return a;}int main() { std::string str = &quot;123456&quot;; // 这里要用 &amp;, 不然不是引用 std::string &amp;str2 = Get(str); str2 = &quot;xxxxxx&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; Get(str) = &quot;hello world&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; return 0;} 12xxxxxx xxxxxxhello world hello world 返回常量引用，不能修改 12345678int main() { std::string str = &quot;123456&quot;; // 这里要用 const &amp; std::string const &amp;str2 = GetConst(str); std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; std::cout &lt;&lt; GetConst(str).length() &lt;&lt; std::endl; return 0;} return by T const * 1234567int const *Get(int *p) { return p;}int a = 10;int const *p1 = Get(&amp;a);int * p2 = Get(&amp;a); // error return by T * const1234567int *const Get2(int *p) { return p;}int a = 10;int *const p3 = Get2(&amp;a);int * p4 = Get2(&amp;a); 6.2 修饰参数 普通的 顶层 const (不是 T const &amp;)使用普通的 顶层 const 作为函数参数，没有意义, 函数收到的是一个副本。 12void fun1(int const val);void fun2(int *const ptr); 底层 const通过传入 T const * 的方式, 使得函数能够通过指针访问函数体外的对象, 又保证了数据的不可修改。 1void fun1(int const *p); T const &amp;pass by const reference 能让函数直接通过变量名访问作用域外的对象, 还能保证数据的 read only 1void fun1(std::string const &amp;str); 对于类类型的变量来说, 使用pass by value 的方式传值, 在拷贝过程中对象的拷贝构造以及析构都会消耗时间, 效率较低。我们可以使用 pass by pointer to const 以及 pass by const reference 来提高效率, 同时保证数据的安全性。 7. 类与 const const member function 普通的member function 中的 this pointer 类型为 T *, 而 const member function 中的 this pointer 类型为 T const *。 对于 const object来说, 它不能用来给普通的this pointer初始化, 它只能给const member function中T const *类型的this pointer初始化。 对于普通的 object, 它即可以使用const member function, 又可以使用普通的 member function。因为T * 既可以给 T * 初始化, 又可以给 T const * 初始化。 除了函数参数列表, 是否是 const member function, 也可以进行重载. 普通的 object 默认调用 非 const member function. 12345678910111213class A {public: void print() const { std::cout &lt;&lt; &quot;const print()\\n&quot;; } void print() { std::cout &lt;&lt; &quot;print()\\n&quot;; }};int main() { A a; A const ca; a.print(); ca.print(); return 0;} 123// 结果print()const print() const 成员 这里讨论一下类内初始值与初始值列表的优先级。初始值列表的优先级比类内初始值要高。只有没有为该成员设定初始值列表时, 它才会使用类内初始值进行初始化。 1234567891011121314class A {public: A() : _a(1) {} void Print() { std::cout &lt;&lt; _a &lt;&lt; &quot;\\n&quot;; }private: int _a = 0;};int main() { A a; a.Print(); return 0;} 12// 结果1 类中的 const 成员可以使用类内初始值的方式初始化 1const int _a = 999; 类中的 const 成员可以使用初始值列表的方式初始化 12const int _a;A() : _a(999) {} 不能在构造函数中用赋值表达式初始化 const 成员, 在进入构造函数体之前, 成员的初始化过程已经结束。 12const int _a;A() { _a = 999; } // error 当要表示类中共享的常量时, 通常使用 static const 修饰 使用类内初始值的方式定义 static const 1static const int _a = 999; // 类内初始值的方式初始化 static const 变量 采用与一般 static 变量一样的方法, 类内声明, 类外定义 1234// in classstatic const int _a;// 类的实现文件const int A::_a = 999; // 需要去除 static 符号","link":"/2021/04/11/Cpp/C-const/"},{"title":"Linux C 系统开发 I&#x2F;O 篇","text":"I/O (input &amp; output)I/O 是一切实现的基础。它分为 stdio (标准IO) 和 sysio (文件IO、系统调用IO)。优先使用 stdio。sysio 取决于操作系统内核，windows 和 linux 提供的文件 io 是不一致的。而 stdio 是 c 中提供的，stdio 依赖于底层的 sysio。windosw 和 linux 是兼容的，例如 fopen linux 环境中依赖于 open，windows 环境下依赖于 openfile。 stdioman 手册第三章 类型FILE 函数stream open &amp; close functions12345678910111213#include &lt;stdio.h&gt;FILE *fopen(const char *pathname, const char *mode);FILE *fdopen(int fd, const char *mode);FILE *freopen(const char *pathname, const char *mode, FILE *stream);Feature Test Macro Requirements for glibc (see feature_test_macros(7)):fdopen(): _POSIX_C_SOURCEint fclose(FILE *stream); fopen 中的 mode 如果使用 r、r+, 则指定的文件必须存在。同时 linux 没有二进制流和文本流的区别。 fopen 返回的 FILE 指针指向的内存在堆上，通过 fclose 释放堆空间。 1234567891011121314151617181920212223#include &lt;stdio.h&gt; // perror#include &lt;stdlib.h&gt;#include &lt;errno.h&gt; // errno#include &lt;string.h&gt; // strerrorint main() { FILE *fp; fp = fopen(&quot;tmp&quot;, &quot;r&quot;); if (fp == NULL) { // fprintf(stderr, &quot;fopen() failed! errno = %d\\n&quot;, errno); // perror(&quot;fopen()&quot;); fprintf(stderr, &quot;fopen(): %s\\n&quot;, strerror(errno)); exit(1); } puts(&quot;OK&quot;); fclose(fp); exit(0);} 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main() { FILE *fp = NULL; int count = 0; while (1) { fp = fopen(&quot;tmp&quot;, &quot;w&quot;); if (fp == NULL) { perror(&quot;fopen(): &quot;); break; } ++count; } fprintf(stdout, &quot;count = %d\\n&quot;, count); exit(0);} 每个进程默认最多能够打开 1024 个文件，默认已经打开了三个文件：stdin, stdout, stderr 12fopen(): : Too many open filescount = 1021 文件权限默认公式：0666 &amp; ~umask，umask 越大，生成的文件权限越小。 input of characters and strings123456789101112#include &lt;stdio.h&gt;int fgetc(FILE *stream);int getc(FILE *stream);int getchar(void);int ungetc(int c, FILE *stream);// 缺点：只能读取指定大小的内容。char *fgets(char *s, int size, FILE *stream); fgetc 读取失败返回 EOF，fgets 读取失败返回 NULL。 fgets - 读取 `size - 1` 个字符，例如 `abcde`，size 为 5, s 为 `abcd\\0` - 读取到 `\\n`，例如 `abc`, size 为 5, s 为 `abc\\n\\0` output of characters and strings123456789int fputc(int c, FILE *stream);int putc(int c, FILE *stream);int putchar(int c);int fputs(const char *s, FILE *stream);int puts(const char *s); binary stream input/output12345#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 1234// afread(buffer, 1, 10, fp);// bfread(buffer, 10, 1, fp); fp 指向的数据量不小于10个字节 - a 返回 10， 读取到 10 个字节. - b 返回 1，读取到 10 个字节. fp 指向的数据量只有 10 个字节. - a: 返回 5, 读取到 5 个字节. - b：返回 0, 这时不知道自己读取了几个字节. 建议 fread 以及 fwrite 中的 size 设定为 1, 即块大小永远设定为 1. formatted output conversion123456789101112#include &lt;stdio.h&gt;// 标准输出int printf(const char *format, ...);// 文件输出int fprintf(FILE *stream, const char *format, ...);// 文件描述符int dprintf(int fd, const char *format, ...);// 字符串int sprintf(char *str, const char *format, ...);// 指定大小的字符串, 防止数组越界int snprintf(char *str, size_t size, const char *format, ...); formatted input conversion缺点：读取字符串时，不知道目标字符串的大小。 12345#include &lt;stdio.h&gt;int scanf(const char *format, ...);int fscanf(FILE *stream, const char *format, ...);int sscanf(const char *str, const char *format, ...); reposition a streamfseek 以及 ftell 缺点：参数类型以及返回类型为 long，32 位平台下，只能支持 2GB 左右大小的文件。 1234567#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence);long ftell(FILE *stream);void rewind(FILE *stream); fflush() 问题man fopen 显示 no manual entry123// 安装标准 c 的帮助文档sudo apt-get install libc-devsudo apt-get install glibc-doc 执行文件时，需要加 ./执行文件时不会在当前目录查找。","link":"/2021/05/28/LinuxC/linux-c-io/"},{"title":"具名条件：compare","text":"1. 前置知识1.1. 笛卡尔积$$A \\ast B = { (x, y) | x \\in A \\land y \\in B}$$ 1.2. 二元关系二元关系R实质上是有序对的集合. $从A到B的二元关系：R \\subseteq A \\ast B$ $A上的二元关系：R \\subseteq A \\ast A$ $x对y存在二元关系R的符号表示：$$xRy$, $&lt;x, y&gt; \\in R$ 1.3. 二元关系的表示: 列举、描述、关系矩阵、关系图1.4. 特殊的二元关系 $空关系：R = \\varnothing $ $恒等关系：I_A = {&lt;x, x&gt; | x \\in A }$ $全域关系：R = A \\ast B$ 1.5. A上的二元关系的性质 自反性: $\\forall x \\in A, &lt;x, x&gt; \\in A$ 反自反性: $\\forall x \\in A, &lt;x, x&gt; \\notin A$ 对称性: $\\forall x, y \\in A, 如果 &lt;x, y&gt; \\in R, 则 &lt;y, x&gt; \\in R$ 反对称性: $\\forall x, y \\in A, 如果 &lt;x, y&gt; \\in R, &lt;y, x&gt; \\in R, 则 x = y$ 传递性: $\\forall x, y, z \\in A, 如果 &lt;x, y&gt; \\in R, &lt;y, z&gt; \\in A, 则 &lt;x, z&gt; \\in R$ ！！！对称性和反对称性并不对立, 一个A上的二元关系可以既有对称性又有反对称性, 当然也可以都没有. 1.6. 等价关系如果R为A上的二元关系，如果R具备自反性、对称性以及传递性，则R为A上的等价关系（Equivalence Relation） 等价关系中集合元素的等价性 $如果R为等价关系$ $&lt;a, b&gt;\\in R，称a等价于b，记作a\\sim b$ $因为R是对称的，所以a\\sim b即b\\sim a$ 1.7. 偏序关系（Partial order）以及偏序集次序关系: 任务之间存在先后关系 如果R为A上的二元关系，如果R具备自反性、反对称性以及传递性，则R为A上的偏序关系，简称偏序，记作$\\preceq$ A以及A上的偏序关系$\\preceq$一起称作一个偏序集，记为$&lt;A, \\preceq&gt;$ 偏序集中的元素的性质 $&lt;A, \\preceq&gt;为偏序集，\\forall x, y\\in A$ $可比（comparable）：x \\in \\preceq \\lor y \\in \\preceq$ $x小于y：x\\in \\preceq \\land x \\ne y$，即偏序关系中x为第一分量，与为第二分量 $不可比（incomparable）：x \\notin \\preceq \\land y\\notin \\preceq$ 1.8. 全序关系$&lt;A, \\preceq&gt;$为偏序关系，如果$\\forall x, y\\in A$，都有$x\\preceq y或者y\\preceq x$（任意两个元素是可比的），则称$\\preceq 为全序关系$ 1.9 严格偏序关系与（非严格的）偏序关系相比，唯一的不同在于（非严格的）偏序关系满足自反性，而严格偏序关系要求反自反性。 偏序关系与严格偏序关系不是包含与被包含的关系 2. STL 具名要求：CompareCompare要求满足严格弱序关系 严格弱序关系（strict weak order）的定义如下： compare本身是一个严格偏序关系 不可比较的关系（!compare(a, b) &amp;&amp; !compare(b, a)）是一个等价关系 2.1 Compare 的功能 compare(a, b) == true表示 a 先于 b !compare(a, b) == true表示 b 先于 a !compare(a, b) &amp;&amp; !compare(b, a) == true表示a与b等价（相等） 2.2 一个合格的 Compare为了使得compare 能够很好地表达上述含义, 要求如下 2.2.1 compare本身是一个严格偏序关系 反自反性：compare(a, a) == false 反对称性：如果compare(a, b) == true，那么compare(b, a) == false 传递性：如果comapre(a, b) &amp;&amp; compare(b, c) == true，那么compare(a, c) == true 2.2.2 equiv是一个等价关系为了表示方便，使用equiv(a, b) 表示 !compare(a, b) &amp;&amp; !compare(b, a) 自反性：equiv(a, a) == true 对称性：如果equiv(a, b) == true，那么equiv(b, a) == true 传递性：如果equiv(a, b) &amp;&amp; equiv(b, c) == true，那么equiv(a, c) == true","link":"/2021/07/23/Cpp/namedRequirementCompare/"},{"title":"C++ 初始化类型","text":"参考资料CPP Reference知乎回答 初始化类型 list initialization aggregate initialization value initialization default initialization zero initialization direct initialization copy initialization 1. list initialization [new] T [objectName] {arg1, arg2, …} list initialization 分为两种, 一种是 aggregate type，它会利用 args 对其中的成员逐个初始化, args 不够会对剩余的成员进行 value initialization。另一种是 非 aggerate type，它会调用最匹配的构造函数。 123456789101112131415161718192021// 列表初始化// 非 aggregate 类型, 直接查找匹配的构造函数std::string str1{ &quot;123&quot; };std::string str2 = { &quot;456&quot; };std::string str3 = std::string{ &quot;789&quot; };std::string *str4 = new std::string{ &quot;xxx&quot; };std::cout &lt;&lt; str1 &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; &quot; &quot; &lt;&lt; str3 &lt;&lt; &quot; &quot; &lt;&lt; *str4 &lt;&lt; '\\n';// aggregate initialization, 使用{}中的参数逐个初始化, 不足的使用 value// initializationstd::vector&lt;int&gt; c1{ 1, 2, 3, 4 };std::array&lt;int, 8&gt; c2 = { 4, 5, 6, 7 };for (auto item : c1) { std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n';for (auto item : c2) { std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n'; 1234// 结果123 456 789 xxx1 2 3 44 5 6 7 0 0 0 0 2. value initialization 对于class 类型的变量, value initialization 会优先考虑用户自定义的默认构造函数, 否则先进行 value initialization，再调用合成的默认构造函数 对于非class类型的变量，直接进行 value initialization 123456789101112131415161718// class 类型变量，用户自定义默认构造函数class A {public: A() : _data(999) {} void Print() { std::cout &lt;&lt; _data &lt;&lt; '\\n'; }private: int _data;};A a1{};A a2 = {};A a3 = A{};A *a4 = new A{};a1.Print();a2.Print();a3.Print();a4-&gt;Print(); 12345// 结果999999999999 12345678910111213141516171819202122232425// class 类型变量，合成默认构造函数class A {public: A() = default; void Print() { std::cout &lt;&lt; _data &lt;&lt; '\\n'; }private: int _data;};// value initializationA a1{};A a2 = {};A a3 = A{};A *a4 = new A{};a1.Print();a2.Print();a3.Print();a4-&gt;Print();// default initializationA a5;A a6 = A();A *a7 = new A();a5.Print();a6.Print();a7-&gt;Print(); 1234567891011// 结果// value initialization0000// default initialization495097600 6. direct initialization7. copy initialization 注意有些时候编译器会对copy initializaiton进行优化。 例 1 12345678910111213141516// example 1class A {public: A(int data) : _data(data) { std::cout &lt;&lt; &quot;data constructor...\\n&quot;; } A(A const &amp;x) { this-&gt;_data = x._data; std::cout &lt;&lt; &quot;copy constructor...\\n&quot;; }private: int _data;};// main functionA a = 999; A a = A(999); 12345// result// 第一行 : 隐式转换 999 -&gt; A// 第二行 : 等价于 A a(999);data constructor...data constructor... 12345678// 取消 g++ 优化 : g++ -o test test.cpp -fno-elide-constructors// result// 第一行 : 先隐式转换执行 A(999)，然后调用 copy ctor// 第二行 ： 先调用 普通ctor，再调用 copy ctordata constructor...copy constructor...data constructor...copy constructor... 例 2 12345678// example 2// 返回值优化A get() { return A();}void usage03() { A a = get();} 1234567891011// usage03()// g++编译器会对函数返回值优化, 这里并不会创建临时变量来存放返回值0x79fdef constructor // a0x79fdef destructor // a 析构// -fno-elide-constructors, 取消 g++ 优化0x78fd8f constructor // get() 中的匿名对象0x78fddf copy constructor // 临时对象存储返回值0x78fd8f destructor // 匿名对象析构0x78fdde copy constructor // a0x78fddf destructor // 临时对象析构0x78fdde destructor // a 析构","link":"/2021/04/11/Cpp/CppInitializationType/"},{"title":"第一章、计算机系统漫游","text":"计算机系统由硬件和系统软件组成，它们共同工作来运行应用程序。 这一章通过研究hello.c来介绍计算机系统的主要概念和主题。 1 hello.c123456#include &lt;cstdio&gt;int main() { printf(&quot;hello, world\\n&quot;); return 0;} 2 计算机系统中信息的表示 计算机系统中的信息就是二进制位串+上下文（解读方式） 计算机系统中的所有信息都是以一串二进制位表示的，在不同的上下文中，同一个二进制位串会被解读成不同的信息。 例如11111111，如果计算机认为它是8位无符号数，则被解读为255，如果计算机认为它是8位带符号数，则被解读为-1。 3 hello.c的编译过程unix上通过编译器驱动程序完成源文件到二进制可执行目标文件的转换。 示例如下： 1gcc -o hello hello.c 编译过程的4个阶段 预处理阶段：进行一些预处理工作，修改hello.c得到另一个c源文件hello.i。 编译阶段：生成关于源文件汇编语言版本的文本文件hello.s。 汇编阶段：生成可重定位的二进制目标文件hello.o。 链接阶段：生成最终的二进制可执行目标文件hello。 4 系统的硬件组成 计算机系统的硬件组成包括：总线、中央处理器（CPU）、内存（主存）、I/O设备。 磁盘以及网络都可以看成一个I/O设备。 总线：负责在系统的各个部分之间传输定长的字节块（字）。 字是一个基本的系统参数，现在大多数系统的字长都是8个字节（64位）。 类别：I/O总线、系统总线、内存总线 中央处理器（CPU）：负责执行存储在内存中的指令，包括PC、ALU、寄存器文件。 程序计数器（PC）：大小为一个字的寄存器，保存着下一条将要执行的机器指令的地址。 算术/逻辑单元（ALU）：CPU的执行(算术运算、逻辑运算)单元。 寄存器文件：由若干个大小为一个字的寄存器组成，每个寄存器都有一个唯一的名字。 内存：一个临时存储设备，CPU执行程序时，负责存储程序以及程序产生的数据。 物理结构：由一组DRAM芯片组成 逻辑结构：线性字节数组，内存中的每个字节都与一个地址唯一对应。 I/O设备：输入/输出设备，常用来与外界交换信息（显示器、键盘、网络设备、磁盘）。 每个I/O设备都是通过适配器或者控制器和I/O总线交换信息。 CPU工作流程的简单理解从系统通电到断电，CPU一直在重复一个简单的流程。 从内存中取出PC指向的机器指令。 对该指令进行解释，执行该指令指示的简单操作. 更新PC，使其指向下一条要执行的命令。 运行hello的简单流程 键盘上输入./hello，shell将字符逐一读入寄存器，再把它们放入内存。 当读取到回车字符，命令的输入结束，shell程序通过一系列指令从磁盘将二进制的可执行目标文件hello复制到CPU。 一般情况，数据需要通过寄存器才能往内存写入数据，而计算机系统通过DMA技术可以直接将数据从磁盘写入到内存。 一旦hello被加载到内存，CPU就开始执行hello内的机器指令，通过寄存器向显示器写入”hello, world\\n”。 “hello world\\n”的转移路线：磁盘 -&gt; 内存 -&gt; 寄存器 -&gt; 显示器 5 计算机系统存储器的层次结构5.1 高速缓存的设计在计算机系统运行的过程中，需要将字节块通过总线在不同的地方之间来回搬运（寄存器、内存、CPU、I/O设备）。 而不同的存储器之间的访问速度差距很大，例如寄存器的访问速度远远高于内存，这就导致当CPU执行完一条指令，从内存读取下一条指令需要等待。这就导致CPU运行时的时间消耗了一大部分在读取指令上。 为了加快CPU从内存读取字节块的速度，在CPU与内存之间引入了L1, L2, L3高速缓存用来存放CPU近期最有可能用到的信息。 高速缓存不是一个特定的部件，它是一种设计思想，例如寄存器文件可以看作L1的高速缓存，L1又可以看作L2的高速缓存 5.2 层次结构特点越往上，存储器的访问速度越快，容量越小，每字节存储单位的造价越高。 上一层的存储器可以看作下一层的高速缓存。 6 操作系统（OS） 操作系统是在系统硬件和应用程序中间插入的软件层。 所有的应用程序都不会直接访问硬件，而是通过操作系统提供的服务来访问以及操作系统的硬件设备。 6.1 操作系统的功能操作系统通过对硬件设备进行抽象，来完成两个主要功能。 防止硬件被失控的应用程序滥用。 提供一种简单一致的机制来控制复杂庞大的低级硬件设置。 6.2 操作系统提供的抽象表示操作系统提供的抽象概念：进程、虚拟内存、文件。 6.3 进程 进程是操作系统对一个正在运行的程序的抽象，通俗说进程就是一个活着的程序。 因为进程是一个正在运行的程序，那么它就有自己的上下文（PC和寄存器文件的当前值、内存的当前值）。 为了使得多个进程能够同时运行，操作系统内核需要在不同的进程之间进行切换。 操作系统内核不是一个独立的进程，是系统管理全部进程的代码和数据结构的集合，它常驻内存。 进程切换会导致上下文切换：操作系统保存旧进程的上下文，操作系统恢复新进程的上下文。 上下文切换由操作系统负责，是内核代码的一部分，因此在进行上下文切换之前，旧进程需要将控制权交还给操作系统，切换完成之后，操作系统再把控制权移交给新进程。 shell程序执行hello会导致进程的切换，如图： 6.4 线程传统的进程调度模型中，进程扮演者两种角色： 调度、执行的基本单位 资源所有权拥有者 线程模型中，每个进程都有着若干个线程。 进程只是资源所有权的拥有者，资源由进程下的所有线程共享。 线程取代进程成为操作系统内核调度的基本单位。 两个优点： 线程的切换开销更小。 线程之间通信比进程之间通信效率更高。 6.4 虚拟内存 虚拟内存是对程序存储器的抽象。 虚拟内存提供一种假象：每个进程独占地使用系统内存。 6.5 文件 文件是对I/O设备的抽象。 文件本质就是字节序列，所有的I/O设备都可以看成文件，都可以使用操作系统提供的统一系统函数调用来读写字节块。 7 重要主题7.1 Amdahl定律当我们对系统的某个部分加速时，对系统整体性能的影响取决于该部分的重要性以及性能提升幅度。 假设 $T_{old}$为系统原始耗时，$T_{new}$为某个部分优化后的系统耗时, $\\alpha$为该部分耗时占系统耗时的比重，$k$为该部分性能提升比例。 易得该部分原始耗时为$\\alpha T_{old}$，优化后耗时为$\\frac {\\alpha T_{old}} {k}$ 因此 $$T_new = (1-\\alpha)T_{old} + \\frac {\\alpha T_{old}} {k}$$加速比$S=T_{old} / T_{new}$等于 $$S = \\frac 1 {(1-\\alpha) + \\frac \\alpha k}$$ $k$趋向$\\infty$时 $$S_{\\infty} = \\frac 1 {1 - \\alpha}$$ 7.2 并发与并行 并发：一个通用的概念，表示一个同时具有多个活动的系统。 并行：利用并发使系统运行得更快。 并发的层次 线程级并发 指令级并发 多核处理器 超线程 单指令、多数据并行 SIMD并行 7.3 指令架构集、虚拟机 指令集架构：提供了对CPU硬件的抽象，提供了一种假象：CPU一次只会执行一条指令。 不同的硬件实现同一个指令架构集，只是开销和性能不同，但是结果一样。 虚拟机：对整个计算机系统的抽象，包括操作系统、CPU、内存、I/O设备。","link":"/2021/08/04/CSAPP/1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"title":"使用allocator将内存分配和对象的构造分开","text":"当我们需要按需构造对象时，new []会有性能上的损耗，它会初始化所有的内存。这时候我们可以通过allocator将内存分配和对象构造分开。 1 allocator&lt;T&gt; 头文件：&lt;memory&gt; 构造allocator对象 1std::allocator&lt;std::string&gt; alloc; alloc分配内存 1auto const p = alloc.allocate(n); construct构造对象 123auto q = p;alloc.construct(q++, &quot;hello&quot;);alloc.construct(q++, 5, 'a'); destroy销毁对象 1alloc.destroy(q--); deallocate回收内存 1alloc.deallocate(p, n); 2 注意点 allocate(n)与new [n]的结果类型一致，都是T *。 allocate的结果最好用const修饰防止被修改，因为deallocate需要指定动态内存首元素位置。 没有construct的内存，不要使用，与内置变量的默认初始化一样，其结果是未定义的。 3 实例12345678910111213141516171819202122// allocatorDemo.cpp// Output: 0 1 2 3 4 5 6 7 8 9 int main() { std::allocator&lt;std::string&gt; strAlloc; auto const p = strAlloc.allocate(10); auto q = p; for(int i = 0; i &lt; 10; ++i) { strAlloc.construct(q++, std::to_string(i)); } for (int i = 0; i &lt; 10; ++i) { std::cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; while (q != p) { strAlloc.destroy(--q); } strAlloc.deallocate(p, 10); return 0;}","link":"/2021/08/03/CppPrimer5th/allocator/"},{"title":"ch02","text":"信息的表示和处理计算机通过有限个二进制位完成对信息的编码，当有限个二进制位不足以表示某个信息时，就会发生溢出（overflow）。 无符号编码 补码（带符号编码） 浮点数编码 整数运算和浮点数运算 整数运算是精确的，整数编码的范围较小。 浮点数运算是近似的，浮点数编码的范围较大。 12345678910// 整数运算，运算顺序不同，溢出的结果相同，是可以std::cout &lt;&lt; 500 * 400 * 300 * 200 &lt;&lt; std::endl;std::cout &lt;&lt; 500 * (400 * 300) * 200 &lt;&lt; std::endl;std::cout &lt;&lt; 500 * 400 * (300 * 200) &lt;&lt; std::endl;std::cout &lt;&lt; 200 * 300 * 400 * 500 &lt;&lt; std::endl;// 浮点数运算不可结合std::cout &lt;&lt; (3.14 + 1e20) - 1e20 &lt;&lt; std::endl;std::cout &lt;&lt; 3.14 + 1e20 - 1e20 &lt;&lt; std::endl;std::cout &lt;&lt; 3.14 + (1e20 - 1e20) &lt;&lt; std::endl; 1234567-884901888-884901888-884901888-884901888003.14","link":"/2021/07/26/CSAPP/ch02/"},{"title":"第13章 拷贝控制","text":"任何类（Class0、struct）都需要定义拷贝控制操作，程序员没有定义的拷贝控制操作，编译器会自动合成（定义）缺失的拷贝控制操作。 拷贝控制操作主要分为三类： 同类型的另一个对象来完成某对象的初始化：拷贝构造函数(copy ctor)以及移动构造函数(move ctor) 用同类型的另一个对象来给某对象赋值：拷贝赋值运算符(copy op=)以及移动赋值运算符(move op=) 此类型的对象销毁时：析构函数(dtor) 简单的思考1. 为什么copy ctor的参数必须是引用。通常是T const &amp;。如果copy ctor的参数不是引用，而是一个值类型，当第一次调用copy ctor时，我们需要将对象作为实参再次调用copy ctor来传递给拷贝构造函数，这会导致copy ctor的循环调用。 2. 为什么copy ctor不应该被声明为explicit。123explicit Foo(Foo const &amp;rhs) = default; // 合成的 copy ctorFoo b(a); // 正确Foo c = a; // error: no matching function for call to 'Foo::Foo(Foo&amp;)' 当我们使用explicit声明一个拷贝构造函数时，我们无法使用copy init(拷贝初始化)来初始化一个对象。只能使用direct init(直接初始化)。 3. synthesized copy ctor的拷贝流程synthesized copy ctor会拷贝所有的非static数据成员，根据成员类型的不同，采用不同的拷贝方法。 内置类型成员：直接拷贝(int a = b) 类类型成员：调用成员的copy ctor进行拷贝 内置数组类型成员：因为内置数组不能直接拷贝，所以会对数组进行逐元素拷贝。 4. copy op=能够声明为全局函数(global function)吗copy op= 必须是一个nonstatic member function。 例如下面就会报错 12// compile error: 'Foo&amp; operator=(Foo&amp;, const Foo&amp;)' must be a nonstatic member functionfriend Foo &amp;operator=(Foo &amp;lhs, Foo const &amp;rhs); 5. 析构函数的作用是什么？析构函数体为空，那该类型对象的成员还会销毁吗？ 析构函数并不会直接销毁对象的成员变量，它负责执行程序员编写的对象销毁时的附加代码（例如释放分配的动态内存，或者减小引用计数）。 销毁成员变量其实是由析构函数之后执行的析构阶段负责。 一个类对象从创建到销毁的流程： 构造阶段（初始值列表initialization list）：成员变量的初始化阶段，如果没有使用initialization list，会进行default initialization。 执行构造函数体 … 执行析构函数体 析构阶段：按成员初始化的逆序逐一销毁成员。 6. =default 与 delete 的用法有什么区别。 =default只能用于定义类的拷贝控制函数，既可以在类内定义，也可以在类外定义（类内声明），与普通函数一样。 =delete可以定义所有的成员函数（主要是拷贝控制函数），用来阻止该成员函数的使用，只能在类内定义。 =delete只能在类内定义的理解：=default函数只会影响这个函数的代码，编译时只需要知道函数声明即可，而=delete函数编译时需要告知编译器阻止对它的调用。 7. 编译器生成的拷贝控制函数什么时候是=delete因为类的拷贝控制操作依赖于成员的拷贝控制操作，所以当某类的数据成员中不能完成拷贝控制操作，该类对应的拷贝控制操作会被定义为=delete。 8. 析构函数被定义为=delete 不能定义该类的变量。 不能创建该类的临时对象。 变量与对象的区别：C++中，大部分情况下变量与对象等价，唯一的区别在于变量一定有变量名，而对象没有名字的概念。 9. copy ctor、copy op=以及dtor的关系 需要自定义dtor时，同时也需要自定义copy ctor以及copy op= copy ctor与copy op=是等价的（要么都自定义，要么都不自定义） 因此考虑某个类的拷贝控制操作时，优先考虑析构函数。 10. private代替=deleteC++11标准之前，通过将某个类的成员函数声明为private的，同时不给出定义来阻止对该函数的调用。 其它成员函数以及友元函数调用该函数，会发生链接时错误。 非成员函数以及友元函数调用该函数，会发生编译时错误。 11. 行为像值的类与行为像指针的类 行为像值的类：拷贝某对象时，副本和原对象互相独立。 行为像指针的类：拷贝某对象时，副本和原对象之间共享状态，一个对象的操作会影响到另一个操作。 行为像值的HasPtr 1234567891011121314151617181920212223242526272829303132333435363738// HasPtr1.hclass HasPtr {public: // 构造函数 HasPtr(std::string s = std::string()) : ps_(new std::string(s)) {} // 拷贝构造函数 HasPtr(HasPtr const &amp;rhs) : ps_(new std::string(*rhs.ps_)), i_(rhs.i_) {} // 拷贝赋值运算符 HasPtr &amp;operator=(HasPtr const &amp;rhs); // 析构函数 ~HasPtr() { delete ps_; } // --------------- Debug --------------- void pushBack(char ch) { ps_-&gt;push_back(ch); } std::string strData() const{ return *ps_; }private: int i_; std::string *ps_;};inline HasPtr &amp;HasPtr::operator=(HasPtr const &amp;rhs) { auto newPs = new std::string(*rhs.ps_); // 拷贝 rhs 管理的动态内存 delete ps_; // 释放旧内存 // 拷贝 rhs 的数据 ps_ = newPs; i_ = rhs.i_; return *this; // 返回本对象} 行为像指针的HasPtr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// HasPtr2.hclass HasPtr {public: // 构造函数，引用计数初始化为 1 HasPtr(std::string s = std::string()) : ps_(new std::string(s)), i_(0), use_(new std::size_t(1)) {} // 拷贝构造函数 HasPtr(HasPtr const &amp;rhs) : ps_(rhs.ps_), i_(rhs.i_), use_(rhs.use_) { ++*use_; } // 拷贝赋值运算符 HasPtr &amp;operator=(HasPtr const &amp;rhs); // 析构函数 ~HasPtr() { if (--*use_ == 0) { delete ps_; delete use_; } } // --------------- Debug --------------- void pushBack(char ch) { ps_-&gt;push_back(ch); } std::string strData() const{ return *ps_; }private: std::string *ps_; int i_; std::size_t *use_; // 引用计数};inline HasPtr &amp;HasPtr::operator=(HasPtr const &amp;rhs) { // 先增加 rhs 的引用计数处理自我赋值的情况 ++*rhs.use_; if (--*use_ == 0) { delete ps_; delete use_; } i_ = rhs.i_; ps_ = rhs.ps_; use_ = rhs.use_; return *this;} 1234567891011121314// Demo.cppint main() { HasPtr hp1(&quot;hp&quot;), hp2(hp1), hp3; // 拷贝构造 hp3 = hp2; // 拷贝赋值运算符 // 自我赋值 hp3 = hp3; hp1.pushBack('1'); hp2.pushBack('2'); hp3.pushBack('3'); std::cout &lt;&lt; hp1.strData() &lt;&lt; &quot; &quot; &lt;&lt; hp2.strData() &lt;&lt; &quot; &quot; &lt;&lt; hp3.strData() &lt;&lt; std::endl; return 0;} 123// 输出行为像值的HasPtr: hp1 hp2 hp3行为像指针的HasPtr: hp123 hp123 hp123 12. swap函数 对于那些需要重排元素顺序的标准库算法，它们通常需要调用swap函数来交换两个元素。如果类没有定义自己的swap函数，算法默认使用std::swap。 std::swap需要进行1次拷贝构造以及2次拷贝赋值运算，实现类似于： 123Foo tmp = lhs;lhs = rhs;rhs = tmp; 对于某些特定的类，std::swap多了一些不必要的内存分配，例如HasPtr。我们可以自定义swap函数来优化性能。 swap函数可以是成员函数，也可以是全局函数。 HasPtr 自定义 swap HasPtr可以通过交换指针来完成堆内存的交换操作。 这里的例子中swap是一个全局函数。 12345678910111213// HasPtr1.hclass HasPtr { friend void swap(HasPtr &amp;, HasPtr &amp;); // ...};void swap(Hasptr &amp;lhs, HasPtr &amp;rhs) { // 对于存在自定义swap的成员使用它们自定义的swap // 没有自定义swap的成员使用std::swap using std::swap; swap(lhs.i_); swap(lsh.ps_);} 123456// Demovoid test2() { HasPtr hp1(&quot;hp1&quot;), hp2(&quot;hp2&quot;); swap(hp1, hp2); std::cout &lt;&lt; hp1.strData() &lt;&lt; &quot; &quot; &lt;&lt; hp2.strData() &lt;&lt; std::endl;} 12// 输出hp2 hp1 13. copy and swap idiom 两个优点： 对于自定义了swap函数的类，可以通过copy and swap的技术实现copy op=，它天生就是异常安全的，同时能够正确处理自我赋值。 比起之前编写的版本，使用copy and swap实现copy op=的代码更加简洁。 HasPtr通过copy and swap技术实现copy op= 1234567// 声明HasPtr &amp;operator=(HasPtr rhs);// 定义inline HasPtr &amp;HasPtr::operator=(HasPtr rhs) { swap(*this, rhs); return *this; // 返回本对象} 注意点： 函数体不需要使用using std::swap，因为std::swap函数内会调用copy op=。 14. 头文件循环依赖 当头文件出现循环依赖时，很容易出现编译错误。如下：A.h中include B.h，而B.h中又include A.h，会发生编译时错误：error: 'A' does not name a type 如果某个类A中只需要使用B的不完整类型（指针），则可以借助前置声明取代include &quot;B.h&quot; 如果函数体中需要借助指针调用B的成员函数，则通过分离式编译将函数的定义在实现文件里定义。 123456789101112// A.h#ifndef CPP_PRIMER5_A_H#define CPP_PRIMER5_A_H#include &quot;B.h&quot;class A {private: B b_;};#endif //CPP_PRIMER5_A_H 123456789101112// B.h#ifndef CPP_PRIMER5_B_H#define CPP_PRIMER5_B_H#include &quot;A.h&quot;class B {private: A a_;};#endif //CPP_PRIMER5_B_H 12345678910111213141516171819202122232425262728// ABDemo.cpp#include &quot;A.h&quot;#include &quot;B.h&quot;int main() { A a; B b; return 0;}```c++// ABDemo.cpp 预处理后的代码class B {private: A a_; // 报错：A无法识别成一个类型};class A {private: B b_;};int main() { A a; B b; return 0;}","link":"/2021/07/27/CppPrimer5th/ch13/"},{"title":"拷贝控制示例(Message、Folder)","text":"通过标准库容器完成某个类运行时分配可变内存空间的要求，不需要自定义拷贝控制操作。 对于某些需要自己进行内存分配的类来说，需要自定义拷贝控制成员。 实现标准库Vector的一个简化版本StrVector 1 代码详细的代码设计思路请参考《C++ primter 5th》 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// StrVector.h#ifndef CPP_PRIMER5_STRVECTOR_H#define CPP_PRIMER5_STRVECTOR_H#include &lt;string&gt;#include &lt;cstddef&gt;#include &lt;memory&gt;class StrVector {public: // --------------------- 构造函数 --------------------- // strAllocator 默认初始化 StrVector() : data_(nullptr), size_(0), capacity_(0) {} // --------------------- 拷贝控制 --------------------- // copy ctor StrVector(StrVector const &amp;); // copy op= StrVector &amp;operator=(StrVector const &amp;); // dtor ~StrVector(); // --------------------- 功能函数 --------------------- void pushBack(std::string const &amp;); std::string *begin() const; std::string *end() const; std::size_t size() const; std::size_t capacity() const;private: static std::allocator&lt;std::string&gt; sStrAllocator_; std::string *data_; // 指向首元素 std::size_t size_; // 大小 std::size_t capacity_; // 容量 // --------------------- 工具函数 --------------------- // 分配内存，并从另一处拷贝对象 // 内存容量和大小相等 static std::pair&lt;std::string *, std::size_t&gt; allocateAndCopy(std::string *data, std::size_t size); // 销毁已经构造的对象，并回收内存 void destroyAndDeallocate(); // 保证最少有一个空位置 void checkCapacity(); // 扩容 void expandCapacity();};#endif //CPP_PRIMER5_STRVECTOR_H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// StrVector.cpp#include &quot;StrVector.h&quot;std::allocator&lt;std::string&gt; StrVector::sStrAllocator_ = std::allocator&lt;std::string&gt;();// copy ctorStrVector::StrVector(StrVector const &amp;rhs) { // 分配内存并从 rhs 拷贝对象 auto p = StrVector::allocateAndCopy(rhs.data_, rhs.size_); data_ = p.first; capacity_ = size_ = p.second;}// copy op=StrVector &amp;StrVector::operator=(StrVector const &amp;rhs) { // 拷贝 rhs 的数据 auto const p = StrVector::allocateAndCopy(rhs.data_, rhs.size_); // 销毁动态内存中的 std::string 对象，并回收内存 destroyAndDeallocate(); // 让 this 管理之前拷贝 rhs 的内存 data_ = p.first; capacity_ = size_ = p.second; return *this;}// dtorStrVector::~StrVector() { destroyAndDeallocate();}void StrVector::pushBack(std::string const &amp;str) { checkCapacity(); // 构造元素 sStrAllocator_.construct(data_ + size_, str); ++size_;}std::string *StrVector::begin() const { return data_;}std::string *StrVector::end() const { return data_ + size_;}std::size_t StrVector::size() const { return size_;}std::size_t StrVector::capacity() const { return capacity_;}std::pair&lt;std::string *, std::size_t&gt; StrVector::allocateAndCopy(std::string *data, std::size_t size) { auto const newData = sStrAllocator_.allocate(size); std::uninitialized_copy(data, data + size, newData); return {newData, size};}void StrVector::destroyAndDeallocate() { while (size_ &gt; 1) { sStrAllocator_.destroy(data_ + size_ - 1); --size_; } sStrAllocator_.deallocate(data_, capacity_); data_ = nullptr; capacity_ = 0;}void StrVector::checkCapacity() { if (capacity_ == size_) { expandCapacity(); }}void StrVector::expandCapacity() { // 分配一块更大的内存 // 默认的 capacity_ 为0 std::size_t newCapacity = capacity_ ? capacity_ * 2 : 1; auto const newData = sStrAllocator_.allocate(newCapacity); // 将原先的 std::string 元素拷贝到新内存 std::size_t newSize = 0; while ( newSize &lt; size_) { // 旧内存的 std::string 对象不会再用到，因此通过 std::move 减少性能损耗 sStrAllocator_.construct(newData + newSize, std::move(*(data_ + newSize))); ++newSize; } // 销毁旧内存的 std::string 元素，并释放旧内存 destroyAndDeallocate(); data_ = newData; size_ = newSize; capacity_ = newCapacity;} 2 测试1234567891011121314151617181920// StrVectorDemo.cpp#include &quot;StrVector.h&quot;#include &lt;string&gt;#include &lt;iostream&gt;int main() { StrVector sVec; for (int i = 0; i &lt; 10; ++i) { sVec.pushBack(std::to_string(i)); } std::cout &lt;&lt; &quot;size: &quot; &lt;&lt; sVec.size() &lt;&lt; &quot; capacity: &quot; &lt;&lt; sVec.capacity() &lt;&lt; std::endl; for (auto cur = sVec.begin(); cur != sVec.end(); ++cur) { std::cout &lt;&lt; *cur &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; return 0;} 123// 输出size: 10 capacity: 160 1 2 3 4 5 6 7 8 9","link":"/2021/08/04/CppPrimer5th/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB%EF%BC%88StrVector%EF%BC%89/"},{"title":"拷贝控制示例(Message、Folder)","text":"邮件处理应用中，一条消息可以被出现在多个目录中，如果某条消息的文本被修改，那么我们从包含该条消息的任何目录中都能看到改变后的内容。 1 设计详细的代码设计思路请参考《C++ primter 5th》 2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Message.h#ifndef CPP_PRIMER5_MESSAGE_H#define CPP_PRIMER5_MESSAGE_H#include &lt;string&gt;#include &lt;set&gt;#include &lt;algorithm&gt;class Folder;class Message { friend class Folder;public: // ------------------------- 构造函数 ------------------------- explicit Message(std::string content) : contents_(content), pFolderSet_(std::set&lt;Folder *&gt;()) {} // ------------------------- 拷贝控制 ------------------------- // copy ctor Message(Message const &amp;rhs) : contents_(rhs.contents_), pFolderSet_(rhs.pFolderSet_){ // 在对应的 folder 中添加 this 指针 addToFolders(); } // copy op= Message &amp;operator=(Message const &amp;rhs); // dtor ~Message() { removeFromFolders(); } // swap void swap(Message &amp;); // ------------------------- 功能函数 ------------------------- // 将 this 消息保存到新的 Folder void save(Folder &amp;); // 从 Folder 中删除 this 消息 void remove(Folder &amp;); // ------------------- Debug ------------------- // 输出消息内容 void printDebug();private: std::string contents_; // 消息内容 std::set&lt;Folder *&gt; pFolderSet_; // 文件夹列表 // ------------------------- 工具函数 ------------------------- void addToFolders(); void removeFromFolders(); // ------------------------- Folder 调用 ------------------------- // Message 单方面添加 Folder void addFolder(Folder &amp;); // Message 单方面移除 Folder void removeFolder(Folder &amp;);};#endif //CPP_PRIMER5_MESSAGE_H 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Folder.h#ifndef CPP_PRIMER5_FOLDER_H#define CPP_PRIMER5_FOLDER_H#include &lt;string&gt;#include &lt;set&gt;class Message;class Folder { friend class Message;public: // ------------------- 构造函数 ------------------- // ctor explicit Folder(std::string const &amp;name) : name_(name), pMsgSet_(std::set&lt;Message *&gt;()) {} // ------------------- 拷贝控制 ------------------- // copy ctor Folder(Folder const &amp;rhs) : name_(rhs.name_), pMsgSet_(rhs.pMsgSet_) { // rhs 记录的 Message 添加 this 文件夹 addToMessages(); } // copy op= Folder &amp;operator=(Folder const &amp;); // dtor ~Folder() { // 所有对应的 Message 删除 this 文件夹 removeFromMessages(); } // swap void swap(Folder &amp;); // ------------------- Debug ------------------- // 输出目录名以及所有的消息内容 void printDebug();private: std::string name_; // 目录名 std::set&lt;Message *&gt; pMsgSet_; // Message 指针列表 // ------------------- 工具函数 ------------------- // 所有的 Message 单方面添加 this void addToMessages(); // 所有的 Message 单方面移除 this void removeFromMessages(); // ------------------------- Message 调用 ------------------------- // this 单方面添加 Msg void addMsg(Message &amp;); // this 单方面移除 Msg void removeMsg(Message &amp;);};#endif //CPP_PRIMER5_FOLDER_H 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Message.cpp#include &quot;Message.h&quot;#include &quot;Folder.h&quot;#include &lt;iostream&gt;// copy op=Message &amp;Message::operator=(Message const &amp;rhs) { // 在之前的 folder 中移除 this 指针 removeFromFolders(); contents_ = rhs.contents_; pFolderSet_ = rhs.pFolderSet_; // 在新的 folder 中添加 this 指针 addToFolders(); return *this;}void Message::swap(Message &amp;rhs) { using std::swap; // 当成员没有定义 swap时，调用 std::swap // 将 this 和 rhs 从原来的文件夹中移除 removeFromFolders(); rhs.removeFromFolders(); swap(contents_, rhs.contents_); swap(pFolderSet_, rhs.pFolderSet_); // 将 this 和 rhs 添加到新的文件夹中 addToFolders(); rhs.addToFolders();}void Message::save(Folder &amp;folder) { pFolderSet_.insert(&amp;folder); folder.addMsg(*this);}void Message::remove(Folder &amp;folder) { pFolderSet_.erase(&amp;folder); folder.removeMsg(*this);}void Message::addToFolders() { for (Folder *pFolder : pFolderSet_) { pFolder-&gt;addMsg(*this); }}void Message::removeFromFolders() { for (Folder *pFolder : pFolderSet_) { pFolder-&gt;removeMsg(*this); }}// Message 单方面添加 Foldervoid Message::addFolder(Folder &amp;folder) { pFolderSet_.insert(&amp;folder);}// Message 单方面移除 Foldervoid Message::removeFolder(Folder &amp;folder) { pFolderSet_.erase(&amp;folder);}void Message::printDebug() { std::cout &lt;&lt; contents_ &lt;&lt; std::endl;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Folder.cpp#include &quot;Folder.h&quot;#include &quot;Message.h&quot;#include &lt;iostream&gt;// copy op=Folder &amp;Folder::operator=(Folder const &amp;rhs) { // 旧的消息中移除 this 文件夹 removeFromMessages(); // 拷贝文件夹名和消息指针列表 name_ = rhs.name_; pMsgSet_ = rhs.pMsgSet_; // 新的消息中添加 this 文件夹 addToMessages();}// swapvoid Folder::swap(Folder &amp;rhs) { using std::swap; // 从旧的 Message 中移除 this, rhs removeFromMessages(); rhs.removeFromMessages(); swap(name_, rhs.name_); swap(pMsgSet_, rhs.pMsgSet_); // 新的 Message 中添加 this, rhs addToMessages(); rhs.addToMessages();}// 所有的 Message 单方面添加 thisvoid Folder::addToMessages() { for (auto pMsg : pMsgSet_) { pMsg-&gt;addFolder(*this); }}// 所有的 Message 完全移除 thisvoid Folder::removeFromMessages() { for (auto pMsg : pMsgSet_) { pMsg-&gt;removeFolder(*this); }}void Folder::addMsg(Message &amp;Msg) { pMsgSet_.insert(&amp;Msg);}// this 单方面移除 Msgvoid Folder::removeMsg(Message &amp;Msg) { pMsgSet_.erase(&amp;Msg);}void Folder::printDebug() { std::cout &lt;&lt; &quot;目录名: &quot; &lt;&lt; name_ &lt;&lt; &quot;\\n&quot;; for (auto pMsg : pMsgSet_) { pMsg-&gt;printDebug(); }} 3 测试1234567891011121314151617181920212223242526// MessageFolderDemo.cpp#include &quot;Message.h&quot;#include &quot;Folder.h&quot;#include &lt;iostream&gt;int main() { Folder f1(&quot;目录1&quot;), f2(&quot;目录2&quot;); Message m1(&quot;m1&quot;), m2(&quot;m2&quot;), m3(&quot;m3&quot;); m1.save(f1); m1.save(f2); m2.save(f1); m2.save(f2); m3.save(f1); f1.printDebug(); f2.printDebug(); std::cout &lt;&lt; &quot;移除部分消息\\n&quot;; m2.remove(f2); m3.remove(f1); f1.printDebug(); f2.printDebug(); return 0;} 1234567891011121314// 输出目录名: 目录1m3m2m1目录名: 目录2m2m1移除部分消息目录名: 目录1m2m1目录名: 目录2m1","link":"/2021/08/04/CppPrimer5th/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E7%A4%BA%E4%BE%8B(Message%E3%80%81Folder)/"},{"title":"Windows terminal ssh 免密登录 Linux","text":"1. 修改设置- 打开 windows terminal 的 配置文件(json)- 找到 profiles 属性- powershell中通过 new_guid 生成新的 guid- 添加代码123456{ &quot;guid&quot;: &quot;{3a4f3a4b-f4bc-46c6-9b65-94a3a223f3f9}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;UbuntuDesktop&quot;, &quot;commandline&quot;: &quot;ssh cmtang@192.168.29.128&quot;} 2. Linux 存储 windows 公钥- sudo apt install openssh-server- windows 生成 ssh 密钥，C:\\Users\\Chengming\\.ssh- ~/.ssh/authorized_keys 中添加 windows 公钥 id_rsa.pub","link":"/2021/05/28/others/WindowsTerminal-ssh-linux/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Gitee","slug":"Gitee","link":"/tags/Gitee/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"LinuxC 系统开发","slug":"LinuxC-系统开发","link":"/tags/LinuxC-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"离散数学","slug":"离散数学","link":"/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"严格弱序关系","slug":"严格弱序关系","link":"/tags/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E5%85%B3%E7%B3%BB/"},{"name":"计算机系统","slug":"计算机系统","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机系统","slug":"深入理解计算机系统","link":"/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"Demo","slug":"Demo","link":"/tags/Demo/"},{"name":"C++ primer","slug":"C-primer","link":"/tags/C-primer/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Windows Terminal","slug":"Windows-Terminal","link":"/tags/Windows-Terminal/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"C++那些事","slug":"C-那些事","link":"/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"name":"Linux系统编程","slug":"Linux系统编程","link":"/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"深入理解计算机系统","slug":"深入理解计算机系统","link":"/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"C++ Primer 5th","slug":"C-Primer-5th","link":"/categories/C-Primer-5th/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}