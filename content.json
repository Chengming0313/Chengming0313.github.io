{"pages":[],"posts":[{"title":"CSAPP：计算机系统漫游","text":"计算机系统由硬件和系统软件组成，它们共同工作来运行应用程序。 这一章通过研究hello.c来介绍计算机系统的主要概念和主题。 1 hello.c123456#include &lt;cstdio&gt;int main() { printf(&quot;hello, world\\n&quot;); return 0;} 2 计算机系统中信息的表示 计算机系统中的信息就是二进制位串+上下文（解读方式） 计算机系统中的所有信息都是以一串二进制位表示的，在不同的上下文中，同一个二进制位串会被解读成不同的信息。 例如11111111，如果计算机认为它是8位无符号数，则被解读为255，如果计算机认为它是8位带符号数，则被解读为-1。 3 hello.c的编译过程unix上通过编译器驱动程序完成源文件到二进制可执行目标文件的转换。 示例如下： 1gcc -o hello hello.c 编译过程的4个阶段 预处理阶段：进行一些预处理工作，修改hello.c得到修改后的源文件hello.i。 编译阶段：生成关于源文件汇编语言版本的文本文件hello.s。 汇编阶段：生成可重定位的二进制目标文件hello.o。 链接阶段：生成最终的二进制可执行目标文件hello。 4 系统的硬件组成 计算机系统的硬件组成包括：总线、中央处理器（CPU）、内存（主存）、I/O设备。 磁盘以及网络都可以看成一个I/O设备。 总线：负责在系统的各个部分之间传输定长的字节块（字）。 字是一个基本的系统参数，现在大多数系统的字长都是8个字节（64位）。 类别：I/O总线、系统总线、内存总线 中央处理器（CPU）：负责执行存储在内存中的指令，包括PC、ALU、寄存器文件。 程序计数器（PC）：大小为一个字的寄存器，保存着下一条将要执行的机器指令的地址。 算术/逻辑单元（ALU）：CPU的执行(算术运算、逻辑运算)单元。 寄存器文件：由若干个大小为一个字的寄存器组成，每个寄存器都有一个唯一的名字。 内存：一个临时存储设备，CPU执行程序时，负责存储程序以及程序产生的数据。 物理结构：由一组DRAM芯片组成 逻辑结构：线性字节数组，内存中的每个字节都与一个地址唯一对应。 I/O设备：输入/输出设备，常用来与外界交换信息（显示器、键盘、网络设备、磁盘）。 每个I/O设备都是通过适配器或者控制器和I/O总线交换信息。 CPU工作流程的简单理解从系统通电到断电，CPU一直在重复一个简单的流程。 从内存中取出PC指向的机器指令。 对该指令进行解释，执行该指令指示的简单操作. 更新PC，使其指向下一条要执行的命令。 运行hello的简单流程 键盘上输入./hello，shell将字符逐一读入寄存器，再把它们放入内存。 当读取到回车字符，命令的输入结束，shell程序通过一系列指令从磁盘将二进制的可执行目标文件hello复制到内存。 一般情况，数据需要通过寄存器才能往内存写入数据，而计算机系统通过DMA(存储器直接存取)技术可以直接将数据从磁盘写入到内存。 一旦hello被加载到内存，CPU就开始执行hello内的机器指令，通过寄存器向显示器写入”hello, world\\n”。 “hello world\\n”的转移路线：磁盘 -&gt; 内存 -&gt; 寄存器 -&gt; 显示器 5 计算机系统存储器的层次结构5.1 高速缓存的设计在计算机系统运行的过程中，需要将字节块通过总线在不同的地方之间来回搬运（寄存器、内存、CPU、I/O设备）。 而不同的存储器之间的访问速度差距很大，例如寄存器的访问速度远远高于内存，这就导致当CPU执行完一条指令，从内存读取下一条指令需要等待。这就导致CPU运行时的时间消耗了一大部分在读取指令上。 为了加快CPU从内存读取字节块的速度，在CPU与内存之间引入了L1, L2, L3高速缓存用来存放CPU近期最有可能用到的信息。 高速缓存不是一个特定的部件，它是一种设计思想，例如寄存器文件可以看作L1的高速缓存，L1又可以看作L2的高速缓存 5.2 层次结构特点越往上，存储器的访问速度越快，容量越小，每字节存储单位的造价越高。 上一层的存储器可以看作下一层的高速缓存。 6 操作系统（OS） 操作系统是在系统硬件和应用程序中间插入的软件层。 所有的应用程序都不会直接访问硬件，而是通过操作系统提供的服务来访问以及操作系统的硬件设备。 6.1 操作系统的功能操作系统通过对硬件设备进行抽象，来完成两个主要功能。 防止硬件被失控的应用程序滥用。 提供一种简单一致的机制来控制复杂庞大的低级硬件设置。 6.2 操作系统提供的抽象表示操作系统提供的抽象概念：进程、虚拟内存、文件。 6.3 进程 进程是操作系统对一个正在运行的程序的抽象，通俗说进程就是一个活着的程序。 因为进程是一个正在运行的程序，那么它就有自己的上下文（PC和寄存器文件的当前值、内存的当前值）。 为了使得多个进程能够同时运行，操作系统内核需要在不同的进程之间进行切换。 操作系统内核不是一个独立的进程，是系统管理全部进程的代码和数据结构的集合，它常驻内存。 进程切换会导致上下文切换：操作系统保存旧进程的上下文，操作系统恢复新进程的上下文。 上下文切换由操作系统负责，是内核代码的一部分，因此在进行上下文切换之前，旧进程需要将控制权交还给操作系统，切换完成之后，操作系统再把控制权移交给新进程。 shell程序执行hello会导致进程的切换，如图： 6.4 线程传统的进程调度模型中，进程扮演着两种角色： 调度、执行的基本单位 资源所有权拥有者 线程模型中，每个进程都有着若干个线程。 进程只是资源所有权的拥有者，资源由进程下的所有线程共享。 线程取代进程成为操作系统内核调度的基本单位。 两个优点： 线程的切换开销更小。 线程之间通信比进程之间通信效率更高。 6.4 虚拟内存 虚拟内存是对程序存储器的抽象。 虚拟内存提供一种假象：每个进程独占地使用系统内存。 6.5 文件 文件是对I/O设备的抽象。 文件本质就是字节序列，所有的I/O设备都可以看成文件，都可以使用操作系统提供的统一系统函数调用来读写字节块。 7 重要主题7.1 Amdahl定律当我们对系统的某个部分加速时，对系统整体性能的影响取决于该部分的重要性以及性能提升幅度。 假设 $T_{old}$为系统原始耗时，$T_{new}$为某个部分优化后的系统耗时, $\\alpha$为该部分耗时占系统耗时的比重，$k$为该部分性能提升比例。 易得该部分原始耗时为$\\alpha T_{old}$，优化后耗时为$\\frac {\\alpha T_{old}} {k}$ 因此 $$T_new = (1-\\alpha)T_{old} + \\frac {\\alpha T_{old}} {k}$$加速比$S=T_{old} / T_{new}$等于 $$S = \\frac 1 {(1-\\alpha) + \\frac \\alpha k}$$ $k$趋向$\\infty$时 $$S_{\\infty} = \\frac 1 {1 - \\alpha}$$ 7.2 并发与并行 并发：一个通用的概念，表示一个同时具有多个活动的系统。 并行：利用并发使系统运行得更快。 并发的层次 线程级并发 指令级并发 多核处理器 超线程 单指令、多数据并行 SIMD并行 7.3 指令架构集、虚拟机 指令集架构：提供了对CPU硬件的抽象，提供了一种假象：CPU一次只会执行一条指令。 不同的硬件实现同一个指令架构集，只是开销和性能不同，但是结果一样。 虚拟机：对整个计算机系统的抽象，包括操作系统、CPU、内存、I/O设备。","link":"/2021/08/04/CSAPP/1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"title":"C++ const","text":"本系列参考第三方文档 C++那些事 const const 含义 定义一个 const 变量 const 的一些特性 指针与 const 函数与 const 类与 const 1. const 含义 const 用来修饰变量，表示变量的值不可改变(赋值), 是一个 只读变量 。 const 修饰的变量不一定是一个 常量表达式 , 常量表达式除了要求值不可更改之外, 还要求在编译过程中就能得到计算结果。 一般使用 constexpr 来修饰一个常量表达式, 编译器会对变量进行验证。不符合要求会报错。 声明 constexpr 的类型有所限制, 必须属于 字面值类型 。 2. 定义一个 const 变量 const 变量必须初始化 const 变量不能赋值 const 修饰的 类变量 , 只有在 构造函数 完成后才算真正具有 const 属性。 123const int i1; // error: uninitialized const 'i1'const int i = 0;i = 1; // error: assignment of read-only variable 'i' 3. const 的一些特性 用 const 代替 #define如下, #define 定义的 SIZE_NUM, 在 预处理过程 就已经被 10 替换, 不会进入 符号表。程序出现问题时不好定位。 12#define SIZE_NUM = 10const int SIZE_NUM = 10; const 变量默认为文件局部变量 非 const 变量不同文件访问 123456789101112131415// g++ -o main main.cpp other.cpp// other.cppint i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;extern int i;int main() { std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} const 变量不同文件访问 const 变量需要显式使用 extern 定义, 才能跨文件访问 1234567891011121314151617// other.cppextern const int i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;// 这里不用 const 声明也能够通过, i = 200 不会报错, 但是// 程序运行时会出错extern const int i;int main() { // i = 200; std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} 4. 指针与 const const 总是优先与它左侧的符号配对 12345const char * a; // pointer to const charchar const char * a; // 同上char *const a; // const pointer to charchar const *const a; // const pointer to const charconst char *const a; // 同上 指向常量的指针（底层 const） 可以不用初始化, 不能通过指针解引用去修改它的值 12345char const * a; // 底层 const 可以不用初始化char ch = 'a';a = &amp;ch;*a = 'x'; // error, 不能通过指针修改它的值 可以指向非 const 的变量 12345int i = 10;int const *pi = &amp;i;std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n';std::cout &lt;&lt; ++i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n'; 1210 1011 11 不能用 void * 指向 const 变量, 必须使用 const void * 123const int a = 10;void const *ptr1 = &amp;a;void * ptr2 = &amp;a; // error 常量指针（顶层 const） 必须初始化, 指针不能修改 1234int a = 10;int *const ptr = &amp;a;int *const ptr2; // error: uninitialized const 'ptr2'ptr = nullptr; // error: assignment of read-only variable 'ptr' error: const T * —-&gt; T * const 12int const a = 10;int *const ptr = &amp;a; // error: invalid conversion from 'const int*' to 'int*' 5. const 变量的拷贝操作 顶层 const 对象可以拷贝给非顶层 const 对象 1234const int ci = 100;int i = ci; // i: 100int *const p1 = &amp;i;int * p2 = p1; 非顶层 const 对象也可以拷给顶层 const 对象 12345// -&gt; 顶层 constint j = 200;const int cj = j;int * ptr1 = &amp;j;int *const ptr2 = ptr1; 底层 const 对象不能拷给非底层 const 对象 1234567891011int const &amp;cr1 = 100;int &amp;r1 = cr1; // error: binding reference of type 'int&amp;' to 'const int' discards qualifiersint const *p3 = &amp;ci;int * p4 = p3; // error: invalid conversion from 'const int*' to 'int*'// T const * const -&gt;int const *const p5 = &amp;ci;int * p6 = p5; // error: invalid conversion from 'const int*' to 'int*'int const * p7 = p5;int *const p8 = p5; // error: invalid conversion from 'const int*' to 'int*' 非底层 const 对象可以拷给底层 const 对象 1234567int &amp; r2 = j;int const &amp;cr2 = r2;int * ptr3 = &amp;j;int const *ptr4 = ptr3;int const *const ptr5 = ptr3; 6. 函数与 const6.1 修饰返回值 return by const value，一般情况下,，没有意义。一些特殊情况下是有意义的, 详见Effective C++ 条款21。 123const int get() {return 1;} // 无意义// 这是有意义的, 防止出现 (a * b) = c;const Rational operator*(Rational const &amp;lhs, Rational const &amp;rhs); return by const reference 返回普通引用, 可以修改返回值, 可以作为左值使用 1234567891011121314std::string &amp;Get(std::string &amp;a) { return a;}int main() { std::string str = &quot;123456&quot;; // 这里要用 &amp;, 不然不是引用 std::string &amp;str2 = Get(str); str2 = &quot;xxxxxx&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; Get(str) = &quot;hello world&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; return 0;} 12xxxxxx xxxxxxhello world hello world 返回常量引用，不能修改 12345678int main() { std::string str = &quot;123456&quot;; // 这里要用 const &amp; std::string const &amp;str2 = GetConst(str); std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; std::cout &lt;&lt; GetConst(str).length() &lt;&lt; std::endl; return 0;} return by T const * 1234567int const *Get(int *p) { return p;}int a = 10;int const *p1 = Get(&amp;a);int * p2 = Get(&amp;a); // error return by T * const1234567int *const Get2(int *p) { return p;}int a = 10;int *const p3 = Get2(&amp;a);int * p4 = Get2(&amp;a); 6.2 修饰参数 普通的 顶层 const (不是 T const &amp;)使用普通的 顶层 const 作为函数参数，没有意义, 函数收到的是一个副本。 12void fun1(int const val);void fun2(int *const ptr); 底层 const通过传入 T const * 的方式, 使得函数能够通过指针访问函数体外的对象, 又保证了数据的不可修改。 1void fun1(int const *p); T const &amp;pass by const reference 能让函数直接通过变量名访问作用域外的对象, 还能保证数据的 read only 1void fun1(std::string const &amp;str); 对于类类型的变量来说, 使用pass by value 的方式传值, 在拷贝过程中对象的拷贝构造以及析构都会消耗时间, 效率较低。我们可以使用 pass by pointer to const 以及 pass by const reference 来提高效率, 同时保证数据的安全性。 7. 类与 const const member function 普通的member function 中的 this pointer 类型为 T *, 而 const member function 中的 this pointer 类型为 T const *。 对于 const object来说, 它不能用来给普通的this pointer初始化, 它只能给const member function中T const *类型的this pointer初始化。 对于普通的 object, 它即可以使用const member function, 又可以使用普通的 member function。因为T * 既可以给 T * 初始化, 又可以给 T const * 初始化。 除了函数参数列表, 是否是 const member function, 也可以进行重载. 普通的 object 默认调用 非 const member function. 12345678910111213class A {public: void print() const { std::cout &lt;&lt; &quot;const print()\\n&quot;; } void print() { std::cout &lt;&lt; &quot;print()\\n&quot;; }};int main() { A a; A const ca; a.print(); ca.print(); return 0;} 123// 结果print()const print() const 成员 这里讨论一下类内初始值与初始值列表的优先级。初始值列表的优先级比类内初始值要高。只有没有为该成员设定初始值列表时, 它才会使用类内初始值进行初始化。 1234567891011121314class A {public: A() : _a(1) {} void Print() { std::cout &lt;&lt; _a &lt;&lt; &quot;\\n&quot;; }private: int _a = 0;};int main() { A a; a.Print(); return 0;} 12// 结果1 类中的 const 成员可以使用类内初始值的方式初始化 1const int _a = 999; 类中的 const 成员可以使用初始值列表的方式初始化 12const int _a;A() : _a(999) {} 不能在构造函数中用赋值表达式初始化 const 成员, 在进入构造函数体之前, 成员的初始化过程已经结束。 12const int _a;A() { _a = 999; } // error 当要表示类中共享的常量时, 通常使用 static const 修饰 使用类内初始值的方式定义 static const 1static const int _a = 999; // 类内初始值的方式初始化 static const 变量 采用与一般 static 变量一样的方法, 类内声明, 类外定义 1234// in classstatic const int _a;// 类的实现文件const int A::_a = 999; // 需要去除 static 符号","link":"/2021/04/11/Cpp/C-const/"},{"title":"具名条件：compare","text":"1. 前置知识1.1. 笛卡尔积$$A \\ast B = { (x, y) | x \\in A \\land y \\in B}$$ 1.2. 二元关系二元关系R实质上是有序对的集合. $从A到B的二元关系：R \\subseteq A \\ast B$ $A上的二元关系：R \\subseteq A \\ast A$ $x对y存在二元关系R的符号表示：$$xRy$, $&lt;x, y&gt; \\in R$ 1.3. 二元关系的表示: 列举、描述、关系矩阵、关系图1.4. 特殊的二元关系 $空关系：R = \\varnothing $ $恒等关系：I_A = {&lt;x, x&gt; | x \\in A }$ $全域关系：R = A \\ast B$ 1.5. A上的二元关系的性质 自反性: $\\forall x \\in A, &lt;x, x&gt; \\in A$ 反自反性: $\\forall x \\in A, &lt;x, x&gt; \\notin A$ 对称性: $\\forall x, y \\in A, 如果 &lt;x, y&gt; \\in R, 则 &lt;y, x&gt; \\in R$ 反对称性: $\\forall x, y \\in A, 如果 &lt;x, y&gt; \\in R, &lt;y, x&gt; \\in R, 则 x = y$ 传递性: $\\forall x, y, z \\in A, 如果 &lt;x, y&gt; \\in R, &lt;y, z&gt; \\in A, 则 &lt;x, z&gt; \\in R$ ！！！对称性和反对称性并不对立, 一个A上的二元关系可以既有对称性又有反对称性, 当然也可以都没有. 1.6. 等价关系如果R为A上的二元关系，如果R具备自反性、对称性以及传递性，则R为A上的等价关系（Equivalence Relation） 等价关系中集合元素的等价性 $如果R为等价关系$ $&lt;a, b&gt;\\in R，称a等价于b，记作a\\sim b$ $因为R是对称的，所以a\\sim b即b\\sim a$ 1.7. 偏序关系（Partial order）以及偏序集次序关系: 任务之间存在先后关系 如果R为A上的二元关系，如果R具备自反性、反对称性以及传递性，则R为A上的偏序关系，简称偏序，记作$\\preceq$ A以及A上的偏序关系$\\preceq$一起称作一个偏序集，记为$&lt;A, \\preceq&gt;$ 偏序集中的元素的性质 $&lt;A, \\preceq&gt;为偏序集，\\forall x, y\\in A$ $可比（comparable）：x \\in \\preceq \\lor y \\in \\preceq$ $x小于y：x\\in \\preceq \\land x \\ne y$，即偏序关系中x为第一分量，与为第二分量 $不可比（incomparable）：x \\notin \\preceq \\land y\\notin \\preceq$ 1.8. 全序关系$&lt;A, \\preceq&gt;$为偏序关系，如果$\\forall x, y\\in A$，都有$x\\preceq y或者y\\preceq x$（任意两个元素是可比的），则称$\\preceq 为全序关系$ 1.9 严格偏序关系与（非严格的）偏序关系相比，唯一的不同在于（非严格的）偏序关系满足自反性，而严格偏序关系要求反自反性。 偏序关系与严格偏序关系不是包含与被包含的关系 2. STL 具名要求：CompareCompare要求满足严格弱序关系 严格弱序关系（strict weak order）的定义如下： compare本身是一个严格偏序关系 不可比较的关系（!compare(a, b) &amp;&amp; !compare(b, a)）是一个等价关系 2.1 Compare 的功能 compare(a, b) == true表示 a 先于 b !compare(a, b) == true表示 b 先于 a !compare(a, b) &amp;&amp; !compare(b, a) == true表示a与b等价（相等） 2.2 一个合格的 Compare为了使得compare 能够很好地表达上述含义, 要求如下 2.2.1 compare本身是一个严格偏序关系 反自反性：compare(a, a) == false 反对称性：如果compare(a, b) == true，那么compare(b, a) == false 传递性：如果comapre(a, b) &amp;&amp; compare(b, c) == true，那么compare(a, c) == true 2.2.2 equiv是一个等价关系为了表示方便，使用equiv(a, b) 表示 !compare(a, b) &amp;&amp; !compare(b, a) 自反性：equiv(a, a) == true 对称性：如果equiv(a, b) == true，那么equiv(b, a) == true 传递性：如果equiv(a, b) &amp;&amp; equiv(b, c) == true，那么equiv(a, c) == true","link":"/2021/07/23/Cpp/namedRequirementCompare/"},{"title":"使用allocator将内存分配和对象的构造分开","text":"当我们需要按需构造对象时，new []会有性能上的损耗，它会初始化所有的内存。这时候我们可以通过allocator将内存分配和对象构造分开。 1 allocator&lt;T&gt; 头文件：&lt;memory&gt; 构造allocator对象 1std::allocator&lt;std::string&gt; alloc; alloc分配内存 1auto const p = alloc.allocate(n); construct构造对象 123auto q = p;alloc.construct(q++, &quot;hello&quot;);alloc.construct(q++, 5, 'a'); destroy销毁对象 1alloc.destroy(q--); deallocate回收内存 1alloc.deallocate(p, n); 2 注意点 allocate(n)与new [n]的结果类型一致，都是T *。 allocate的结果最好用const修饰防止被修改，因为deallocate需要指定动态内存首元素位置。 没有construct的内存，不要使用，与内置变量的默认初始化一样，其结果是未定义的。 3 实例12345678910111213141516171819202122// allocatorDemo.cpp// Output: 0 1 2 3 4 5 6 7 8 9 int main() { std::allocator&lt;std::string&gt; strAlloc; auto const p = strAlloc.allocate(10); auto q = p; for(int i = 0; i &lt; 10; ++i) { strAlloc.construct(q++, std::to_string(i)); } for (int i = 0; i &lt; 10; ++i) { std::cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; while (q != p) { strAlloc.destroy(--q); } strAlloc.deallocate(p, 10); return 0;}","link":"/2021/08/03/CppPrimer5th/allocator/"},{"title":"动态内存管理类（StrVector）","text":"通过标准库容器完成某个类运行时分配可变内存空间的要求，不需要自定义拷贝控制操作。 对于某些需要自己进行内存分配的类来说，需要自定义拷贝控制成员。 实现标准库Vector的一个简化版本StrVector 1 代码详细的代码设计思路请参考《C++ primter 5th》 StrVector.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef CPP_PRIMER5_STRVECTOR_H#define CPP_PRIMER5_STRVECTOR_H#include &lt;string&gt;#include &lt;cstddef&gt;#include &lt;memory&gt;class StrVector {public: // --------------------- 构造函数 --------------------- // strAllocator 默认初始化 StrVector() : data_(nullptr), size_(0), capacity_(0) {} // --------------------- 拷贝控制 --------------------- // copy ctor StrVector(StrVector const &amp;); // copy op= StrVector &amp;operator=(StrVector const &amp;); // dtor ~StrVector(); // --------------------- 功能函数 --------------------- void pushBack(std::string const &amp;); std::string *begin() const; std::string *end() const; std::size_t size() const; std::size_t capacity() const;private: static std::allocator&lt;std::string&gt; sStrAllocator_; std::string *data_; // 指向首元素 std::size_t size_; // 大小 std::size_t capacity_; // 容量 // --------------------- 工具函数 --------------------- // 分配内存，并从另一处拷贝对象 // 内存容量和大小相等 static std::pair&lt;std::string *, std::size_t&gt; allocateAndCopy(std::string *data, std::size_t size); // 销毁已经构造的对象，并回收内存 void destroyAndDeallocate(); // 保证最少有一个空位置 void checkCapacity(); // 扩容 void expandCapacity();};#endif //CPP_PRIMER5_STRVECTOR_H StrVector.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &quot;StrVector.h&quot;std::allocator&lt;std::string&gt; StrVector::sStrAllocator_ = std::allocator&lt;std::string&gt;();// copy ctorStrVector::StrVector(StrVector const &amp;rhs) { // 分配内存并从 rhs 拷贝对象 auto p = StrVector::allocateAndCopy(rhs.data_, rhs.size_); data_ = p.first; capacity_ = size_ = p.second;}// copy op=StrVector &amp;StrVector::operator=(StrVector const &amp;rhs) { // 拷贝 rhs 的数据 auto const p = StrVector::allocateAndCopy(rhs.data_, rhs.size_); // 销毁动态内存中的 std::string 对象，并回收内存 destroyAndDeallocate(); // 让 this 管理之前拷贝 rhs 的内存 data_ = p.first; capacity_ = size_ = p.second; return *this;}// dtorStrVector::~StrVector() { destroyAndDeallocate();}void StrVector::pushBack(std::string const &amp;str) { checkCapacity(); // 构造元素 sStrAllocator_.construct(data_ + size_, str); ++size_;}std::string *StrVector::begin() const { return data_;}std::string *StrVector::end() const { return data_ + size_;}std::size_t StrVector::size() const { return size_;}std::size_t StrVector::capacity() const { return capacity_;}std::pair&lt;std::string *, std::size_t&gt; StrVector::allocateAndCopy(std::string *data, std::size_t size) { auto const newData = sStrAllocator_.allocate(size); std::uninitialized_copy(data, data + size, newData); return {newData, size};}void StrVector::destroyAndDeallocate() { while (size_ &gt; 1) { sStrAllocator_.destroy(data_ + size_ - 1); --size_; } sStrAllocator_.deallocate(data_, capacity_); data_ = nullptr; capacity_ = 0;}void StrVector::checkCapacity() { if (capacity_ == size_) { expandCapacity(); }}void StrVector::expandCapacity() { // 分配一块更大的内存 // 默认的 capacity_ 为0 std::size_t newCapacity = capacity_ ? capacity_ * 2 : 1; auto const newData = sStrAllocator_.allocate(newCapacity); // 将原先的 std::string 元素拷贝到新内存 std::size_t newSize = 0; while ( newSize &lt; size_) { // 旧内存的 std::string 对象不会再用到，因此通过 std::move 减少性能损耗 sStrAllocator_.construct(newData + newSize, std::move(*(data_ + newSize))); ++newSize; } // 销毁旧内存的 std::string 元素，并释放旧内存 destroyAndDeallocate(); data_ = newData; size_ = newSize; capacity_ = newCapacity;} 2 测试StrVectorDemo.cpp12345678910111213141516171819#include &quot;StrVector.h&quot;#include &lt;string&gt;#include &lt;iostream&gt;int main() { StrVector sVec; for (int i = 0; i &lt; 10; ++i) { sVec.pushBack(std::to_string(i)); } std::cout &lt;&lt; &quot;size: &quot; &lt;&lt; sVec.size() &lt;&lt; &quot; capacity: &quot; &lt;&lt; sVec.capacity() &lt;&lt; std::endl; for (auto cur = sVec.begin(); cur != sVec.end(); ++cur) { std::cout &lt;&lt; *cur &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; return 0;} 输出12size: 10 capacity: 160 1 2 3 4 5 6 7 8 9","link":"/2021/08/04/CppPrimer5th/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB%EF%BC%88StrVector%EF%BC%89/"},{"title":"拷贝控制示例(Message、Folder)","text":"邮件处理应用中，一条消息可以被出现在多个目录中，如果某条消息的文本被修改，那么我们从包含该条消息的任何目录中都能看到改变后的内容。 1 设计详细的代码设计思路请参考《C++ primter 5th》 2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Message.h#ifndef CPP_PRIMER5_MESSAGE_H#define CPP_PRIMER5_MESSAGE_H#include &lt;string&gt;#include &lt;set&gt;#include &lt;algorithm&gt;class Folder;class Message { friend class Folder;public: // ------------------------- 构造函数 ------------------------- explicit Message(std::string content) : contents_(content), pFolderSet_(std::set&lt;Folder *&gt;()) {} // ------------------------- 拷贝控制 ------------------------- // copy ctor Message(Message const &amp;rhs) : contents_(rhs.contents_), pFolderSet_(rhs.pFolderSet_){ // 在对应的 folder 中添加 this 指针 addToFolders(); } // copy op= Message &amp;operator=(Message const &amp;rhs); // dtor ~Message() { removeFromFolders(); } // swap void swap(Message &amp;); // ------------------------- 功能函数 ------------------------- // 将 this 消息保存到新的 Folder void save(Folder &amp;); // 从 Folder 中删除 this 消息 void remove(Folder &amp;); // ------------------- Debug ------------------- // 输出消息内容 void printDebug();private: std::string contents_; // 消息内容 std::set&lt;Folder *&gt; pFolderSet_; // 文件夹列表 // ------------------------- 工具函数 ------------------------- void addToFolders(); void removeFromFolders(); // ------------------------- Folder 调用 ------------------------- // Message 单方面添加 Folder void addFolder(Folder &amp;); // Message 单方面移除 Folder void removeFolder(Folder &amp;);};#endif //CPP_PRIMER5_MESSAGE_H 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Folder.h#ifndef CPP_PRIMER5_FOLDER_H#define CPP_PRIMER5_FOLDER_H#include &lt;string&gt;#include &lt;set&gt;class Message;class Folder { friend class Message;public: // ------------------- 构造函数 ------------------- // ctor explicit Folder(std::string const &amp;name) : name_(name), pMsgSet_(std::set&lt;Message *&gt;()) {} // ------------------- 拷贝控制 ------------------- // copy ctor Folder(Folder const &amp;rhs) : name_(rhs.name_), pMsgSet_(rhs.pMsgSet_) { // rhs 记录的 Message 添加 this 文件夹 addToMessages(); } // copy op= Folder &amp;operator=(Folder const &amp;); // dtor ~Folder() { // 所有对应的 Message 删除 this 文件夹 removeFromMessages(); } // swap void swap(Folder &amp;); // ------------------- Debug ------------------- // 输出目录名以及所有的消息内容 void printDebug();private: std::string name_; // 目录名 std::set&lt;Message *&gt; pMsgSet_; // Message 指针列表 // ------------------- 工具函数 ------------------- // 所有的 Message 单方面添加 this void addToMessages(); // 所有的 Message 单方面移除 this void removeFromMessages(); // ------------------------- Message 调用 ------------------------- // this 单方面添加 Msg void addMsg(Message &amp;); // this 单方面移除 Msg void removeMsg(Message &amp;);};#endif //CPP_PRIMER5_FOLDER_H 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Message.cpp#include &quot;Message.h&quot;#include &quot;Folder.h&quot;#include &lt;iostream&gt;// copy op=Message &amp;Message::operator=(Message const &amp;rhs) { // 在之前的 folder 中移除 this 指针 removeFromFolders(); contents_ = rhs.contents_; pFolderSet_ = rhs.pFolderSet_; // 在新的 folder 中添加 this 指针 addToFolders(); return *this;}void Message::swap(Message &amp;rhs) { using std::swap; // 当成员没有定义 swap时，调用 std::swap // 将 this 和 rhs 从原来的文件夹中移除 removeFromFolders(); rhs.removeFromFolders(); swap(contents_, rhs.contents_); swap(pFolderSet_, rhs.pFolderSet_); // 将 this 和 rhs 添加到新的文件夹中 addToFolders(); rhs.addToFolders();}void Message::save(Folder &amp;folder) { pFolderSet_.insert(&amp;folder); folder.addMsg(*this);}void Message::remove(Folder &amp;folder) { pFolderSet_.erase(&amp;folder); folder.removeMsg(*this);}void Message::addToFolders() { for (Folder *pFolder : pFolderSet_) { pFolder-&gt;addMsg(*this); }}void Message::removeFromFolders() { for (Folder *pFolder : pFolderSet_) { pFolder-&gt;removeMsg(*this); }}// Message 单方面添加 Foldervoid Message::addFolder(Folder &amp;folder) { pFolderSet_.insert(&amp;folder);}// Message 单方面移除 Foldervoid Message::removeFolder(Folder &amp;folder) { pFolderSet_.erase(&amp;folder);}void Message::printDebug() { std::cout &lt;&lt; contents_ &lt;&lt; std::endl;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Folder.cpp#include &quot;Folder.h&quot;#include &quot;Message.h&quot;#include &lt;iostream&gt;// copy op=Folder &amp;Folder::operator=(Folder const &amp;rhs) { // 旧的消息中移除 this 文件夹 removeFromMessages(); // 拷贝文件夹名和消息指针列表 name_ = rhs.name_; pMsgSet_ = rhs.pMsgSet_; // 新的消息中添加 this 文件夹 addToMessages();}// swapvoid Folder::swap(Folder &amp;rhs) { using std::swap; // 从旧的 Message 中移除 this, rhs removeFromMessages(); rhs.removeFromMessages(); swap(name_, rhs.name_); swap(pMsgSet_, rhs.pMsgSet_); // 新的 Message 中添加 this, rhs addToMessages(); rhs.addToMessages();}// 所有的 Message 单方面添加 thisvoid Folder::addToMessages() { for (auto pMsg : pMsgSet_) { pMsg-&gt;addFolder(*this); }}// 所有的 Message 完全移除 thisvoid Folder::removeFromMessages() { for (auto pMsg : pMsgSet_) { pMsg-&gt;removeFolder(*this); }}void Folder::addMsg(Message &amp;Msg) { pMsgSet_.insert(&amp;Msg);}// this 单方面移除 Msgvoid Folder::removeMsg(Message &amp;Msg) { pMsgSet_.erase(&amp;Msg);}void Folder::printDebug() { std::cout &lt;&lt; &quot;目录名: &quot; &lt;&lt; name_ &lt;&lt; &quot;\\n&quot;; for (auto pMsg : pMsgSet_) { pMsg-&gt;printDebug(); }} 3 测试1234567891011121314151617181920212223242526// MessageFolderDemo.cpp#include &quot;Message.h&quot;#include &quot;Folder.h&quot;#include &lt;iostream&gt;int main() { Folder f1(&quot;目录1&quot;), f2(&quot;目录2&quot;); Message m1(&quot;m1&quot;), m2(&quot;m2&quot;), m3(&quot;m3&quot;); m1.save(f1); m1.save(f2); m2.save(f1); m2.save(f2); m3.save(f1); f1.printDebug(); f2.printDebug(); std::cout &lt;&lt; &quot;移除部分消息\\n&quot;; m2.remove(f2); m3.remove(f1); f1.printDebug(); f2.printDebug(); return 0;} 1234567891011121314// 输出目录名: 目录1m3m2m1目录名: 目录2m2m1移除部分消息目录名: 目录1m2m1目录名: 目录2m1","link":"/2021/08/04/CppPrimer5th/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E7%A4%BA%E4%BE%8B(Message%E3%80%81Folder)/"},{"title":"Linux C 系统开发 I&#x2F;O 篇","text":"I/O (input &amp; output)I/O 是一切实现的基础。它分为 stdio (标准IO) 和 sysio (文件IO、系统调用IO)。优先使用 stdio。sysio 取决于操作系统内核，windows 和 linux 提供的文件 io 是不一致的。而 stdio 是 c 中提供的，stdio 依赖于底层的 sysio。windosw 和 linux 是兼容的，例如 fopen linux 环境中依赖于 open，windows 环境下依赖于 openfile。 stdioman 手册第三章 类型FILE 函数stream open &amp; close functions12345678910111213#include &lt;stdio.h&gt;FILE *fopen(const char *pathname, const char *mode);FILE *fdopen(int fd, const char *mode);FILE *freopen(const char *pathname, const char *mode, FILE *stream);Feature Test Macro Requirements for glibc (see feature_test_macros(7)):fdopen(): _POSIX_C_SOURCEint fclose(FILE *stream); fopen 中的 mode 如果使用 r、r+, 则指定的文件必须存在。同时 linux 没有二进制流和文本流的区别。 fopen 返回的 FILE 指针指向的内存在堆上，通过 fclose 释放堆空间。 1234567891011121314151617181920212223#include &lt;stdio.h&gt; // perror#include &lt;stdlib.h&gt;#include &lt;errno.h&gt; // errno#include &lt;string.h&gt; // strerrorint main() { FILE *fp; fp = fopen(&quot;tmp&quot;, &quot;r&quot;); if (fp == NULL) { // fprintf(stderr, &quot;fopen() failed! errno = %d\\n&quot;, errno); // perror(&quot;fopen()&quot;); fprintf(stderr, &quot;fopen(): %s\\n&quot;, strerror(errno)); exit(1); } puts(&quot;OK&quot;); fclose(fp); exit(0);} 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main() { FILE *fp = NULL; int count = 0; while (1) { fp = fopen(&quot;tmp&quot;, &quot;w&quot;); if (fp == NULL) { perror(&quot;fopen(): &quot;); break; } ++count; } fprintf(stdout, &quot;count = %d\\n&quot;, count); exit(0);} 每个进程默认最多能够打开 1024 个文件，默认已经打开了三个文件：stdin, stdout, stderr 12fopen(): : Too many open filescount = 1021 文件权限默认公式：0666 &amp; ~umask，umask 越大，生成的文件权限越小。 input of characters and strings123456789101112#include &lt;stdio.h&gt;int fgetc(FILE *stream);int getc(FILE *stream);int getchar(void);int ungetc(int c, FILE *stream);// 缺点：只能读取指定大小的内容。char *fgets(char *s, int size, FILE *stream); fgetc 读取失败返回 EOF，fgets 读取失败返回 NULL。 fgets - 读取 `size - 1` 个字符，例如 `abcde`，size 为 5, s 为 `abcd\\0` - 读取到 `\\n`，例如 `abc`, size 为 5, s 为 `abc\\n\\0` output of characters and strings123456789int fputc(int c, FILE *stream);int putc(int c, FILE *stream);int putchar(int c);int fputs(const char *s, FILE *stream);int puts(const char *s); binary stream input/output12345#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 1234// afread(buffer, 1, 10, fp);// bfread(buffer, 10, 1, fp); fp 指向的数据量不小于10个字节 - a 返回 10， 读取到 10 个字节. - b 返回 1，读取到 10 个字节. fp 指向的数据量只有 10 个字节. - a: 返回 5, 读取到 5 个字节. - b：返回 0, 这时不知道自己读取了几个字节. 建议 fread 以及 fwrite 中的 size 设定为 1, 即块大小永远设定为 1. formatted output conversion123456789101112#include &lt;stdio.h&gt;// 标准输出int printf(const char *format, ...);// 文件输出int fprintf(FILE *stream, const char *format, ...);// 文件描述符int dprintf(int fd, const char *format, ...);// 字符串int sprintf(char *str, const char *format, ...);// 指定大小的字符串, 防止数组越界int snprintf(char *str, size_t size, const char *format, ...); formatted input conversion缺点：读取字符串时，不知道目标字符串的大小。 12345#include &lt;stdio.h&gt;int scanf(const char *format, ...);int fscanf(FILE *stream, const char *format, ...);int sscanf(const char *str, const char *format, ...); reposition a streamfseek 以及 ftell 缺点：参数类型以及返回类型为 long，32 位平台下，只能支持 2GB 左右大小的文件。 1234567#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence);long ftell(FILE *stream);void rewind(FILE *stream); fflush() 问题man fopen 显示 no manual entry123// 安装标准 c 的帮助文档sudo apt-get install libc-devsudo apt-get install glibc-doc 执行文件时，需要加 ./执行文件时不会在当前目录查找。","link":"/2021/05/28/LinuxC/linux-c-io/"},{"title":"第13章：拷贝控制","text":"任何类（Class0、struct）都需要定义拷贝控制操作，程序员没有定义的拷贝控制操作，编译器会自动合成（定义）缺失的拷贝控制操作。 拷贝控制操作主要分为三类： 同类型的另一个对象来完成某对象的初始化：拷贝构造函数(copy ctor)以及移动构造函数(move ctor) 用同类型的另一个对象来给某对象赋值：拷贝赋值运算符(copy op=)以及移动赋值运算符(move op=) 此类型的对象销毁时：析构函数(dtor) 1. 为什么copy ctor的参数必须是引用。通常是T const &amp;。如果copy ctor的参数不是引用，而是一个值类型，当第一次调用copy ctor时，我们需要将对象作为实参再次调用copy ctor来传递给拷贝构造函数，这会导致copy ctor的循环调用。 2. 为什么copy ctor不应该被声明为explicit。123explicit Foo(Foo const &amp;rhs) = default; // 合成的 copy ctorFoo b(a); // 正确Foo c = a; // error: no matching function for call to 'Foo::Foo(Foo&amp;)' 当我们使用explicit声明一个拷贝构造函数时，我们无法使用copy init(拷贝初始化)来初始化一个对象。只能使用direct init(直接初始化)。 3. synthesized copy ctor的拷贝流程synthesized copy ctor会拷贝所有的非static数据成员，根据成员类型的不同，采用不同的拷贝方法。 内置类型成员：直接拷贝(int a = b) 类类型成员：调用成员的copy ctor进行拷贝 内置数组类型成员：因为内置数组不能直接拷贝，所以会对数组进行逐元素拷贝。 4. copy op=能够声明为全局函数(global function)吗copy op= 必须是一个nonstatic member function。 例如下面就会报错 12// compile error: 'Foo&amp; operator=(Foo&amp;, const Foo&amp;)' must be a nonstatic member functionfriend Foo &amp;operator=(Foo &amp;lhs, Foo const &amp;rhs); 5. 析构函数的作用是什么？析构函数体为空，那该类型对象的成员还会销毁吗？ 析构函数并不会直接销毁对象的成员变量，它负责执行程序员编写的对象销毁时的附加代码（例如释放分配的动态内存，或者减小引用计数）。 销毁成员变量其实是由析构函数之后执行的析构阶段负责。 一个类对象从创建到销毁的流程： 构造阶段（初始值列表initialization list）：成员变量的初始化阶段，如果没有使用initialization list，会进行default initialization。 执行构造函数体 … 执行析构函数体 析构阶段：按成员初始化的逆序逐一销毁成员。 6. =default 与 delete 的用法有什么区别。 =default只能用于定义类的拷贝控制函数，既可以在类内定义，也可以在类外定义（类内声明），与普通函数一样。 =delete可以定义所有的成员函数（主要是拷贝控制函数），用来阻止该成员函数的使用，只能在类内定义。 =delete只能在类内定义的理解：=default函数只会影响这个函数的代码，编译时只需要知道函数声明即可，而=delete函数编译时需要告知编译器阻止对它的调用。 7. 编译器生成的拷贝控制函数什么时候是=delete因为类的拷贝控制操作依赖于成员的拷贝控制操作，所以当某类的数据成员中不能完成拷贝控制操作，该类对应的拷贝控制操作会被定义为=delete。 8. 析构函数被定义为=delete 不能定义该类的变量。 不能创建该类的临时对象。 变量与对象的区别：C++中，大部分情况下变量与对象等价，唯一的区别在于变量一定有变量名，而对象没有名字的概念。 9. copy ctor、copy op=以及dtor的关系 需要自定义dtor时，同时也需要自定义copy ctor以及copy op= copy ctor与copy op=是等价的（要么都自定义，要么都不自定义） 因此考虑某个类的拷贝控制操作时，优先考虑析构函数。 10. private代替=deleteC++11标准之前，通过将某个类的成员函数声明为private的，同时不给出定义来阻止对该函数的调用。 其它成员函数以及友元函数调用该函数，会发生链接时错误。 非成员函数以及友元函数调用该函数，会发生编译时错误。 11. 行为像值的类与行为像指针的类 行为像值的类：拷贝某对象时，副本和原对象互相独立。 行为像指针的类：拷贝某对象时，副本和原对象之间共享状态，一个对象的操作会影响到另一个操作。 行为像值的HasPtr \"行为像值的HasPtr\" >folded1234567891011121314151617181920212223242526272829303132333435363738// HasPtr1.hclass HasPtr {public: // 构造函数 HasPtr(std::string s = std::string()) : ps_(new std::string(s)) {} // 拷贝构造函数 HasPtr(HasPtr const &amp;rhs) : ps_(new std::string(*rhs.ps_)), i_(rhs.i_) {} // 拷贝赋值运算符 HasPtr &amp;operator=(HasPtr const &amp;rhs); // 析构函数 ~HasPtr() { delete ps_; } // --------------- Debug --------------- void pushBack(char ch) { ps_-&gt;push_back(ch); } std::string strData() const{ return *ps_; }private: int i_; std::string *ps_;};inline HasPtr &amp;HasPtr::operator=(HasPtr const &amp;rhs) { auto newPs = new std::string(*rhs.ps_); // 拷贝 rhs 管理的动态内存 delete ps_; // 释放旧内存 // 拷贝 rhs 的数据 ps_ = newPs; i_ = rhs.i_; return *this; // 返回本对象} 行为像指针的HasPtr \"行为像指针的HasPtr\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// HasPtr2.hclass HasPtr {public: // 构造函数，引用计数初始化为 1 HasPtr(std::string s = std::string()) : ps_(new std::string(s)), i_(0), use_(new std::size_t(1)) {} // 拷贝构造函数 HasPtr(HasPtr const &amp;rhs) : ps_(rhs.ps_), i_(rhs.i_), use_(rhs.use_) { ++*use_; } // 拷贝赋值运算符 HasPtr &amp;operator=(HasPtr const &amp;rhs); // 析构函数 ~HasPtr() { if (--*use_ == 0) { delete ps_; delete use_; } } // --------------- Debug --------------- void pushBack(char ch) { ps_-&gt;push_back(ch); } std::string strData() const{ return *ps_; }private: std::string *ps_; int i_; std::size_t *use_; // 引用计数};inline HasPtr &amp;HasPtr::operator=(HasPtr const &amp;rhs) { // 先增加 rhs 的引用计数处理自我赋值的情况 ++*rhs.use_; if (--*use_ == 0) { delete ps_; delete use_; } i_ = rhs.i_; ps_ = rhs.ps_; use_ = rhs.use_; return *this;} \"Demo\" >folded1234567891011121314// Demo.cppint main() { HasPtr hp1(&quot;hp&quot;), hp2(hp1), hp3; // 拷贝构造 hp3 = hp2; // 拷贝赋值运算符 // 自我赋值 hp3 = hp3; hp1.pushBack('1'); hp2.pushBack('2'); hp3.pushBack('3'); std::cout &lt;&lt; hp1.strData() &lt;&lt; &quot; &quot; &lt;&lt; hp2.strData() &lt;&lt; &quot; &quot; &lt;&lt; hp3.strData() &lt;&lt; std::endl; return 0;} \"输出\" >folded123// 输出行为像值的HasPtr: hp1 hp2 hp3行为像指针的HasPtr: hp123 hp123 hp123 12. swap函数 对于那些需要重排元素顺序的标准库算法，它们通常需要调用swap函数来交换两个元素。如果类没有定义自己的swap函数，算法默认使用std::swap。 std::swap需要进行1次拷贝构造以及2次拷贝赋值运算，实现类似于： 123Foo tmp = lhs;lhs = rhs;rhs = tmp; 对于某些特定的类，std::swap多了一些不必要的内存分配，例如HasPtr。我们可以自定义swap函数来优化性能。 swap函数可以是成员函数，也可以是全局函数。 HasPtr 自定义 swap HasPtr可以通过交换指针来完成堆内存的交换操作。 这里的例子中swap是一个全局函数。 12345678910111213// HasPtr1.hclass HasPtr { friend void swap(HasPtr &amp;, HasPtr &amp;); // ...};void swap(Hasptr &amp;lhs, HasPtr &amp;rhs) { // 对于存在自定义swap的成员使用它们自定义的swap // 没有自定义swap的成员使用std::swap using std::swap; swap(lhs.i_); swap(lsh.ps_);} 123456// Demovoid test2() { HasPtr hp1(&quot;hp1&quot;), hp2(&quot;hp2&quot;); swap(hp1, hp2); std::cout &lt;&lt; hp1.strData() &lt;&lt; &quot; &quot; &lt;&lt; hp2.strData() &lt;&lt; std::endl;} 12// 输出hp2 hp1 13. copy and swap idiom 两个优点： 对于自定义了swap函数的类，可以通过copy and swap的技术实现copy op=，它天生就是异常安全的，同时能够正确处理自我赋值。 比起之前编写的版本，使用copy and swap实现copy op=的代码更加简洁。 HasPtr通过copy and swap技术实现copy op= 1234567// 声明HasPtr &amp;operator=(HasPtr rhs);// 定义inline HasPtr &amp;HasPtr::operator=(HasPtr rhs) { swap(*this, rhs); return *this; // 返回本对象} 注意点： 函数体不需要使用using std::swap，因为std::swap函数内会调用copy op=。 14. 头文件循环依赖 当头文件出现循环依赖时，很容易出现编译错误。如下：A.h中include B.h，而B.h中又include A.h，会发生编译时错误：error: 'A' does not name a type 如果某个类A中只需要使用B的不完整类型（指针），则可以借助前置声明取代include &quot;B.h&quot; 如果函数体中需要借助指针调用B的成员函数，则通过分离式编译将函数的定义在实现文件里定义。 \"A.h\" >folded123456789101112// A.h#ifndef CPP_PRIMER5_A_H#define CPP_PRIMER5_A_H#include &quot;B.h&quot;class A {private: B b_;};#endif //CPP_PRIMER5_A_H \"B.h\" >folded123456789101112// B.h#ifndef CPP_PRIMER5_B_H#define CPP_PRIMER5_B_H#include &quot;A.h&quot;class B {private: A a_;};#endif //CPP_PRIMER5_B_H \"Demo\" >folded12345678910111213141516171819202122232425262728// ABDemo.cpp#include &quot;A.h&quot;#include &quot;B.h&quot;int main() { A a; B b; return 0;}```c++// ABDemo.cpp 预处理后的代码class B {private: A a_; // 报错：A无法识别成一个类型};class A {private: B b_;};int main() { A a; B b; return 0;} 为什么引入移动语义 某些场景下移动对象比起拷贝对象能够提升性能 某些对象禁止拷贝","link":"/2021/07/27/CppPrimer5th/ch13/"},{"title":"Windows terminal ssh 免密登录 Linux","text":"1. 修改设置- 打开 windows terminal 的 配置文件(json)- 找到 profiles 属性- powershell中通过 new_guid 生成新的 guid- 添加代码123456{ &quot;guid&quot;: &quot;{3a4f3a4b-f4bc-46c6-9b65-94a3a223f3f9}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;UbuntuDesktop&quot;, &quot;commandline&quot;: &quot;ssh cmtang@192.168.29.128&quot;} 2. Linux 存储 windows 公钥- sudo apt install openssh-server- windows 生成 ssh 密钥，C:\\Users\\Chengming\\.ssh- ~/.ssh/authorized_keys 中添加 windows 公钥 id_rsa.pub","link":"/2021/05/28/others/WindowsTerminal-ssh-linux/"},{"title":"【LeetCode】二分查找","text":"二分查找：每次通过比较当前查找区间的中点将当前查找区间分成大小几乎相等的两部分，下次的查找区间只取其中的一部分，减小查询时间。对于一个长度为$n$的数组，它的时间复杂度只有$O(log n)$ 二分查找的本质：二段性。一段满足一个性质，另一段不满足这个性质。通过对nums[mid]进行某种条件判断，缩小一半的查找区间。 参考资料二分查找有几种写法？它们的区别是什么？ - Jason Li的回答 - 知乎二分查找有几种写法？它们的区别是什么？ - LightGHLi的回答 - 知乎二分查找有几种写法？它们的区别是什么？ - 胖君的回答 - 知乎【宫水三叶】详解为何元素相同会导致 O(n)，一起看清二分的本质 1 基础题简单考察二分查找的一般形式。 704. Binary Search(Easy)\"c++\" >folded123456789101112131415161718192021222324class Solution {public: int lowerBound(vector&lt;int&gt; const &amp;nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &lt; target) { first = mid + 1; } else { last = mid; } } return last; } int search(vector&lt;int&gt;&amp; nums, int target) { int ans = lowerBound(nums, target); int n = static_cast&lt;int&gt;(nums.size()); if (ans == n || nums[ans] &gt; target) { return -1; } return ans; }}; \"python\" >folded12345678910111213141516class Solution: def search(self, nums: List[int], target: int) -&gt; int: ans = self.lower_bound(nums, target) if ans == len(nums) or nums[ans] != target: return -1 return ans def lower_bound(self, nums: list[int], target: int) -&gt; int: first, last = 0, len(nums) while first &lt; last: mid = first + (last - first) // 2 if nums[mid] &lt; target: first = mid + 1 else: last = mid return first 剑指 Offer 53 - I. 在排序数组中查找数字 I(Easy)\"c++\" >folded123456789101112131415161718192021222324252627282930313233343536class Solution {public: int lowerBound(vector&lt;int&gt; const &amp;nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &lt; target) { first = mid + 1; } else { last = mid; } } return first; } int upperBound(vector&lt;int&gt; const &amp;nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &gt; target) { last = mid; } else { first = mid + 1; } } return first; } int search(vector&lt;int&gt;&amp; nums, int target) { int upper = upperBound(nums, target); int lower = lowerBound(nums, target); return upper - lower; }}; \"python\" >folded123456789101112131415161718192021222324class Solution: def search(self, nums: List[int], target: int) -&gt; int: lower, upper = self.lower_bound(nums, target), self.upper_bound(nums, target) return upper - lower def lower_bound(self, nums: list[int], target: int) -&gt; int: first, last = 0, len(nums) while first &lt; last: mid = first + (last - first) // 2 if nums[mid] &lt; target: first = mid + 1 else: last = mid return first def upper_bound(self, nums: list[int], target: int) -&gt; int: first, last = 0, len(nums) while first &lt; last: mid = first + (last - first) // 2 if nums[mid] &gt; target: last = mid else: first = mid + 1 return first 34. Find First and Last Position of Element in Sorted Array(Medium)\"c++\" >folded123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int lower = lowerBound(nums, target); int upper = upperBound(nums, target); if (upper - lower == 0) { return {-1, -1}; } return {lower, upper - 1}; } int lowerBound(vector&lt;int&gt; const &amp;nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &lt; target) { first = mid + 1; } else { last = mid; } } return first; } int upperBound(vector&lt;int&gt; const &amp;nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &gt; target) { last = mid; } else { first = mid + 1; } } return first; }}; \"python\" >folded1234567891011121314151617181920212223242526class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: lower, upper = self.lower_bound(nums, target), self.upper_bound(nums, target) if upper - lower == 0: return [-1, -1] return [lower, upper - 1] def lower_bound(self, nums: list[int], target: int) -&gt; int: first, last = 0, len(nums) while first &lt; last: mid = first + (last - first) // 2 if nums[mid] &lt; target: first = mid + 1 else: last = mid return first def upper_bound(self, nums: list[int], target: int) -&gt; int: first, last = 0, len(nums) while first &lt; last: mid = first + (last - first) // 2 if nums[mid] &gt; target: last = mid else: first = mid + 1 return first 35. Search Insert Position(Easy)插入位置与lower_bound是等价的。 时间复杂度：$O(logN)$。 空间复杂度：$O(1)$。 \"c++\" >folded1234567891011121314151617181920class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { return lowerBound(nums, target); } int lowerBound(vector&lt;int&gt; const &amp;nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &lt; target) { first = mid + 1; } else { last = mid; } } return first; }}; 278. First Bad Version(Easy)注意$n$的可能取到$2 ^ 31 - 1$，因此这里last不能取n + 1，否则会发生溢出。 时间复杂度：$O(logN)$。 空间复杂度：$O(1)$。 \"c++\" >folded1234567891011121314151617181920// The API isBadVersion is defined for you.// bool isBadVersion(int version);class Solution {public: int firstBadVersion(int n) { int first = 1, last = n; // 好版本: [1, first) // 坏版本: (last, n] while (first &lt;= last) { int mid = first + (last - first) / 2; if (isBadVersion(mid)) { last = mid - 1; } else { first = mid + 1; } } return first; }}; 2 变形题学会抓住二分查找的本质，即查找区间能根据某个条件分成两段。 29. Divide Two Integers(Medium)$a / b, a \\geq 0, b &gt; 0$的结果一定位于$[0, a]$。因此我们可以对$[0, a]$进行二分。 判断最终结果的符号，将$dividend$以及$divisor$转变为非负数。 对$[0, a]$进行二分查找，当中点mid与$b$的乘积超过$a$，缩小区间到左半部分；乘积小于$a$，缩小区间到右半部分。 因为题目要求不允许出现乘法运算，可以通过位运算以及加法运算代替乘法运算。 严格的说，题目要求不允许出现超过int表示范围的数，这里还是采用了long long类型的变量存储中间结果。 时间复杂度：$O(log a)$。 空间复杂度：$O(1)$。 \"c++\" >folded1234567891011121314151617181920212223242526272829303132class Solution {public: int divide(int dividend, int divisor) { bool negative = (dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0); long long a = abs(dividend), b = abs(divisor); long long first = 0, last = a + 1; while (first &lt; last) { long long mid = first + (last - first &gt;&gt; 1); long long x = mul(b, mid); if (x &gt; a) { last = mid; } else { first = mid + 1; } } long long quotient = negative ? -(first - 1) : first - 1; return quotient &gt; numeric_limits&lt;int&gt;::max() ? numeric_limits&lt;int&gt;::max() : quotient; } long long mul(long long a, long long b) { long long ans = 0; while (b) { if (b &amp; 0x1) { ans += a; } a += a; b &gt;&gt;= 1; } return ans; }}; 33. Search in Rotated Sorted Array(Medium) 确定左右区间的划分。 比较target与nums[0], 判断需要对哪个区间进行二分查找。 线性查找确定左右区间 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"c++\" >folded12345678910111213141516171819202122232425262728293031323334class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); int pivot = n; for (int i = 1; i &lt; n; ++i) { if (nums[i] &lt; nums[i - 1]) { pivot = i; } } int first = 0, last = n; if (target == nums[0]) { return 0; } else if (target &lt; nums[0]) { first = pivot; } else { last = pivot; } while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { first = mid + 1; } else { last = mid; } } return -1; }}; \"python\" >folded123456789101112131415161718192021222324252627class Solution: def search(self, nums: List[int], target: int) -&gt; int: n = len(nums) pivot = n for i in range(1, n): if nums[i] &lt; nums[i - 1]: pivot = i break first, last = 0, n if target == nums[0]: return 0 elif target &lt; nums[0]: first = pivot else: last = pivot while first &lt; last: mid = first + (last - first) // 2 if target == nums[mid]: return mid elif nums[mid] &lt; target: first = mid + 1 else: last = mid return -1 二分查找 题目要求$O(logN)$的时间复杂度，如果采用线性查找的方式确定左右区间，最终的时间复杂度为$O(N)$，不符合要求。而左右区间其实能够利用二分查找去划分，因为左区间的所有值都大于等于nums[0]，右区间的所有值都小于nums[0]。利用二分查找划分左右区间，最终的时间复杂度可以降为$O(logN)$。 时间复杂度：$O(logN)$。 额外空间复杂度：$O(1)$。 \"c++\" >folded123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); // 找到旋转数组的断点 int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &lt; nums[0]) { last = mid; } else { first = mid + 1; } } // 判断 target 在左区间还是右区间, 分区间二分查找 if (target == nums[0]) { return 0; } else if (target &gt; nums[0]) { first = 0; } else { last = n; } while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { first = mid + 1; } else { last = mid; } } return -1; }}; \"python\" >folded123456789101112131415161718192021222324252627class Solution: def search(self, nums: List[int], target: int) -&gt; int: n = len(nums) first, last = 0, n # 划分左右区间 while first &lt; last: mid = first + (last - first) // 2 if nums[mid] &lt; nums[0]: last = mid else: first = mid + 1 # 比较 target 与 nums[0] if target &lt; nums[0]: last = n else: first = 0 while first &lt; last: mid = first + (last - first) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: first = mid + 1 else: last = mid return -1 81. Search in Rotated Sorted Array II(Medium) 线性查找 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"c++\" >folded1234567891011class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { for (auto num : nums) { if (num == target) { return true; } } return false; }}; 线性查找旋转点+二分查找 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"c++\" >folded12345678910111213141516171819202122232425262728293031323334class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); // 寻找数组旋转之前的首元素 int pivot = n; for (int i = 1; i &lt; n; ++i) { if (nums[i] &lt; nums[i - 1]) { pivot = i; break; } } int first = 0, last = n; // 比较 target 与 nums[0] 选择区间进行二分查找 if (target &lt; nums[0]) { first = pivot; } else { last = pivot; } while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] == target) { return true; } else if (nums[mid] &lt; target) { first = mid + 1; } else { last = mid; } } return false; }}; 二分查找 如果我们想通过二分查找的方式来找数组旋转前的首元素，就需要保证旋转数组是二分的。因为数组中存在重复元素，当左右区间存在相同元素时，不能二分(nums[mid]==nums[0]无法判断mid的位置)，因此我们要保证左右区间没有相同的元素。 时间复杂度：$O(N)$。在极端情况下1, 1, 1, ..., 1，去除左右区间相同元素的操作时间复杂度是$O(N)$的。 空间复杂度：$O(1)$。 \"c++\" >folded1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { int n = static_cast&lt;int&gt;(nums.size()); // 寻找数组旋转之前的首元素 while (n &gt; 1 &amp;&amp; nums[0] == nums[n - 1]) { --n; } int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &lt; nums[0]) { last = mid; } else { first = mid + 1; } } // 比较 target 与 nums[0] 选择区间进行二分查找 if (target &lt; nums[0]) { last = n; } else { first = 0; } while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] == target) { return true; } else if (nums[mid] &lt; target) { first = mid + 1; } else { last = mid; } } return false; }}; 153. Find Minimum in Rotated Sorted Array(Medium)题目要求$O(logN)$的时间复杂度，因此必须使用二分。同时数组中不存在相同元素，满足二分性。 \"c++\" >folded12345678910111213141516class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int n = static_cast&lt;int&gt;(nums.size()); int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &lt; nums[0]) { last = mid; } else { first = mid + 1; } } return first == n ? nums[0] : nums[first]; }}; \"python\" >folded12345678910class Solution: def findMin(self, nums: List[int]) -&gt; int: first, last = 0, len(nums) while first &lt; last: mid = first + (last - first) // 2 if nums[mid] &lt; nums[0]: last = mid else: first = mid + 1 return nums[first] if first &lt; len(nums) else nums[0] 154. Find Minimum in Rotated Sorted Array II(Hard)题目没有要求$O(logN)$的时间复杂度，最直接的方法就是线性遍历求最小值。同时测试用例的长度不会超过$5000$，$O(N)$的时间复杂度肯定够用。 线性遍历求最小值 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"c++\" >folded12345678910class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int min = nums[0]; for (auto num : nums) { min = num &lt; min ? num : min; } return min; }}; 二分查找 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"c++\" >folded12345678910111213141516171819class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int n = static_cast&lt;int&gt;(nums.size()); while (n &gt; 1 &amp;&amp; nums[n - 1] == nums[0]) { --n; } int first = 0, last = n; while (first &lt; last) { int mid = first + (last - first) / 2; if (nums[mid] &lt; nums[0]) { last = mid; } else { first = mid + 1; } } return first == n ? nums[0] : nums[first]; }}; 面试题 10.03. Search Rotate Array LCCI 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"c++\" >folded1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int search(vector&lt;int&gt;&amp; arr, int target) { int n = static_cast&lt;int&gt;(arr.size()); while (n &gt; 1 &amp;&amp; arr[n - 1] == arr[0]) { --n; } int first = 0, last = n; while (first &lt; last) { int mid = first + (last - mid) / 2; if (arr[mid] &lt; arr[0]) { last = mid; } else { first = mid + 1; } } if (target &lt; arr[0]) { last = n; } else { first = 0; } int bound = last; while (first &lt; last) { int mid = first + (last - first) / 2; if (arr[mid] &lt; target) { first = mid + 1; } else { last = mid; } } if (first == bound || arr[first] &gt; target) { return -1; } return first; }}; 540. Single Element in a Sorted Array(Medium)题目要求$O(logN)$的时间复杂度，因此选择二分查找。如果题目不是有序的话，一般采取逐元素按位异或的方法。 二分查找 时间复杂度：$O(logN)$。 额外空间复杂度：$O(1)$。 \"c++\" >folded12345678910111213141516171819202122232425262728class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int n = static_cast&lt;int&gt;(nums.size()); int first = 0, last = n; int ans = 0; while (first &lt; last) { int mid = first + (last - first) / 2; if (mid &gt; first &amp;&amp; nums[mid] == nums[mid - 1]) { if (mid - 1 - first &amp; 1) { last = mid - 1; } else { first = mid + 1; } } else if (mid &lt; last - 1 &amp;&amp; nums[mid] == nums[mid + 1]) { if (mid - first &amp; 1) { last = mid; } else { first = mid + 2; } } else { return nums[mid]; } } // 正常情况下，不会执行到这里 return ans; }}; 4. Median of Two Sorted Arrays(Hard) 双指针 要计算归并数组的中位数，最直接的解法应该是先求出归并数组，再利用下标直接访问中位数。然而经过进一步思考，中位数的下标合并前已经知道，而归并数组的过程每次确认的元素是按顺序的，因此在归并的过程中，就可以找到中位数。 时间复杂度：$O(M + N)$。 空间复杂度：$O(1)$。 \"c++\" >folded1234567891011121314151617181920212223242526class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int m = static_cast&lt;int&gt;(nums1.size()); int n = static_cast&lt;int&gt;(nums2.size()); int mid = (m + n) / 2; int p = 0, q = 0, prev = 0, cur = 0; for (int i = 0; i &lt; mid + 1; ++i) { prev = cur; if (p == m) { cur = nums2[q++]; } else if (q == n) { cur = nums1[p++]; } else if (nums2[q] &lt; nums1[p]) { cur = nums2[q++]; } else { cur = nums1[p++]; } } if ((m + n) &amp; 1) { return cur; } return (prev + cur) / 2.0; }}; 搜索第$K$小的元素 时间复杂度：$O(log(M + N))。 空间复杂度：$O(1)$。 \"c++\" >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int m = static_cast&lt;int&gt;(nums1.size()); int n = static_cast&lt;int&gt;(nums2.size()); int k = (m + n) / 2; if ((m + n) &amp; 1) { return findKthElement(nums1, nums2, k + 1); } int left = findKthElement(nums1, nums2, k); int right = findKthElement(nums1, nums2, k + 1); return (left + right) / 2.0; } int findKthElement(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2, int k) { int m = static_cast&lt;int&gt;(nums1.size()); int n = static_cast&lt;int&gt;(nums2.size()); int begin1 = 0, begin2 = 0; while (true) { if (begin1 == m) { return nums2[begin2 + k - 1]; } if (begin2 == n) { return nums1[begin1 + k - 1]; } if (k == 1) { return min(nums1[begin1], nums2[begin2]); } int end1 = begin1 + k / 2 - 1; if (end1 &gt;= m) { end1 = m - 1; } int end2 = begin2 + k / 2 - 1; if (end2 &gt;= n) { end2 = n - 1; } if (nums2[end2] &lt; nums1[end1]) { k -= end2 - begin2 + 1; begin2 = end2 + 1; } else { k -= end1 - begin1 + 1; begin1 = end1 + 1; } } }}; 74. Search a 2D Matrix(Medium)可以将输入的矩阵看作一个一维的有序数组。只需要将一维数组的坐标映射到二维矩阵上即可。 - 时间复杂度：$O(log(M * N))$。 - 空间复杂度：$O(1)$。 \"c++\" >folded123456789101112131415161718192021222324252627class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int m = static_cast&lt;int&gt;(matrix.size()); int n = m ? static_cast&lt;int&gt;(matrix[0].size()) : 0; int ans = lowerBound(matrix, target); if (ans == m * n || matrix[ans / n][ans % n] != target) { return false; } return true; } int lowerBound(vector&lt;vector&lt;int&gt;&gt; const &amp;matrix, int target) { int m = static_cast&lt;int&gt;(matrix.size()); int n = m ? static_cast&lt;int&gt;(matrix[0].size()) : 0; int first = 0, last = m * n; while (first &lt; last) { int mid = first + (last - first) / 2; if (matrix[mid / n][mid % n] &lt; target) { first = mid + 1; } else { last = mid; } } return first; }}; 220. Contains Duplicate III(Medium) 滑动窗口+有序集合 本题属于[217]以及[219]的变形题，区别在于它需要判断目标值是否在区间内，而不是等于特定的值，这一点很容易想到二分查找。解题的整体思路与[219]一致，依然采用滑动窗口的思想遍历数组，但是辅助的数据结构不能再用哈希表，辅助数据结构应该满足以下特点。 - $O(1)$时间内获取对应`key`的`value`。 - $O(1)$时间内删除指定的`key`。 - 结构有序，能够在该结构中利用二分查找快速查询上下界。 c++解题需要处理int的溢出情况。 时间复杂度：$O(NlogK)$。 空间复杂度：$O(K)$。 \"c++\" >folded123456789101112131415161718192021222324252627282930class Solution {public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) { set&lt;int&gt; numSet; int n = static_cast&lt;int&gt;(nums.size()); for (int i = 0; i &lt; n; ++i) { int low = tsub_ok(nums[i], t) ? numeric_limits&lt;int&gt;::min() : nums[i] - t; int high = tadd_ok(nums[i], t) ? numeric_limits&lt;int&gt;::max() : nums[i] + t; auto iter = numSet.lower_bound(low); if (iter != numSet.cend() &amp;&amp; *iter &lt;= high) { return true; } numSet.insert(nums[i]); if (numSet.size() &gt; k) { numSet.erase(nums[i - k]); } } return false; } bool tadd_ok(int x, int y) { long long sum = static_cast&lt;long long&gt;(x) + y; return sum &gt; numeric_limits&lt;int&gt;::max() || sum &lt; numeric_limits&lt;int&gt;::min(); } bool tsub_ok(int x, int y) { long long sub = static_cast&lt;long long&gt;(x) - y; return sub &gt; numeric_limits&lt;int&gt;::max() || sub &lt; numeric_limits&lt;int&gt;::min(); }}; 274. H-Index(Medium) 对于一个大小为n的数组，h指数一定属于$[0, n + 1)$。 我们可以对$[0, n + 1]$进行二分查找。假设它的h指数为$i$，则对于$[0, i]$的任意值$x$，数组都至少存在$i &gt;= x$个元素大于等于$x$。而对于$[i + 1, n + 1)$的任意值$y$，数组都不可能存在$y$个元素大于等于$y$。 时间复杂度：$O(NlogN)$。 空间复杂度：$O(1)$。 \"c++\" >folded123456789101112131415161718192021222324252627282930class Solution {public: int hIndex(vector&lt;int&gt;&amp; citations) { int n = static_cast&lt;int&gt;(citations.size()); // h指数取值落在[0, n + 1) int first = 0, last = n + 1; // [0, first) 表示满足 check 函数 // [last, n + 1) 表示不满足 check 函数 while (first &lt; last) { int mid = first + (last - first) / 2; if (check(citations, mid)) { first = mid + 1; } else { last = mid; } } return first - 1; } // 数组中大于等于 h 的元素是否大于等于 h 个 bool check(vector&lt;int&gt; const &amp;citations, int h) { int cnt = 0; for (auto citation : citations) { if (citation &gt;= h) { ++cnt; } } return cnt &gt;= h; }}; 275. H-Index II(Medium)与274. H-Index区别在于数组已然有序，因此优化check函数的时间复杂度，只需要判断数组的倒数第h个元素是否大于等于h即可。 时间复杂度：$O(logN)$。 空间复杂度：$O(1)$。 \"c++\" >folded12345678910111213141516class Solution {public: int hIndex(vector&lt;int&gt;&amp; citations) { int n = static_cast&lt;int&gt;(citations.size()); int first = 1, last = n + 1; while (first &lt; last) { int mid = first + (last - first) / 2; if (citations[n - mid] &gt;= mid) { first = mid + 1; } else { last = mid; } } return first - 1; }}; 1818. Minimum Absolute Sum Difference(Hard)注意取模运算。 时间复杂度：$O(NlogN)$。 空间复杂度：$O(N)$。 \"c++\" >folded1234567891011121314151617181920212223242526272829303132333435class Solution {public: static constexpr int mod = 1'000'000'007; int minAbsoluteSumDiff(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int sum = 0; int n = static_cast&lt;int&gt;(nums1.size()); vector&lt;int&gt; aux(nums1); sort(aux.begin(), aux.end()); int maxDiff = 0; for (int i = 0; i &lt; n; ++i) { int a = nums1[i], b = nums2[i]; if (a == b) { continue; } sum += (abs(a - b)) % mod; sum %= mod; auto lower = lower_bound(aux.cbegin(), aux.cend(), b); int diff = 0; if (lower != aux.cend()) { diff = abs(a - b) - abs(*lower - b); } if (lower != aux.cbegin()) { diff = max(diff, abs(a - b) - abs(*(lower - 1) - b)); } maxDiff = max(maxDiff, diff); } return (sum - maxDiff % mod + mod) % mod; }}; 3 联想题刷题过程中，看到的有趣的题。 189. Rotate Array(Medium) 模拟 旋转后，下标为$i$的元素移动到$(i + k) % n$的位置上，因此遍历数组将元素移动到新位置上。但是新位置上的元素会被覆盖，因此创建辅助数组保存移动后的元素。最后将辅助数组的元素拷贝到原数组即可。 时间复杂度：$O(N)$。需要遍历数组2遍。 空间复杂度：$O(N)$。\"c++\" >folded1234567891011121314class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int n = static_cast&lt;int&gt;(nums.size()); vector&lt;int&gt; aux(n, 0); for (int i = 0; i &lt; n; ++i) { int j = (i + k) % n; aux[j] = nums[i]; } for (int i = 0; i &lt; n; ++i) { nums[i] = aux[i]; } }}; 翻转数组 仔细观察，数组的旋转可以用数组的翻转代替。 翻转整个数组 翻转前$k$个元素 翻转后$n - k$个元素 时间复杂度：$O(N)$。每个元素访问2次。 额外空间复杂度：$O(1)$。 \"c++\" >folded123456789101112131415161718class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int n = static_cast&lt;int&gt;(nums.size()); k = k % n; reverse(nums, 0, n); reverse(nums, 0, k); reverse(nums, k, n); } void reverse(vector&lt;int&gt; &amp;nums, int first, int last) { while (first &lt; last) { swap(nums[first], nums[last - 1]); ++first; --last; } }}; 217. Contains Duplicate(Easy) 排序 题目没有规定不可以改变数组，因此直接对数组排序，如果存在相同的元素，则它们必然连续出现。 时间复杂度：$O(NlogN)$。 空间复杂度：$O(logN)$。 \"c++\" >folded1234567891011121314class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int n = static_cast&lt;int&gt;(nums.size()); for (int i = 1; i &lt; n; ++i) { if (nums[i] == nums[i - 1]) { return true; } } return false; }}; 哈希表 假如不允许改变数组的原始顺序，我们可以创建一个哈希表，保存已经访问过的元素，当出现相同元素时，说明数组中存在重复元素。 时间复杂度：$O(N)$。 空间复杂度：$O(N)$。 \"c++\" >folded12345678910111213141516class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { int n = static_cast&lt;int&gt;(nums.size()); unordered_set&lt;int&gt; numSet; numSet.reserve(n); for (auto num : nums) { auto iter = numSet.find(num); if (iter != numSet.cend()) { return true; } numSet.insert(num); } return false; }}; 219. Contains Duplicate II(Easy)与上题不同，这里不能通过排序来判断是否存在相同的元素。这题我们可以参考滑动窗口的思想，构建一个大小为k的哈希表，访问下一个元素时判断哈希表中是否存在相同的元素。 为什么这里只需要大小为k的哈希表，例如下标为i的元素，它比较的范围应该为[i - k, i + k]。这里与从数组选取二元数对的思想一致，因为下标对(i, j)与(j, i)实际上执行相同的判断。因此我们只需要进行一个方向的比较即可，这里我们每次比较[i - k, i - 1]。 注意边界情况的处理：k == 0。 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"c++\" >folded12345678910111213141516171819202122class Solution {public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) { if (k == 0) { return false; } unordered_set&lt;int&gt; numSet; numSet.reserve(k); int n = static_cast&lt;int&gt;(nums.size()); for (int i = 0; i &lt; n; ++i) { auto iter = numSet.find(nums[i]); if (iter != numSet.cend()) { return true; } if (numSet.size() == k) { numSet.erase(nums[i - k]); } numSet.insert(nums[i]); } return false; }};","link":"/2021/08/06/LeetCode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"【LeetCode】排序","text":"常见的排序算法 1 简单的排序算法($O(N^2)$)时间复杂度为$O(N^{2})$的排序算法有选择排序, 冒泡排序, 插入排序三种. 选择排序 每趟遍历只有1次交换操作。 时间复杂度：$O(N^{2})$。与冒泡排序以及插入排序不同，时间复杂度不会因为数组的初始顺序降低。 空间复杂度：$O(N)$。 \"选择排序\" >folded123456789101112131415161718class SelectionSort {public: static void selectionSort(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } for (int i = 0; i &lt; nums.size() - 1; ++i) { int minIndex = i; for (int j = i + 1; j &lt; nums.size(); ++j) { if (nums[j] &lt; nums[minIndex]) { minIndex = j; } } using std::swap; swap(nums[i], nums[minIndex]); } }}; 冒泡排序 时间复杂度：$O(N^{2})$。当某趟遍历不需要交换元素时，数组已然有序。因此对有序数组进行冒泡排序时，时间复杂度为$O(N)$。 空间复杂度：$O(1)$。 \"冒泡排序\" >folded12345678910111213141516171819202122class BubbleSort {public: static void bubbleSort(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } // 某一趟遍历的范围为 [0, i) for (int i = nums.size(); i &gt; 1; --i) { bool sorted = true; for (int j = 1; j &lt; i; ++j) { if (nums[j] &lt; nums[j - 1]) { using std::swap; sorted = false; swap(nums[j], nums[j - 1]); } } if (sorted) { return; } } }}; 插入排序 时间复杂度：$O(N^2)$。比较次数与数组的初始顺序有关，当对有序数组排序时，时间复杂度为$O(N)$。 空间复杂度：$O(1)$。 插入排序是一种稳定的排序算法。 可以通过交换或者赋值的方法完成元素的插入。 实现代码\"插入排序\" >folded1234567891011121314151617181920212223242526272829303132class InsertionSort {public: // 通过 swap 插入元素 static void insertionSort(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } for (int i = 1; i &lt; nums.size(); ++i) { using std::swap; for (int j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; nums[j + 1]; --j) { swap(nums[j], nums[j + 1]); } } } // 通过覆盖元素的方式插入元素 static void insertionSort2(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } for (int i = 1; i &lt; nums.size(); ++i) { int guard = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt; guard) { nums[j + 1] = nums[j]; --j; } // nums[i] 需要插入到 j + 1 nums[j + 1] = guard; } }}; 2 $O(NlogN)$的排序算法注意当数据规模小于某个常数规模时，优先考虑用$O(N^2)$的排序算法，而不是$O(NlogN)$的排序算法。 归并排序自顶向下（递归版本） 时间复杂度: $O(NlogN)$。利用Master定理, a = 2, b = 2, d = 1，可知$T(N) = O(Nlog_{2}N)$。 空间复杂度: $O(N)$。空间消耗除了常数大小的变量，包括递归栈以及辅助数组。递归栈的空间复杂度为$O(log_{2}N)$，辅助数组的空间复杂度为$O(N)$。因此总的空间复杂度为$O(N)$。 自底向上（迭代版本） 自底向上的归并排序十分契合用链表组织的数据。因为有序链表之间的合并不需要额外的辅助数组，只需要改变链表中结点的指向。它的空间复杂度为$O(1)$。 时间复杂度：$O(NlogN)$。 空间复杂度：$O(N)$。尽管最终的空间复杂度与自顶向下版本一致，但是它少了递归栈的空间复杂度。 代码实现\"归并排序\" >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MergeSort {public: // 自顶向下的归并排序 static void topDownMergeSort(std::vector&lt;int&gt; &amp;nums) { MergeSort::aux.resize(nums.size()); topDownMergeSort(nums, 0, nums.size()); } // 自底向上的归并排序 static void bottomUpMergeSort(std::vector&lt;int&gt; &amp;nums) { MergeSort::aux.resize(nums.size()); int size = nums.size(); // size表示子数组大小 // 如果数组的长度不超过此时归并子数组的长度 mergeSize, 说明数组已经有序 for (int mergeSize = 1; mergeSize &lt; size ; mergeSize += mergeSize) { // 如果数组剩下的元素数量不超过 mergeSize, 则剩下的元素已经有序，不需要归并 for (int first = 0; size - first &gt; mergeSize; first += mergeSize + mergeSize) { // 因为该轮归并的最后1次归并有可能不足 2 * mergeSize, 因此需要对 last 进行判断 merge(nums, first, first + mergeSize, std::min(size, first + mergeSize + mergeSize)); } } } private: static std::vector&lt;int&gt; aux; static void topDownMergeSort(std::vector&lt;int&gt; &amp;nums, int first, int last) { if (last - first &lt; 2) { return; } int mid = first + (last - first) / 2; topDownMergeSort(nums, first, mid); topDownMergeSort(nums, mid, last); merge(nums, first, mid, last); } static void merge(std::vector&lt;int&gt; &amp;nums, int first, int mid, int last) { int left = first, right = mid; for (int i = first; i &lt; last; ++i) { aux[i] = nums[i]; } for (int i = first; i &lt; last; ++i) { if (left &gt;= mid) { nums[i] = aux[right++]; } else if (right &gt;= last) { nums[i] = aux[left++]; } else if (aux[left] &gt; aux[right]) { nums[i] = aux[right++]; } else { nums[i] = aux[left++]; } } }};std::vector&lt;int&gt; MergeSort::aux; 快速排序 注意点 引入随机化过程。没有引入随机化的过程，快速排序在一些情况下容易退化到$O(N^{2})$（每次分区时左半区或者右半区没有元素）。 在数组存在大量重复元素时，3向分区比起左右分区性能更好，每次分区能确定k个元素（$ k \\geq 1$)。 快排的迭代版本与归并排序的迭代版本不一样，它并不能降低时间复杂度。因为它必须保存所有的分区边界。 用std::stack代替函数调用栈并不一定能减少程序的运行时间。 random_device以及mt19937的初始化过程耗时较多，因此将它们设置为static变量。 时间复杂度：$O(NlogN)$。 空间复杂度：$O(logN)$。额外空间消耗除了常数大小的变量，还包括递归栈。递归栈的空间复杂度为$O(log_{2}N)$，因此最终的空间复杂度为$O(logN)$。迭代版本的空间复杂度与递归版本一致，因为它必须要保存上次分区得到的边界。 代码实现\"快速排序\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118class QuickSort {public: // 左右分区快速排序递归版本 static void quickSort(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } quickSort(nums, 0, nums.size()); } // 3分区快速排序递归版本 static void quickSort3Way(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } quickSort3Way(nums, 0, nums.size()); } // 3分区快速排序迭代版本 static void quickSort3Way2(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } std::stack&lt;std::pair&lt;int, int&gt;&gt; s; s.push({0, nums.size()}); while (!s.empty()) { auto range = s.top(); s.pop(); auto p = partition3Way(nums, range.first, range.second); // 左半边的长度大于1才需要继续分区 if (p.first - range.first &gt; 1) { s.push({range.first, p.first}); } // 右半边的长度大于1才需要继续分区 if (range.second - p.second &gt; 1) { s.push({p.second, range.second}); } } }private: static std::random_device randomDevice; static std::mt19937 randomEngine; static void quickSort(std::vector&lt;int&gt; &amp;nums, int first, int last) { if (last - first &lt; 2) { return; } int pivotIndex = partition(nums, first, last); quickSort(nums, first, pivotIndex); quickSort(nums, pivotIndex + 1, last); } static void quickSort3Way(std::vector&lt;int&gt; &amp;nums, int first, int last) { if (last - first &lt; 2) { return; } auto p = partition3Way(nums, first, last); quickSort3Way(nums, first, p.first); quickSort3Way(nums, p.second, last); } // 单向扫描, 左右切分 // [first, pivotIndex)里的元素 &lt; pivot // (pivotIndex, last) 里的元素 &gt;= pivot // nums[pivotIndex] == pivot static int partition(std::vector&lt;int&gt; &amp;nums, int first, int last) { // 引入随机化过程, 防止算法退化 using std::swap; std::uniform_int_distribution&lt;unsigned long long&gt; intDistribution(first, last - 1); swap(nums[last - 1], nums[intDistribution(randomEngine)]); int pivot = nums[last - 1]; int pivotIndex = first; for (int i = first; i &lt; last; ++i) { if (nums[i] &lt; pivot) { swap(nums[i], nums[pivotIndex++]); } } swap(nums[last - 1], nums[pivotIndex]); return pivotIndex; } // 单向扫描，3向切分 // [first, left) 里的元素 &lt; pivot // [left, right) 里的元素 == pivot // [right, last) 里的元素 &gt; pivot // nums[pivotIndex] == pivot static std::pair&lt;int, int&gt; partition3Way(std::vector&lt;int&gt; &amp;nums, int first, int last) { // 引入随机化过程, 防止算法退化 std::uniform_int_distribution&lt;unsigned long long&gt; intDistribution(first, last - 1); int pivot = nums[intDistribution(randomEngine)]; int left = first, right = last; // 查找区间为 [i, right) for (int i = first; i &lt; right;) { using std::swap; // 小于 pivot if (nums[i] &lt; pivot) { swap(nums[i++], nums[left++]); // 大于 pivot } else if (nums[i] &gt; pivot) { swap(nums[i], nums[--right]); // 等于 pivot } else { ++i; } } return {left, right}; }};std::random_device QuickSort::randomDevice;std::mt19937 QuickSort::randomEngine(randomDevice()); 堆排序 堆 逻辑结构：完全二叉树 存储结构：数组 大根堆：每一颗子树的最大值为根的值。 小根堆：每一颗子树的最小值为根的值。 siftUp：对某个元素进行上移调整，使之成为一个堆。时间复杂度为$O(logN)$。 siftDown: 对某个元素进行下移调整，使之成为一个堆。时间复杂度为$O(logN)$。 时间复杂度：$O(NlogN)$。堆排序分为两步，第一步将数组的逻辑结构转变为堆，它的时间复杂度取决于具体实现，如果从末尾开始进行调整，时间复杂度为$O(N)$，而从头开始调整，它的时间复杂度为$O(NlogN)$。第二步从堆移除根结点，它的时间复杂度为$O(NlogN)$。因此总的时间复杂度为$O(NlogN)$。 空间复杂度：$O(1)$。额外的空间消耗只有常数大小的变量，因为堆的存储结构就是数组。 代码实现 \"堆排序\" >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class HeapSort {public: static void heapSort(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } int heapSize = nums.size(); // 从零开始堆化, 将 nums 的逻辑结构转变为大根堆 // O(NlogN) for (int i = 0; i &lt; nums.size(); ++i) { siftUp(nums, i); } // 将大根堆的根结点与最后一个结点交换 // O(NlogN) while (heapSize &gt; 0) { using std::swap; swap(nums[0], nums[--heapSize]); // 将 nums 的逻辑结构转变为大根堆 siftDown(nums, heapSize, 0); } } static void heapSort2(std::vector&lt;int&gt; &amp;nums) { if (nums.size() &lt; 2) { return; } int heapSize = nums.size(); // 从末尾开始堆化, 将 nums 的逻辑结构转变为大根堆 // O(N) for (int i = nums.size() - 1; i &gt;= 0; --i) { siftDown(nums, heapSize, i); } // 将大根堆的根结点与最后一个结点交换 // O(NlogN) while (heapSize &gt; 0) { using std::swap; swap(nums[0], nums[--heapSize]); // 将 nums 的逻辑结构转变为大根堆 siftDown(nums, heapSize, 0); } }private: static void siftUp(std::vector&lt;int&gt; &amp;nums, int index) { int parentIndex = (index - 1) / 2; while (nums[index] &gt; nums[parentIndex]) { using std::swap; swap(nums[index], nums[parentIndex]); index = parentIndex; parentIndex = (index - 1) / 2; } } static void siftDown(std::vector&lt;int&gt; &amp;nums, int heapSize, int index) { int leftChildIndex = 2 * index + 1; // 如果 index 存在子结点, 判断是否需要向下移动 while (leftChildIndex &lt; heapSize) { int maxChildIndex = leftChildIndex; if (leftChildIndex + 1 &lt; heapSize &amp;&amp; nums[leftChildIndex + 1] &gt; nums[leftChildIndex]) { maxChildIndex = leftChildIndex + 1; } // 父节点的值不小于子结点的值，不需要继续移动 if (nums[index] &gt;= nums[maxChildIndex]) { break; } using std::swap; swap(nums[index], nums[maxChildIndex]); index = maxChildIndex; leftChildIndex = 2 * index + 1; } }}; 3 不基于比较的排序算法 优点 时间复杂度理想情况下低于$O(NlogN)$。 缺点 具体问题需要具体分析，不同的数据状况，算法要进行不同的调整。 桶排序桶排序的基本思路如下：将数组中的元素根据合适的分配方法分配到不同的桶中，不同桶之间的元素一定是有序的，同一个桶之间的元素再分别排序。同一个桶之间的元素可以使用传统的快排，也可以递归使用桶排序继续划分。 计数排序 性质 一种特殊的桶排序，每个出现过的元素值分配一个桶。因此只需要将数组中个元素分配到对应的桶，再按次序将桶中的数据回写到数组，即可完成排序。 因为每个桶里的元素是等价的，因此实际上只需要保存元素出现的频率即可。 时间复杂度：$O(N + M)$。其中$N$为数组长度，$M$为数组取值范围大小(桶的个数)。 空间复杂度：$O(N + M)$。 \"计数排序\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142class CountSort {public: static void countSort(std::vector&lt;int&gt; &amp;nums) { int size = static_cast&lt;int&gt;(nums.size()); if (size &lt; 2) { return; } int minValue = nums[0], maxValue = nums[0]; // 数组访问次数：4 * N // 获取数组取值范围 for (int i = 1; i &lt; size; ++i) { minValue = nums[i] &lt; minValue ? nums[i] : minValue; maxValue = nums[i] &gt; maxValue ? nums[i] : maxValue; } std::vector&lt;int&gt; count(maxValue - minValue + 2, 0); std::vector&lt;int&gt; aux(size, 0); // 数组访问次数：N // 计算出现频率 for (int i = 0; i &lt; size; ++i) { count[nums[i] - minValue + 1]++; } // 数组访问次数：R // 将频率转换为索引 for (int i = 1; i &lt; maxValue - minValue + 2; ++i) { count[i] += count[i - 1]; } // 数组访问次数：N // 将元素分类 for (int i = 0; i &lt; size; ++i) { aux[count[nums[i] - minValue]++] = nums[i]; } // 回写 for (int i = 0; i &lt; size; ++i) { nums[i] = aux[i]; } }}; 基数排序 性质 选择某个基数，将元素本身进行有限次的拆分，每次根据当前拆分的元素进行1次计数排序。 元素的拆分实际上是元素顺序优先级的拆分，例如字符串左边字符优先级比右边字符高。 拆分之后的排序算法不一定是计数排序，只要是稳定的排序算法即可。 LSD(低位优先排序) 时间复杂度：$O(W(N + M))$。与普通计数排序不同，LSD中计数排序的$M$通常远小于$N$。例如按十进制对整数进行划分，则$M$为10。 空间复杂度：$O(N + M)$。 \"LSD\" >folded12345678910111213141516171819202122232425262728293031323334// 低位优先的基数排序static void LSDSort(std::vector&lt;int&gt; &amp;nums) { int w = largestWidth(nums); int n = static_cast&lt;int&gt;(nums.size()); int bucketSize = 11; std::vector&lt;int&gt; count(bucketSize, 0); std::vector&lt;int&gt; aux(n, 0); for (int i = 1; i &lt;= w; ++i) { count.resize(bucketSize, 0); // 此时 count[j + 1] 表示 j 出现频率 for (int j = 0; j &lt; n; ++j) { int digit = lastKthDigit(nums[j], i); count[digit + 1]++; } // 此时 count[j] 表示 j 应该放在哪个下标 for (int j = 1; j &lt; bucketSize; ++j) { count[j] += count[j - 1]; } for (int j = 0; j &lt; n; ++j) { int digit = lastKthDigit(nums[j], i); aux[count[digit]++] = nums[j]; } for (int j = 0; j &lt; n; ++j) { nums[j] = aux[j]; } // count 记得复位, 否则下一次计数排序结果无法预计 count.clear(); }} MSD(高位优先排序) 4 字符串排序TODO 4 总结排序的稳定性稳定性：相等的元素排序后的相对顺序与排序前一致。 排序算法稳定性的优点：进行多轮不同主键的排序，可以完成按主键优先级排序。例如第一轮对学生的身高排序，第二轮对学生的年级排序。如果排序算法是稳定的，结果中同一年级的学生是按照身高的顺序排列的。如果排序算法不稳定，不能保证结果中同一年级的学生是按照身高的顺序排列的。 稳定的排序算法 冒泡排序：当后一个元素等于前一个元素时，终止该轮冒泡。 插入排序：当访问的有序子数组中元素等于要插入元素时，终止该轮插入。 归并排序：左半边和右半边元素相等时，存放左半边元素。 一切桶排序思想下的排序：入桶顺序与出桶顺序相同。 不稳定的排序算法 选择排序 例如1, 1, 1, 0, 1, 1。 快速排序 partition过程不能保证相同元素的相对顺序。例如2, 2, 2, 0, 1, 1, 1，以1为pivot。 堆排序 堆排序不能保证稳定性，因为它维护的是完全二叉树中，父结点与左右子树的大小关系，它的逻辑结构不是线性的，不可能保证相同元素的相对顺序。例如5, 3, 3, 4，此时不满足大根堆要求，4需要进行siftUp操作，与第1个3交换。 基于比较的排序本质一些问题 不存在时间复杂度为$O(NlogN)$, 空间复杂度为$O(1)$, 同时保证稳定性的算法 归并排序的变种可以将空间复杂度可以降为$O(1)$，但是这会导致时间复杂度的上升或者稳定性的破坏。 快速排序的变种可以保证稳定性，但是它的时间复杂度或者空间复杂度会上升。 数组长度较小时，插入排序的速度可能是最快的。因此归并排序和快速排序可以进行优化，当数组长度小于某个常数时，用插入排序代替递归调用。 5 练习88. Merge Sorted Array归并排序拓展题，注意这里没有必要利用辅助数组来合并有序数组。 \"Code\" >folded123456789101112131415161718192021222324class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p = m - 1, q = n - 1; // 从末尾开始确定合并后 nums1 所有元素 for (int cnt = m + n - 1; cnt &gt;= 0; --cnt) { // nums1 没有元素需要合并 if (p &lt; 0) { nums1[cnt] = nums2[q--]; } // nums2 没有元素需要合并 else if (q &lt; 0) { nums1[cnt] = nums1[p--]; } // nums1 当前元素大于 nums2 当前元素 else if (nums1[p] &gt; nums2[q]) { nums1[cnt] = nums1[p--]; } else { nums1[cnt] = nums2[q--]; } } }}; 时间复杂度：$O(m + n)$ 空间复杂度：$O(1)$ 21. Merge Two Sorted Lists\"递归版本\" >folded12345678910111213141516171819202122class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { // l1 为空链表, 返回 l2 if (l1 == nullptr) { return l2; // l2 为空链表, 返回 l1 } else if (l2 == nullptr) { return l1; } else { // l2 当前结点小于 l1 当前结点, 选择 l2 当前结点 if (l2-&gt;val &lt; l1-&gt;val) { l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; // 否则选择 l1 当前结点 } else { l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } } }}; 时间复杂度：$O(m + n)$ 空间复杂度：$O(m + n)$ \"迭代版本\" >folded123456789101112131415161718192021class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { // 哨兵结点，统一合并操作 ListNode preHead; ListNode *prev = &amp;preHead; while (l1 &amp;&amp; l2) { if (l2-&gt;val &lt; l1-&gt;val) { prev-&gt;next = l2; l2 = l2-&gt;next; } else { prev-&gt;next = l1; l1 = l1-&gt;next; } prev = prev-&gt;next; } // 这里与归并数组不同，不需要通过循环来合并剩下的元素 prev-&gt;next = l1 ? l1 : l2; return preHead.next; }}; 时间复杂度：$O(m + n)$ 空间复杂度：$O(1)$ 23. Merge k Sorted Lists归并排序拓展题。 \"递归版本\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { return mergeKLists(lists, 0, lists.size()); } ListNode *mergeKLists(vector&lt;ListNode*&gt; &amp;lists, int first, int last) { if (last - first == 0) { return nullptr; } else if (last - first == 1) { return lists[first]; } else if (last - first == 2) { return mergeTwoLists(lists[first], lists[first + 1]); } int mid = first + ((last - first) &gt;&gt; 1); auto left = mergeKLists(lists, first, mid); auto right = mergeKLists(lists, mid, last); // printList(left); // printList(right); return mergeTwoLists(left, right); // O(N), lists[first, .., last) 总共的结点个数 } // 时间复杂度: O(M + N) // 空间复杂度: O(M + N) ListNode *mergeTwoLists(ListNode *left, ListNode *right) { if (left == nullptr) { return right; } else if (right == nullptr) { return left; } else { if (right-&gt;val &lt; left-&gt;val) { right-&gt;next = mergeTwoLists(left, right-&gt;next); return right; } else { left-&gt;next = mergeTwoLists(left-&gt;next, right); return left; } } } // void printList(ListNode *head) { // for (ListNode *cur = head; cur != nullptr; cur = cur-&gt;next) { // std::cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;; // } // std::cout &lt;&lt; std::endl; // }}; 时间复杂度：$O(Nlog_{2}K)$，其中N为链表总共的结点数，K为链表条数。空间复杂度：$O(log_{2}K)$ 147. Insertion Sort List插入排序拓展题。 注意点 单向链表不同于数组，寻找插入位置时只能从头开始寻找。 如果对于每个结点都从头开始寻找插入位置，效率不高。因为不需要插入的元素需要将已经有序的部分遍历一遍。 \"从头开始寻找插入位置\" >folded123456789101112131415161718192021222324252627282930313233class Solution {public: ListNode* insertionSortList(ListNode* head) { // 链表长度小于2不需要排序 if (!head || !head-&gt;next) { return head; } // 定义一个哨兵结点，方便插入结点 ListNode preHead(-1, head); // lastSorted 指向有序链表的最后一个结点 ListNode *lastSorted = head; // 从第2个结点开始执行插入操作 for (ListNode *cur = head-&gt;next; cur != nullptr; cur = lastSorted-&gt;next) { // 如果 cur 的值小于 lastSorted 的值，cur 需要插入 if (cur-&gt;val &lt; lastSorted-&gt;val) { // 从头开始寻找插入位置 // prev 指向插入位置的前一个结点 for (ListNode *prev = &amp;preHead; prev-&gt;next != nullptr; prev = prev-&gt;next) { if (cur-&gt;val &lt; prev-&gt;next-&gt;val) { // 找到插入位置 lastSorted-&gt;next = cur-&gt;next; cur-&gt;next = prev-&gt;next; prev-&gt;next = cur; break; } } } else { lastSorted = cur; } } return preHead.next; }}; 时间复杂度：$O(N^{2})$。尽管单向链表的插入操作是$O(1)$，但插入排序的比较次数依然是$O(N^{2})$。 空间复杂度：$O(1)$ 148. Sort List排序拓展题 \"自顶向下归并排序(递归版本)\" >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: ListNode* sortList(ListNode* head) { int size = 0; // O(N) for (auto cur = head; cur != nullptr; cur = cur-&gt;next) { ++size; } return sortList(head, size); } ListNode *sortList(ListNode *first, int size) { if (size &lt; 2) { return first; } int m = size / 2, n = size - m; ListNode *left = first, *right = first; // O(N) for (int i = 0; i &lt; m; ++i) { right = right-&gt;next; } left = sortList(left, m); right = sortList(right, n); // O(N) ListNode *head = merge(left, m, right, n); // printList(head, m + n); return head; } ListNode *merge(ListNode *left, int m, ListNode *right, int n) { if (m == 0 &amp;&amp; n == 0) { return nullptr; } else if (m == 0) { right-&gt;next = merge(left, m, right-&gt;next, n - 1); return right; } else if (n == 0) { left-&gt;next = merge(left-&gt;next, m - 1, right, n); return left; } else if (right-&gt;val &lt; left-&gt;val){ right-&gt;next = merge(left, m, right-&gt;next, n - 1); return right; } else { left-&gt;next = merge(left-&gt;next, m - 1, right, n); return left; } } void printList(ListNode *first, int size) { for (int i = 0; i &lt; size; ++i) { std::cout &lt;&lt; first-&gt;val &lt;&lt; &quot; &quot;; first = first-&gt;next; } std::cout &lt;&lt; &quot;\\n&quot;; }}; 时间复杂度: $O(Nlog_{2}N)$ 空间复杂度: $O(N)$。最后一次merge时，占用空间最大。sortList的递归调用空间复杂度为$O(log_{2}N)$，merge的空间复杂度为$O(N)$。 剑指 Offer 51. 数组中的逆序对归并排序的拓展题。 时间复杂度：$O(NlogN)$。 空间复杂度：$O(N)$。 \"代码\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: static vector&lt;int&gt; aux; int reversePairs(vector&lt;int&gt;&amp; nums) { int size = static_cast&lt;int&gt;(nums.size()); aux.resize(size, 0); return mergeSort(nums, 0, size); } int mergeSort(vector&lt;int&gt; &amp;nums, int first, int last) { // 长度为1的数组不可再分，也不会存在逆序对 if (last - first &lt; 2) { return 0; } int mid = first + (last - first) / 2; // 左半边内部存在的逆序对数 int leftPairsNum = mergeSort(nums, first, mid); // 右半边内部存在的逆序对数 int rightPairsNum = mergeSort(nums, mid, last); // 左右半边之间存在的逆序对数 int betweenPairsNum = merge(nums, first, mid, last); return leftPairsNum + rightPairsNum + betweenPairsNum; } int merge(vector&lt;int&gt; &amp;nums, int first, int mid, int last) { int left = first, right = mid; int pairsNum = 0; for (int i = first; i &lt; last; ++i) { aux[i] = nums[i]; } for (int i = first; i &lt; last; ++i) { if (left &gt;= mid) { nums[i] = aux[right++]; } else if (right &gt;= last) { nums[i] = aux[left++]; // 右半边的当前元素小于左半边的当前元素，存在逆序对 } else if (aux[right] &lt; aux[left]) { // 逆序对的数量为左半边剩下的元素，包括当前元素 aux[left] pairsNum += mid - left; nums[i] = aux[right++]; } else { nums[i] = aux[left++]; } } return pairsNum; }}; 75. Sort Colors快速排序拓展题，与3分区快速排序中partition的思路一致，这类问题统称为荷兰国旗问题。 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"代码\" >folded12345678910111213141516171819202122class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int size = static_cast&lt;int&gt;(nums.size()); // [0, left) 红色 // [right, size) 蓝色 // [left, right) 白色 int left = 0, right = size; int cur = 0; // 待确定位置的元素 [cur, right) while (cur &lt; right) { using std::swap; if (nums[cur] &lt; 1) { swap(nums[cur++], nums[left++]); } else if (nums[cur] &gt; 1) { swap(nums[cur], nums[--right]); } else { ++cur; } } }}; 215. Kth Largest Element in an Array先排序后选择 时间复杂度：$O(NlogN)$。 空间复杂度：$O(logN)$。 \"先排序后选择\" >folded12345678class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int size = static_cast&lt;int&gt;(nums.size()); std::sort(nums.begin(), nums.end()); return nums[size - k]; }}; 快速选择 时间复杂度：$O(N)$。 空间复杂度：$O(logN)$。 \"快速选择\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution {public: static random_device randomDevice; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int size = static_cast&lt;int&gt;(nums.size()); if (k &gt; size || size == 0) { return numeric_limits&lt;int&gt;::max(); } if (size &lt; 2) { return nums[0]; } return findKthLargest(nums, size - k, 0, size); } int findKthLargest(vector&lt;int&gt; &amp;nums, int index, int first, int last) { // last - first 不应该为 0 if (last - first &lt; 2) { return nums[first]; } auto range = randomPartition(nums, first, last); if (index &lt; range.first) { return findKthLargest(nums, index, first, range.first); } else if (index &gt;= range.second) { return findKthLargest(nums, index, range.second, last); } else { return nums[index]; } } pair&lt;int, int&gt; randomPartition(vector&lt;int&gt; &amp;nums, int first, int last) { // 引入随机化过程 using std::swap; mt19937 randomEngine(randomDevice()); uniform_int_distribution&lt;int&gt; intDistribution(first, last - 1); int pivot = nums[intDistribution(randomEngine)]; int left = first, right = last; int cur = first; while (cur &lt; right) { if (nums[cur] &lt; pivot) { swap(nums[cur++], nums[left++]); } else if (nums[cur] &gt; pivot) { swap(nums[cur], nums[--right]); } else { ++cur; } } return {left, right}; }};random_device Solution::randomDevice;};random_device Solution::randomDevice; 239. Sliding Window Maximum堆排序扩展题。 时间复杂度：$O(NlogN)$。最坏情况下，不会有元素从堆中移除。 空间复杂度：$O(N)$。最坏情况下，堆最终会保存数组中所有的元素。 \"优先队列\" >folded1234567891011121314151617181920class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; ans; priority_queue&lt;pair&lt;int, int&gt;&gt; maxHeap; for (int i = 0; i &lt; k - 1; ++i) { maxHeap.push({nums[i], i}); } int size = static_cast&lt;int&gt;(nums.size()); for (int i = k - 1; i &lt; size; ++i) { maxHeap.push({nums[i], i}); // 只有堆中取出的最大值不在窗口内，才需要将其移除 while (maxHeap.top().second &lt; i + 1 - k) { maxHeap.pop(); } ans.push_back(maxHeap.top().first); } return ans; }}; 347. Top K Frequent Elements 时间复杂度：$O(NlogK)$。$N$为数组长度，$M$为数组中不重复元素个数。统计每个元素次数需要$O(N)$的时间，创建小根堆需要$O(MlogK)$的时间，从小根堆中获取结果需要$O(KlogK)$的时间。当$N==M$时，总共需要$O(NlogK)$的时间。 空间复杂度：$O(N)$。额外的空间消耗包括count以及minHeap两部分。count的空间消耗为$O(M)$，minHeap的空间消耗为$O(K)$。当$N==M$时，总共需要$O(N)$的空间。 \"二叉堆\" >folded123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { int n = static_cast&lt;int&gt;(nums.size()); // 统计每个元素出现的次数 unordered_map&lt;int, int&gt; count; for (int i = 0; i &lt; n; ++i) { count[nums[i]]++; } // 小根堆保存结果 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; minHeap; for (auto it = count.cbegin(); it != count.cend(); it++) { if (minHeap.size() &lt; k) { minHeap.emplace((*it).second, (*it).first); } else if ((*it).second &gt; minHeap.top().first){ minHeap.pop(); minHeap.emplace((*it).second, (*it).first); } } // 从小根堆中获取结果 vector&lt;int&gt; ans; for (int i = 0; i &lt; k &amp;&amp; !minHeap.empty(); ++i) { ans.emplace_back(minHeap.top().second); minHeap.pop(); } return ans; }}; 451. Sort Characters By Frequency 堆排序 时间复杂度：$O(N)$。因为s中只会存在英文字母以及数字，因此堆的大小是一个常数。 空间复杂度：$O(1)$。\"大根堆\" >folded123456789101112131415161718192021222324252627class Solution {public: string frequencySort(string s) { int n = static_cast&lt;int&gt;(s.size()); if (n &lt; 2) { return s; } unordered_map&lt;char, int&gt; count; for (auto ch : s) { count[ch]++; } priority_queue&lt;pair&lt;int, char&gt;&gt; maxHeap; for (auto it = count.cbegin(); it != count.cend(); ++it) { maxHeap.emplace(it-&gt;second, it-&gt;first); } string ans; while (!maxHeap.empty()) { for (int i = 0; i &lt; maxHeap.top().first; ++i) { ans.push_back(maxHeap.top().second); } maxHeap.pop(); } return ans; }}; 快速排序 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。\"快排\" >folded123456789101112131415161718192021222324252627class Solution {public: string frequencySort(string s) { int n = static_cast&lt;int&gt;(s.size()); if (n &lt; 2) { return s; } unordered_map&lt;char, int&gt; count; for (auto ch : s) { count[ch]++; } vector&lt;pair&lt;char, int&gt;&gt; vec(count.cbegin(), count.cend()); auto compare = [](pair&lt;char, int&gt; const &amp;lhs, pair&lt;char, int&gt; const &amp;rhs) { return lhs.second &gt; rhs.second; }; sort(vec.begin(), vec.end(), compare); string ans; for (auto const &amp;p : vec) { ans.append(p.second, p.first); } return ans; }}; 41. First Missing Positive 快速排序 时间复杂度：$O(NlogN)$。 空间复杂度：$O(N)$。 \"快速排序\" >folded12345678910111213141516int firstMissingPositive(vector&lt;int&gt;&amp; nums) { int n = static_cast&lt;int&gt;(nums.size()); sort(nums.begin(), nums.end()); if (nums[0] &gt; 1 || nums[n - 1] &lt;= 0) { return 1; } for (int i = 1; i &lt; n; ++i) { if (nums[i] &gt; 1 &amp;&amp; nums[i] - nums[i - 1] &gt; 1) { return nums[i - 1] &lt; 0 ? 1 : nums[i - 1] + 1; } } return nums[n - 1] + 1;}","link":"/2021/08/12/LeetCode/%E6%8E%92%E5%BA%8F/"},{"title":"【LeetCode】双指针","text":"快慢指针 Floyid判圈法 指向不同数组 同一数组不同方向遍历(搜索) 滑动窗口 1 同一数组不同方向遍历(搜索)时间复杂度从$O(n^2)$降为$O(n)$ 167. 两数之和 II - 输入有序数组2 指向不同数组88. 合并两个有序数组3 快慢指针Floyid判圈法FLoyid判圈法解决的3个问题 链表中是否存在环 找到环的入口结点 计算环的长度 实现思路利用双指针中的快慢指针方法解决问题. 快指针fast每次前进2步, 慢指针slow每次前进1步. 链表中是否存在环：如果链表中存在环，在某个时间点快慢指针一定会相遇，此时fast == slow. 令$x$为链表的第一部分长度, $y$为环的长度, $z$为第一次相遇时, fast以及slow与环的入口结点的距离. 因此第1次相遇时， slow走过的距离为$S_1 = x + ay + z$, fast走过的距离$S2 = 2S_1 = x + by + z$. $$S_2 - S_1 = (b - a)y = S_1 = x + ay + z$$ $$x + z = (b - 2a)y$$ 因此$x + z$一定是环长$y$的倍数. 环的入口结点：第一相遇后, 将slow移动到head重新前进, 这次前进fast每次也只前进1步. 当slow到达环的入口结点时, slow移动的步数为$x$. 则fast移动的总步数（从head算起）为$S_2 + x$. $$S_2 + x = x + by + z + x$$ 又$x + z = (b - 2a) y$ $$S_2 + x = 2(b-a)y + x$$ 此时fast一定也在环的入口结点($x$等价于$x + 2(b - 1)y$). 因此第2次前进当slow == fast时, slow就指向环的入口结点. 环的长度: 当slow与fast首次相遇时, 固定fast不动, 让slow再次前进, 当slow与fast再次相遇时, 移动的步数就是环的长度$y$. 141. 环形链表142. 环形链表 II4 滑动窗口76. 最小覆盖子串","link":"/2021/08/13/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"第十二章：动态内存","text":"栈内存, 静态内存, 堆内存(自由空间) 智能指针 new &amp; delete allocator 智能指针(smart pointer) 1. 为什么需要使用动态内存 程序不知道自己需要多少个对象：程序的栈内存分配之后，大小是固定的，不能随心所欲地分配新的内存. 程序不知道所需对象的所需模型（待回答, 需要学习15章） 程序在多个对象间共享数据：栈中的数据的生命周期与对象一致，不能达到共享数据的目标(两个对象共享某份数据，其中一个对象销毁时，不能单方面销毁底层的数据)。 2. 为什么引入智能指针的概念, 智能指针有哪几类引入智能指针是为了更加方便的管理动态分配的内存. 当某个资源的最后一个(唯一一个)所有者销毁时，会自动完成指定的资源释放动作.(delete或者其它的函数). 智能指针的状态: 空智能指针, 指向某个资源 智能指针有以下3种: shared_ptr&lt;T&gt;：多个shared_ptr共享同一个资源. 每个shared_ptr都能记录有多少个shared_ptr与它一起指向某个资源, 当最后一个shared_ptr销毁时, 会自动释放管理的资源. unique_ptr&lt;T&gt;: 一个unique_ptr独占一个资源, 不能进行拷贝或者赋值(除了移动), 当unique_ptr销毁时, 会自动释放其管理的资源. weak_ptr&lt;T&gt;: 指向一个shared_ptr指向的对象, 与shared_ptr不同, 它不控制资源, 每次访问资源时, 都需要事先判断资源是否存在. 智能指针支持的基本操作 条件判断: 与内置指针语义一致. 解引用*mp, mp-&gt;mem mp.get(), 获得智能指针内部的内置指针. 交换两个智能指针中的内置指针: swap(mp1, mp2), mp1.swap(mp2) 自定义deleter reset: 类似于初始化, 只不过智能指针会先减小自己的引用计数(释放资源), 再指向新的资源 shared_ptr的基本操作 make_shared&lt;T&gt;(args): 返回一个shared_ptr, 指向args初始化的对象. args为空, 则该对象进行值初始化. 拷贝构造: shared_ptr&lt;int&gt; sp2(sp1) 拷贝赋值: sp1 = sp2 unique use_count unique_ptr的基本操作 c++11中unique_ptr没有对应的make_xxx函数, 只能通过unique_ptr&lt;int&gt;(new int(1))的方式初始化 不能进行拷贝构造以及拷贝赋值 release: 与reset不同, 不会释放资源, 只会将智能指针本身置空, 返回内置指针. weak_ptr的基本操作 拷贝构造 赋值 expired() lock() 3. 为什么需要weak_ptrshared_ptr遇到循环引用时, 会导致内存泄漏. \"循环引用\" >folded12345678910111213141516171819202122232425262728293031323334class B;class A{public: std::shared_ptr&lt;B&gt; spB; A() { std::cout &lt;&lt; &quot;A ctor: &quot; &lt;&lt; this &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; &quot;A dtor: &quot; &lt;&lt; this &lt;&lt; std::endl; }};class B {public: std::shared_ptr&lt;A&gt; spA; B() { std::cout &lt;&lt; &quot;B ctor: &quot; &lt;&lt; this &lt;&lt; std::endl; } ~B() { std::cout &lt;&lt; &quot;B dtor: &quot; &lt;&lt; this &lt;&lt; std::endl; }};int main() { auto spA1 = std::make_shared&lt;A&gt;(); auto spB1 = std::make_shared&lt;B&gt;(); spA1-&gt;spB = spB1; spB1-&gt;spA = spA1; return 0;} \"输出\" >folded12A ctor: 0x1d1670B ctor: 0x1d6e70 此时两个动态对象不会被销毁 流程如下: spA1以及spB1指向创建的两个动态对象a以及b spA1内部的spB与spB1指向同一个对象, spA1引用计数为2 spB1内部的spA与spA1指向同一个对象，spB1引用计数为2 spA1销毁时, 引用计数减为1, 动态对象a不会被销毁 spB1销毁时, 引用计数减为1, 动态对象b也不会别销毁 而weak_ptr可以避免这个问题, 只需要将A或者B的shared_ptr指针变成weak_ptr即可, 当然都为weak_ptr也行. 假设B中保存weak_ptr, 流程如下: spA1以及spB1指向创建的两个动态对象a以及b spA1内部的spB与spB1指向同一个对象, spA1引用计数为1(weak_ptr不会增加引用计数) spB1内部的wpA与spA1指向同一个对象，spB1引用计数为2 spA1销毁时, 引用计数减为0, 动态对象a销毁, 导致spB1的引用计数此时减小为1 spB1销毁时, 引用计数减为0, 动态对象b销毁","link":"/2021/08/13/CppPrimer5th/ch12/"},{"title":"【LeetCode】搜索","text":"DFS 回溯 BFS 深度优先搜索时间复杂度: O(N), N为结点个数空间复杂度: O(H), H为搜索的深度.695. 岛屿的最大面积栈写法\"栈写法\" >folded123456789101112131415161718192021222324252627282930313233343536int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = static_cast&lt;int&gt;(grid.size()); int n = m &gt; 0 ? static_cast&lt;int&gt;(grid[0].size()) : 0; int maxArea = 0; vector&lt;int&gt; dm{-1, 0, 1, 0}; vector&lt;int&gt; dn{0, 1, 0, -1}; stack&lt;pair&lt;int, int&gt;&gt; s; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { // 找到了 dfs 的入口元素 if (grid[i][j] == 1) { int area = 0; s.push({i, j}); grid[i][j] = 0; while (!s.empty()) { auto el = s.top(); s.pop(); ++area; for (int k = 0; k &lt; static_cast&lt;int&gt;(dm.size()); ++k) { int ni = el.first + dm[k]; int nj = el.second + dn[k]; if (ni &gt;= 0 &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; n &amp;&amp; grid[ni][nj] == 1) { // 放入栈的元素必须立马标记, 防止重复遍历 s.push({ni, nj}); grid[ni][nj] = 0; } } } maxArea = area &gt; maxArea ? area : maxArea; } } } return maxArea;} 递归写法\"递归写法\" >folded1234567891011121314151617181920212223242526272829303132333435363738int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = static_cast&lt;int&gt;(grid.size()); int n = m &gt; 0 ? static_cast&lt;int&gt;(grid[0].size()) : 0; int maxArea = 0; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (grid[i][j] == 1) { int area = dfs(grid, i, j); maxArea = area &gt; maxArea ? area : maxArea; } } } return maxArea; }int dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, int i, int j) { int m = static_cast&lt;int&gt;(grid.size()); int n = m &gt; 0 ? static_cast&lt;int&gt;(grid[0].size()) : 0; int area = 1; grid[i][j] = 0; vector&lt;int&gt; dm{-1, 0, 1, 0}; vector&lt;int&gt; dn{0, 1, 0, -1}; for (int k = 0; k &lt; 4; ++k) { int ni = i + dm[k]; int nj = j + dn[k]; if (ni &gt;= 0 &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; n &amp;&amp; grid[ni][nj] == 1) { area += dfs(grid, ni, nj); } } return area;} 547. 省份数量栈写法\"栈写法\" >folded1234567891011121314151617181920212223242526int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) { int n = static_cast&lt;int&gt;(isConnected.size()); int cnt = 0; for (int i = 0; i &lt; n; ++i) { if (isConnected[i][i] == 1) { ++cnt; stack&lt;int&gt; s; s.push(i); isConnected[i][i] == 0; while (!s.empty()) { int cur = s.top(); s.pop(); for (int j = 0; j &lt; n; ++j) { // cur 与 j 相连 if (isConnected[cur][j] == 1 &amp;&amp; isConnected[j][j] == 1) { s.push(j); isConnected[j][j] = 0; // 已经搜索过的结点作标记 } } } } } return cnt;} 递归写法\"递归写法\" >folded123456789101112131415161718192021222324int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) { int n = static_cast&lt;int&gt;(isConnected.size()); int cnt = 0; for (int i = 0; i &lt; n; ++i) { if (isConnected[i][i] == 1) { ++cnt; dfs(isConnected, i); } } return cnt;}void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;isConnected, int i) { int n = static_cast&lt;int&gt;(isConnected.size()); isConnected[i][i] = 0; // 已经搜索过的结点作标记 for (int j = 0; j &lt; n; ++j) { if (isConnected[i][j] == 1 &amp;&amp; isConnected[j][j] == 1) { dfs(isConnected, j); } } }","link":"/2021/08/16/LeetCode/%E6%90%9C%E7%B4%A2/"},{"title":"CSAPP：信息的表示和处理","text":"计算机内所有的数据都是以二进制形式保存的，本章主要研究3种数字表示。 无符号编码，表示无符号整数。 补码编码，表示带符号整数。 浮点数编码，表示实数。 其中整数编码(无符号编码以及补码编码)虽然只能表示一个相对较小的数值范围，但是这种表示是精确的。而浮点数编码虽然可以编码一个较大的数值范围，但是这种表示是近似的。 1 信息存储1.1 字长与虚拟内存空间大小第一章提到操作系统为我们提供了虚拟内存这种抽象表示，通过虚拟内存，我们可以将内存看成一个非常大的字节数组，数组中的每个字节都有1个唯一的地址与之对应，所有的地址构成虚拟地址空间。那虚拟内存到底有多大呢？操作系统提供了字长决定了虚拟内存空间的大小。例如字长为$N$位时，虚拟内存地址的范围为$0$到$2^{N} - 1$，虚拟内存空间的大小为$2 ^ {N}$。我们日常生活中见到的计算机的字长一般都是32位或者64位。 1.2 寻址和字节序与多字节程序对象有关的两个概念 对象地址：对象所使用的字节中最小的地址。 字节序 大端法：最高有效字节保存在最前面。 小端法：最低有效字节保存在最前面。 什么时候需要注意字节序的问题。 编写网络应用程序时(程序涉及多台计算机系统时)。 检查机器级的程序代码(二进制代码)。 系统级编程。 1.3 位运算中需要注意的地方按位异或运算根据异或运算的真值表可以推出：a ^ b = (~a &amp; b) | (a &amp; ~b)。 归零律：a ^ a = 0 恒等律：a ^ 0 = a 交换律：a ^ b = b ^ a 结合律：a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c 实现掩码运算x = 0x89ABCDEF, x &amp; 0xFF = 0x000000EF。 1.4 C/C++中移位运算和Java的差别3种移位运算 左移：右边补0。 逻辑右移：左边补0。 算术右移：左边补最高位。 对于无符号数来说，逻辑右移和算术右移没有区别。 C/C++中没有明确规定有符号数的右移运算必须是算术右移，但是几乎所有编译器都会对有符号数使用算术右移。 Java中&gt;&gt;表示算术右移, &gt;&gt;&gt;表示逻辑右移。 C/C++中当移动的位数k大于等于数据类型的位数w时，大多数编译器都会对k先对w取模，再进行移位运算，但这不是必须的。 Java中要求位移数k必须对w进行取模运算。 2 整数表示 C/C++支持有符号数和无符号数，Java只支持有符号数。 C/C++标准定义了每个整数类型必须能够表示的最小取值范围。 32位程序与64位程序的区别在于该程序是如何编译的，而不是其运行的机器类型。 因为几乎所有编译器中有符号数都用补码进行表示，因此下文的有符号数与补码数是等价。 2.1 无符号编码$$B2U(\\vec {x}) = \\sum_{i = 0}^{w - 1} x_{i}2^{i} $$其中二进制向量$\\vec x = (x_{w-1}, x_{w-2}, …, x_0)$，$w$表示$\\vec x$的长度。 无符号编码所能表示的范围：$[0, 2^{w-1}]$。 $B2U$的最小值$UMin_{w} = 0$。 $B2U$的最大值$UMax_{w} = 2^{w} - 1$。 无符号编码具有唯一性。函数$B2U$将每一个长度为$w$的位向量都映射到$[0,2^{w}-1]$之间的一个唯一值。反过来我们也可以通过$B2U$的反函数$U2B$将$[0,2^{w}-1]$中的每一个整数都映射为一个唯一的长度为$w$的位向量。 2.2 补码编码$$B2T(\\vec {x}) = -x_{w-1}2^{w-1} + \\sum_{i = 0}^{w - 2} x_{i}2^{i} $$ 符号位。补码编码中位向量的最高位为符号位，与无符号编码不同，最高位(符号位)的权重是负的。 补码编码所能表示的范围：$[-2^{w-1}, 2^{w-1} - 1]$。 $B2T$的最小值$TMin_{w} = -2^{w - 1}$。 $B2T$的最大值$TMax_{w} = 2^{w - 1} - 1$。 补码编码的取值范围不是对称的，$TMin$没有与之对应的正数。 与无符号编码一样，补码编码也具有唯一性。$B2T$的反函数为$T2B$。 C/C++语言标准没有要求用补码形式来表示任何有符号整数，但是几乎所有机器都是怎么做的。而Java标准明确要求整数数据类型采用补码表示。 2.3 有符号数(补码编码)和无符号数(无符号编码)的互换 C/C++允许在各种不同的整数数据类型之间进行强制类型转换。 强制类型转换 位向量长度相等，无符号数与有符号数相互转换 位向量长度相等的有符号数与无符号数相互转换（$T2U$、$U2T$）：位向量不变，改变的只是解释位向量的函数（$B2U$、$B2T$）。$$T2U_{w}(x) =\\begin{cases}{x + 2^{w}, x &lt; 0}\\\\{x, x \\geq 0}\\end{cases}$$ $$U2T_{w}(u) = \\begin{cases} u, u \\leq TMax_{w}\\\\ u - 2^{w}, u &gt; TMax_{w} \\end{cases}$$ $$U2T_{w}(u) = \\begin{cases} u, u \\leq TMax_{w}\\\\ u - 2^{w}, u &gt; TMax_{w} \\end{cases}$$ 无符号数扩展位数：进行零扩展。在位向量的开头补0。例如16位无符号数53191的位向量为0xcfc7，而32位无符号数53191的位向量为0x0000cfc7。 有符号数扩展位数：进行符号扩展。在位向量的开头补符号位。例如16位有符号数-12345的位向量为0xcfc7，而32位有符号数-12345的位向量为0xffffcfc7。 从一个数据大小扩展到另一个数据大小，以及无符号数与有符号数之间转换的相对顺序能够影响一个程序的行为。 例如16位有符号数-12345(0xcfc7)转换为32位无符号数，当先扩展位数时，得到32位有符号数-12345(0xffffcfc7)。再转换为32位无符号数，得到4294954951(0xffffcfc7)。 如果先转换为16位无符号数，得到16位无符号数53191(0xcfc7)。再转换为32位无符号数，得到53191(0x0000cfc7)。 区别在于先扩展位数的话，那么进行的是符号扩展，而后扩展位数进行的是零扩展。 C/C++标准要求先扩展位数再完成无符号数和有符号数之间的相互转换。 截断整数。对于整数的截断，直接舍弃多出来的高位字节。 例如0x12345678截断成2个字节，采用小端法的机器，会保留78。 截断无符号数。相当于对$2^{k}$取模，其中$k$为截断之后位向量的长度。例如1111截断成11，等价于$15\\ mod\\ 4 = 3$。 截断有符号数。相当于以无符号数的身份对$2^{k}$取模之后，再转换为有符号数。例如1111截断成11，等价于$15\\ mod\\ 4 = 3$，再将3转换为$-1$。 printf没有使用任何类型信息，根据给定的指示符来决定如何解释对应的位向量。 混用有符号数与无符号数进行运算时，C/C++会隐式的将有符号数转换为无符号数来执行运算。 C/C++中$TMin_{32}$写成-2147483647 -1，不能直接写成-2147483648。因为C/C++中整数的字面值不会计算负号，而补码的数值范围不是对称的，2147483648大于$TMax_{32}$，C/C++会对其进行隐式的类型转换，转换为32位的无符号类型。 2.4 关于有符号数与符号数的建议 日常的使用不需要无符号数。 3 整数运算无论是无符号数还是有符号数所能表示的范围都是有限的，而对2个数进行整数运算得到的结果可能不在这个范围内，需要更多的位数来扩展数值范围。这种持续的字长膨胀意味着想要完整的表示无符号加法，就不能对无符号数的位数有所限制。然而大多数的编程语言中的类型都占据着固定的字节数，基于固定字节数的整数运算有着特殊的性质。 3.1 无符号加法 对于$w$位的无符号数，它的数值范围为$[0, 2^{w})$。而$x + y$的范围为$[0, 2^{w + 1})$。当$x + y \\geq 2^{w}$时，计算机会丢弃$x + y$的最高位(第$w + 1$位)，丢弃它就相当于$x + y - 2^{2}$。 无符号数加法公式 $$x +^{u}_{w} y = \\begin{cases} x + y, x + y &lt; 2^{w}\\\\ x + y - 2^{w}, x + y \\geq 2^{w} \\end{cases}$$ 可以看到无符号加法$x + y$的结果等价于对$x + y$对$2^{w}$取模。 $$ x + y = (x + y) mod\\ 2^{w}$$ 检测无符号数加法溢出 当$x + y$发生加法溢出时，$x + y = x + y - 2^{w}$。而$y &lt; 2^{w}$，因为$x, y \\in [0, 2^{w})$，所以$x + y &lt; x$。同理$x + y &lt; y$。 \"检测无符号数加法溢出\" >folded1234bool uadd_ok(unsigned x, unsigned y) { unsigned sum = x + y; return sum &lt; x;} 无符号加法逆元 $$ -^{u}_{w}x = \\begin{cases} x, x = 0 \\\\ 2^{w} - x, x &gt; 0 \\end{cases} $$ 3.2 补码加法 补码加法公式 $$ x +^{t}_{w} y = \\begin{cases} x + y - 2^{w}, x + y &gt;= 2^{w - 1}(正溢出)\\\\ x + y, -2^{w - 1} \\leq x + y &lt; 2^{w - 1}\\\\ x + y + 2^{w}, x + y &lt; 2^{w - 1}(负溢出) \\end{cases} $$ 检测补码加法的溢出 $ x &gt; 0, y &gt; 0$，如果$x + y &lt; 0$，则发生了正溢出。 $ x &lt; 0, y &lt; 0$，如果$x + y \\geq 0$，则发什么了负溢出。 \"检测补码加法溢出\" >folded123456bool tadd_ok(int x, int y) { bool negative_over = false, positive_over = false; negative_over = x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; (x + y) &gt;= 0; positive_over = x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; (x + y) &lt; 0; return !negative_over &amp;&amp; !postive_over;} \"检测补码减法溢出\" >folded12345678bool tsub_ok(int x, int y) { // 因为补码的数值范围不是对称的，TMin的加法逆元还是TMin // 当 y 等于 TMin 时, x - y 不等于 x + (- y) if (y == numeric_limits&lt;int&gt;::min()) { return x &gt;= 0; } return tadd_ok(x, -y);} 补码的加法逆元 $$ -^{t}_{w}x = \\begin{cases} TMin, x = TMin \\\\ -x, x &gt; TMin \\end{cases} $$ 3.3 无符号乘法$$x *^{u}_{w} y = (x \\cdot y)\\ mod\\ 2^{w}$$ 3.4 补码乘法$$x\\ *^{t}_{w}\\ y\\ =\\ U2T[(T2U(x) \\ \\cdot\\ T2U(y))\\ mod\\ 2^{w}]$$ \"检测补码乘法是否会溢出\" >folded12345// 证明过程见练习题 2.35bool tmult_ok(int x, int y) { int p = x * y; return !x || p / x == y;} \"通过提升结果类型判断补码乘法是否会溢出\"1234bool tmult_ok(int x, int y) { int res = statci_cast&lt;int64_t&gt;(x) * y; return res == static_cast&lt;int&gt;(res);} 3.5 乘以常数大多数机器上，整数乘法相比其它整数运算(加法、减法、移位运算、位运算)指令相当慢。 通常来说，编译器会尝试用移位、加法以及减法运算的组合来代替乘以常数因子的乘法。 乘以2的幂 对于无符号数值$x$和$k$，且$0 \\leq k &lt; w$。$$x\\ &lt;&lt;\\ k\\ =\\ x\\ *^{u}_{w}\\ 2^{k}$$ 对于补码值$x$与无符号数值$k$，且$0 \\leq k &lt; w$。$$x\\ &lt;&lt;\\ k\\ = \\ x\\ *^{t}_{w}\\ 2^{k}$$ 乘以任意常数 对于某个常数$K$的表达式$x\\ *\\ K$。假设K的二进制表示为[(0...0)(1...1)(0...0)...(1...1)]。可以用多个2的幂的加减法代替$K$。例如$14$可以写成[(0...0)(111)(0)]。 $$ x\\ *\\ 14 = x\\ *\\ (2^3 + 2^2 + 2^1) = (x &lt;&lt; 3) + (x &lt;&lt; 2) + (x &lt;&lt; 1) $$ $$ x\\ *\\ 14 = x\\ *\\ (2^4 - 2^1) = (x &lt;&lt; 4) - (x &lt;&lt; 1) $$ 3.6 除以2的幂在大多数机器上，整数除法要比整数乘法更慢。 实数$a$的取整操作。 向下取整。 $$\\lfloor a \\rfloor\\ = a^{}$$ $$a^{} \\leq\\ a\\ &lt; a^{`} + 1$$ - 向上取整。 $$\\lceil a \\rceil\\ = a^{`}$$ $$a^{`} - 1 \\leq\\ a\\ &lt; a^{`}$$ 注意点 补码加法和无符号加法得到的位串是一样的。当溢出时都只保留低$w$位。 补码乘法和无符号乘法得到的位串是一样的。当溢出时都只保留低$w$位。","link":"/2021/08/25/CSAPP/2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"},{"title":"第14章【C++ Primer】：操作重载与类型转换","text":"运算符被用于类类型时，C++允许为其指定新的含义。 C++允许自定义类类型之间的转换规则。 为什么需要运算符重载？它的用途？ 通过重载运算符可以让程序更易于编写和阅读。它能够重新定义某些运算符作用于指定的类类型的含义。 重载运算符本质上还是1个具有特殊名字的函数。 重载运算符的性质与要求。 2种实现方式。包括全局函数以及成员函数。当重载的运算符是成员函数时，运算符的第一个(左边)运算对象自动绑定到this上。 必须实现为成员函数的运算符。包括=, [], -&gt;, ()。 通常实现为成员函数的运算符。包括所有的复合赋值运算符，改变对象状态的运算符(递增，递减)以及与类类型密切相关的运算符(解引用)。 通常实现为全局函数的运算符。主要指具有对称性的运算符(算术、相等性、关系以及移位)。 当重载运算符函数名相同时，根据参数个数判断具体的运算符。例如operator+(T const &amp;)以及operator+(T const &amp;, T const &amp;)。 对于重载的运算符，它的优先级与结合律不会改变。 某一些运算符明确规定禁止重载。 某些运算符不推荐重载，因为与它的原始语义不一致。例如&amp;&amp;, ||以及逗号运算符。重载之后，它们的运算顺序无法保留，同时&amp;&amp;以及||的短路求值性质也无法保留。 重载运算符应该实现与内置类型一致的语义。 例如类A需要实现IO操作，则重载移位运算符。 重载的关系运算符以及逻辑运算符都应该返回bool类型。 重载的赋值和复合赋值运算符都应该返回类类型的引用。 某些运算符的重载应该成对出现。 例如==与!=。 所有的关系运算符。","link":"/2021/08/27/CppPrimer5th/ch14/"},{"title":"【LeetCode】链表","text":"单链表结点定义如下 1234567struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; 方法论 笔试和面试的区别 对于笔试(追求快速通过)，不用太在意额外空间复杂度，一切为了时间复杂度。这样写出来的代码往往需要借助额外的数据结构，代码较为简单，编写速度快，通常不是最优解。 对于面试(要求最优解)，时间复杂度依然放在第一位，但是一定要找到额外空间复杂度最优的方法。 链表题的重要技巧 额外数据结构记录(哈希表、数组) 快慢指针 基础题(主要考察基础的代码实现能力),往往只需要简单模拟 所有的操作步骤。 翻转链表(单链表以及双链表) 公共元素 技巧题(时间复杂度或者空间复杂度可以进一步优化) 回文单链表 \"解题思路\" >folded1234567方法1. 额外数据结构：栈方法2. 优化额外空间复杂度为$O(1)$。 1. 找到链表中点 2. 翻转右半边链表 3. 比较左半边链表和右半边链表 4. 复原右半边链表 单链表中的环 \"解题思路\" >folded123方法1. 额外数据结构：哈希表方法2. 快慢指针 单链表的荷兰国旗(partition)问题 \"解题思路\" >folded123456方法1. 额外数据结构：数组方法2. 链表可以随意插入，不需要额外的空间复杂度。 1. 建立3个分区链表 2. 循环遍历链表，在对应分区链表尾部插入结点 3. 重连3个分区链表(注意某个分区可能为空) 复制带有随机指针的单链表 \"解题思路\" >folded123方法1. 额外数据结构：哈希表方法2. 将复制出来的新结点插入旧结点的后面 两个单链表(可能有环)相交 \"解题思路\" >folded1234根据链表是否有环分情况讨论。1. 一个有环，一个没有环，两个链表不可能相交。2. 两个单链表都没有环。3. 两个都有环。 翻转链表206. 反转链表(Easy) 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 \"c++\" >folded12345678910111213class Solution {public: ListNode* reverseList(ListNode* head) { ListNode *prev = nullptr, *cur = head, *next; while (cur != nullptr) { next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; } return prev; }}; 92. 反转链表 II(Medium) 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 \"解题思路\" >folded1 \"c++\" >folded1234567891011121314151617181920212223242526class Solution {public: ListNode* reverseBetween(ListNode* head, int left, int right) { ListNode preHead(-1, head); ListNode *cur = head, *prev = &amp;preHead;; for (int i = left; i &gt; 1 &amp;&amp; cur; i--) { prev = cur; cur = cur-&gt;next; } prev-&gt;next = reverseKNode(cur, right - left + 1); return preHead.next; } ListNode *reverseKNode(ListNode *head, int k) { ListNode *prev = nullptr, *cur = head, *next; while (k &gt; 0 &amp;&amp; cur != nullptr) { next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; k--; } head-&gt;next = next; return prev; }}; 61. 旋转链表(Medium) 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 \"解题思路\" >folded1 \"c++\" >folded123456789101112131415161718192021222324252627282930313233343536class Solution {public: ListNode* rotateRight(ListNode* head, int k) { if (k == 0 || head == nullptr || head-&gt;next == nullptr) { return head; } ListNode preHead(-1, head); int n = 0; ListNode *slow = &amp;preHead, *fast = &amp;preHead; for (auto cur = head; cur; cur = cur-&gt;next) { ++n; } k = k % n; // k 为 0时，不需要旋转 if (k == 0) { return head; } while (k &gt; 0) { fast = fast-&gt;next; k--; } while (fast-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next; } fast-&gt;next = preHead.next; preHead.next = slow-&gt;next; slow-&gt;next = nullptr; return preHead.next; }}; 25. K 个一组翻转链表(Hard) 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 \"c++\" >folded12345678910111213141516171819202122232425262728293031323334class Solution {public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode preHead(0, head); ListNode *prev = &amp;preHead, *cur = head; while (cur) { auto p = reverse(cur, k); prev-&gt;next = p.first; prev = cur; cur = p.second; } return preHead.next; } // 返回反转后链表的头指针以及下一次反转的头指针 pair&lt;ListNode *, ListNode*&gt; reverse(ListNode *head, int size) { ListNode *prev = nullptr, *cur = head, *next = nullptr; int cnt = 0; while (cur &amp;&amp; cnt &lt; size) { next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; ++cnt; } // 长度不够 size，撤销反转 if (cnt &lt; size) { return reverse(prev, cnt); } head-&gt;next = cur; return {prev, cur}; }}; 练习2. 两数相加(Medium) 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 \"解题思路\" >folded1简单地模拟加法运算的过程即可。注意链表长度不相等的情况以及处理最后的进位。 \"c++\" >folded12345678910111213141516171819202122232425class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode preHead(-1); ListNode *prev = &amp;preHead; int carry = 0; // 加法进位 while (l1 || l2) { int a = l1 ? l1-&gt;val : 0; int b = l2 ? l2-&gt;val : 0; int sum = a + b + carry; ListNode *node = new ListNode(sum % 10); prev-&gt;next = node; prev = node; carry = sum / 10; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; } if (carry) { ListNode *node = new ListNode(carry); prev-&gt;next = node; prev = node; } return preHead.next; }}; 86. 分隔链表(Medium) 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。 \"解题思路\" >folded1模拟法，定义2条链表分别保存左右分区结点，最后将两条链表连接在一起即可。 \"c++\" >folded123456789101112131415161718192021class Solution {public: ListNode* partition(ListNode* head, int x) { ListNode left(-1), right(-1); ListNode *leftPrev = &amp;left, *rightPrev = &amp;right; ListNode *cur = head; while (cur) { if (cur-&gt;val &lt; x) { leftPrev-&gt;next = cur; leftPrev = cur; } else { rightPrev-&gt;next = cur; rightPrev = cur; } cur = cur-&gt;next; } leftPrev-&gt;next = right.next; rightPrev-&gt;next = nullptr; return left.next; }}; 83. 删除排序链表中的重复元素(Easy) 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次。返回同样按升序排列的结果链表。 \"解题思路\" >folded1简单模拟链表删除重复元素的操作即可。 \"c++\" >folded123456789101112131415161718class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode preHead(-1, head); ListNode *prev = &amp;preHead, *cur = head, *next; while (cur) { next = cur-&gt;next; // 如果 next 的值与 cur 的值不一致，prev 的下一个结点应该是 cur // 特别地，当 cur 为 链表末尾时，prev 的下一个结点也应该是 cur if (!next || next-&gt;val != cur-&gt;val) { prev-&gt;next = cur; prev = cur; } cur = next; } return preHead.next; }}; 82. 删除排序链表中的重复元素 II(Medium) 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现的数字。返回同样按升序排列的结果链表。 \"解题思路\" >folded1模拟法，与上一题的区别在于只保留没有重复出现过的元素，处理上存在差异。 \"c++\" >folded12345678910111213141516171819202122232425class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode preHead(-1, head); ListNode *prev = &amp;preHead, *cur = head, *next; while (cur) { next = cur-&gt;next; if (next &amp;&amp; cur-&gt;val == next-&gt;val) { while (next &amp;&amp; cur-&gt;val == next-&gt;val) { cur = next; next = cur-&gt;next; } // 下次检查 next 是否没有重复出现 cur = next; // 从链表中删除重复出现的结点 prev-&gt;next = next; } else { prev-&gt;next = cur; prev = cur; cur = next; } } return preHead.next; }}; 19. 删除链表的倒数第 N 个结点(Medium) 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 \"c++\" >folded1234567891011121314151617181920class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { if (head == nullptr) { return head; } ListNode preHead(-1, head); ListNode *slow = &amp;preHead, *fast = &amp;preHead; while (n &gt; 0) { fast = fast-&gt;next; --n; } while (fast-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next; } slow-&gt;next = slow-&gt;next-&gt;next; return preHead.next; }}; 24. 两两交换链表中的节点(Medium) 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 \"c++\" >folded123456789101112131415class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode preHead(-1, head); ListNode *prev = &amp;preHead, *cur = head; while (cur &amp;&amp; cur-&gt;next) { prev-&gt;next = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; prev-&gt;next-&gt;next = cur; prev = cur; cur = cur-&gt;next; } return preHead.next; }}; 138. 复制带随机指针的链表(Medium) 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 \"c++\" >folded1234567891011121314151617181920class Solution {public: Node* copyRandomList(Node* head) { unordered_map&lt;Node *, Node *&gt; nodeMap; for (Node *cur = head; cur; cur = cur-&gt;next) { Node *newNode = new Node(cur-&gt;val); nodeMap[cur] = newNode; } for (Node *cur = head; cur; cur = cur-&gt;next) { auto node = nodeMap[cur]; auto nextNode = cur-&gt;next ? nodeMap[cur-&gt;next] : nullptr; auto randomNode = cur-&gt;random ? nodeMap[cur-&gt;random] : nullptr; node-&gt;next = nextNode; node-&gt;random = randomNode; } return head ? nodeMap[head] : nullptr; }}; \"c++\" >folded1234567891011121314151617181920212223242526class Solution {public: Node* copyRandomList(Node* head) { for (Node *cur = head; cur; cur = cur-&gt;next-&gt;next) { Node *newNode = new Node(cur-&gt;val); // 将新结点插入到原结点后 newNode-&gt;next = cur-&gt;next; cur-&gt;next = newNode; } // 构建新链表中的 random 关系 for (Node *cur = head; cur; cur = cur-&gt;next-&gt;next) { cur-&gt;next-&gt;random = cur-&gt;random ? cur-&gt;random-&gt;next : nullptr; } Node *newList = head ? head-&gt;next : nullptr; // 构建新链表中的 next 关系 for (Node *cur = head; cur; cur = cur-&gt;next) { auto tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; tmp-&gt;next = tmp-&gt;next ? tmp-&gt;next-&gt;next : nullptr; } return newList; }}; 141. 环形链表(Easy) 给定一个链表，判断链表中是否有环。 \"c++\" >folded1234567891011121314class Solution {public: bool hasCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) { return true; } } return false; }}; \"python\" >folded123456789class Solution: def hasCycle(self, head: ListNode) -&gt; bool: slow = fast = head while fast and fast.next and fast.next.next: slow = slow.next fast = fast.next.next if fast is slow: return True return False 142. 环形链表 II(Medium) 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 \"c++\" >folded12345678910111213141516171819class Solution {public: ListNode *detectCycle(ListNode *head) { auto slow = head, fast = head; while (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) { fast = head; while (fast != slow) { fast = fast-&gt;next; slow = slow-&gt;next; } return fast; } } return nullptr; }}; \"python\" >folded1234567891011121314151617class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; slow = fast = head while fast and fast.next and fast.next.next: slow = slow.next fast = fast.next.next if slow is fast: fast = head while slow is not fast: slow = slow.next fast = fast.next return slow return None 876. 链表的中间结点(Easy) 给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。 \"c++\" >folded123456789101112131415161718192021class Solution {public: ListNode* middleNode(ListNode* head) { auto slow = head, fast = head; while (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } // 空链表 if (fast == nullptr) { return nullptr; } // 奇数结点 if (fast-&gt;next == nullptr) { return slow; // 偶数结点 } else { return slow-&gt;next; } }}; \"python\" >folded12345678910111213141516class Solution(object): def middleNode(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head == None: return None slow, fast = head, head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next if fast.next == None: return slow else: return slow.next 143. Reorder List(Medium) 给定一个单链表 L 的头节点 head ，单链表 L 表示为：L0 → L1 → … → Ln-1 → Ln 请将其重新排列后变为：L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 \"c++\" >folded12345678910111213141516171819class Solution {public: void reorderList(ListNode* head) { vector&lt;ListNode *&gt; vec; for (auto cur = head; cur; cur = cur-&gt;next) { vec.push_back(cur); } int n = static_cast&lt;int&gt;(vec.size()); int low = 0, high = n - 1; while (low &lt; high - 1) { vec[high]-&gt;next = vec[low]-&gt;next; vec[low]-&gt;next = vec[high]; ++low; --high; } vec[high]-&gt;next = nullptr; }}; \"python\" >folded123456789101112131415161718class Solution(object): def reorderList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. &quot;&quot;&quot; node_list = [] cur = head while cur: node_list.append(cur) cur = cur.next low, high = 0, len(node_list) - 1 while low &lt; high - 1: node_list[high].next = node_list[low].next node_list[low].next = node_list[high] low += 1 high -= 1 node_list[high].next = None \"c++\" >folded12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: void reorderList(ListNode* head) { if (head == nullptr) { return; } // 1. 找到链表中点 auto slow = head, fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } ListNode *rightHead = slow-&gt;next; // 2. 反转右半边链表 ListNode *cur = rightHead, *prev = nullptr, *next; while (cur) { next = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = next; } rightHead = prev; // 3. 合并左半边链表和右半边链表 auto left = head, right = rightHead; while (left &amp;&amp; right) { auto nextLeft = left-&gt;next, nextRight = right-&gt;next; right-&gt;next = nextLeft; left-&gt;next = right; left = nextLeft; right = nextRight; } // 链表长度为奇数时，为左半边最后1个结点设置 next if (left) { left-&gt;next = nullptr; } }}; \"python\" >folded123456789101112131415161718192021222324252627282930313233343536class Solution(object): def reorderList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. &quot;&quot;&quot; if not head: return # 1. 找到链表的中点 slow = fast = head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next rightHead = slow.next # 2. 翻转右半边链表 prev, cur = None, rightHead while cur: next = cur.next cur.next = prev prev = cur cur = next rightHead = prev # 3. 合并左半边链表和右半边链表 left, right = head, rightHead while left and right: nextLeft = left.next nextRight = right.next right.next = left.next left.next = right left = nextLeft right = nextRight if left: left.next = None 146. LRU 缓存机制(Medium)LRU(least recently used)意义为最近最少使用。优先缓存最近访问过的资源，当缓存区即将溢出的时候，删除缓存中最久没有访问的资源。LRU Cache要求资源的查询、更新以及插入的时间复杂度为$O(1)$。 一般都是通过双链表加上哈希表来实现。链表头部保存最近访问的资源，链表尾部保存最久没有访问的资源，从链表头部到链表尾部，资源的优先级依次降低。哈希表保存资源的键以及资源存储的位置(结点)。 为什么说双链表加上哈希表可以实现LRU Cache。首先LRU Cache支持两种操作。 get(int key)。 如果缓存中不存在对应的资源，利用哈希表能够在$O(1)$时间内得到结果。 如果缓存中存在对应的资源，步骤如下。总的时间复杂度依然为$O(1)$。 利用哈希表查询到对应的链表结点，从而获取对应的资源。时间消耗为$O(1)$。 因为该资源目前的优先级最高，因此需要将对应的结点移动到双链表头部，更新哈希表的记录。时间消耗为$O(1)$。 put(int key, int value)。 如果缓存中存在对应的资源，更新资源。时间消耗为$O(1)$。 利用哈希表查询到对应的链表结点，从而修改对应的资源。时间消耗为$O(1)$。 将该结点移动到双链表头部, 更新哈希表中的记录。时间消耗为$O(1)$。 如果缓存中不存在对应的资源。 如果缓存即将溢出，需要删除最久未访问的资源。无论是从双链表尾部删除结点还是从哈希表中删除记录的时间消耗都是$O(1)$。 创建新的结点，将节点插入双链表头部，更新哈希表的记录。时间消耗为$O(1)$。 为什么不能使用deque代替双链表。因为LRU Cache中需要将中间的某个元素移动到头部。而deque底层通过vector来保存元素，对于这个操作，它的时间复杂度不是$O(1)$。 双链表的结点为什么需要同时保存key以及value。根据哈希表不是能够直接查询到key对应的结点。因为删除尾部结点时，哈希表不知道对应的key，如果链表结点不保存对应的key，哈希表无法删除记录。 c++ list+unordered_map \"list+unordered_map\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class LRUCache {public: LRUCache(int capacity) : capacity_(capacity) { } int get(int key) { auto iter = mp_.find(key); // 如果 key 不存在, 返回 -1 if (iter == mp_.cend()) { return -1; } // 如果 key 存在 int value = iter-&gt;second-&gt;second; // 将最近访问的结点移动到双链表最前面 lst_.erase(iter-&gt;second); lst_.push_front(make_pair(key, value)); mp_[key] = lst_.begin(); // 返回对应的 value return value; } void put(int key, int value) { auto iter = mp_.find(key); // 如果缓存中没有对应的 key if (iter == mp_.cend()) { // 如果缓存满了的话，删除双链表末尾的结点 if (capacity_ == lst_.size()) { mp_.erase(lst_.back().first); lst_.pop_back(); } // 链表头部插入新的结点 lst_.push_front(make_pair(key, value)); mp_[key] = lst_.begin(); // 如果缓存中已经存在对应的 key } else { // 将对应的结点移动到链表头部 lst_.erase(iter-&gt;second); lst_.push_front(make_pair(key, value)); mp_[key] = lst_.begin(); } }private: list&lt;pair&lt;int, int&gt;&gt; lst_; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; mp_; int capacity_; }; 自己实现双链表 使用标准库中的list有一点不方便，将某个结点移动到链表头部时，需要先删除该结点，再在头部插入新结点。 自己实现的双链表，可以在头部以及尾部添加两个哨兵结点。可以减少边界判断。 \"自己实现双链表\" >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495struct LRUNode { int key; int value; LRUNode *prev; LRUNode *next; LRUNode(int key, int value, LRUNode *prev = nullptr, LRUNode *next = nullptr) : key(key), value(value), prev(prev), next(next){ }};struct LRUList { LRUNode *preHead; LRUNode *afterTail; int size; LRUList() : size(0){ preHead = new LRUNode(-1, -1); afterTail = new LRUNode(-1, -1); preHead-&gt;next = afterTail; afterTail-&gt;prev = preHead; } void moveToHead(LRUNode *node) { node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next-&gt;prev = node-&gt;prev; node-&gt;next = preHead-&gt;next; preHead-&gt;next-&gt;prev = node; preHead-&gt;next = node; node-&gt;prev = preHead; } int deleteTailNode() { auto tail = afterTail-&gt;prev; auto prev = tail-&gt;prev; prev-&gt;next = afterTail; afterTail-&gt;prev = prev; int key = tail-&gt;key; delete tail; --size; return key; } void addNode(int key, int value) { auto node = new LRUNode(key, value); node-&gt;prev = preHead; node-&gt;next = preHead-&gt;next; preHead-&gt;next-&gt;prev = node; preHead-&gt;next = node; ++size; } };class LRUCache {public: LRUCache(int capacity) : capacity_(capacity) { } // 1. 查询哈希表, 如果key不存在, 返回 -1 // 2. 查询哈希表, 如果key存在, 将对应的结点移动到链表头部, 返回对应的值 int get(int key) { auto iter = mp_.find(key); if (iter == mp_.cend()) { return -1; } auto node = iter-&gt;second; lst_.moveToHead(node); return node-&gt;value; } // 1. 查询哈希表, 如果 key 存在, 将对应的结点移动到头部 // 2. 查询哈希表, 如果 key 不存在, 判断缓存是否会溢出，如果会溢出， // 先删除链表末尾的结点并从哈希表中移除对应的记录 // 如果不会溢出，创建新的结点，并在链表头部插入 void put(int key, int value) { auto iter = mp_.find(key); if (iter != mp_.cend()) { auto node = iter-&gt;second; // LRU中已经存在相同的 key, 将对应的值用 value 覆盖，并将节点移动到头部 node-&gt;value = value; lst_.moveToHead(node); } else { if (lst_.size == capacity_) { int tailKey = lst_.deleteTailNode(); mp_.erase(tailKey); } lst_.addNode(key, value); } mp_[key] = lst_.preHead-&gt;next; }private: LRUList lst_; unordered_map&lt;int, LRUNode *&gt; mp_; int capacity_;}; python 自己实现双链表 \"python 自己实现双链表\" >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class LRUNode: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = Noneclass LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = dict() self.first = LRUNode(-1, -1) self.last = LRUNode(-1, -1) self.first.next = self.last self.last.prev = self.first # 如果缓存中不存在相同的 key, 返回 - 1 # 如果缓存中存在相同的 key, 将对应的结点移动到链表头部, 返回 value def get(self, key: int) -&gt; int: if key not in self.cache: return -1 node = self.cache[key] self.move_to_head(node) return node.value # 如果缓存中不存在相同的 key, 判断缓存是否会溢出，有必要的话，删除链表末尾的结点，同时从哈希表中删除记录 # 在链表头部插入新结点, 哈希表插入新的记录 # 如果缓存中存在相同的 key, 修改对应结点的值，同时将其移动到链表头部 def put(self, key: int, value: int) -&gt; None: if key not in self.cache: if len(self.cache) == self.capacity: self.delete_node(self.last.prev) self.insert_node_to_head(key, value) else: self.cache[key].value = value self.move_to_head(self.cache[key]) def move_to_head(self, node: LRUNode) -&gt; None: node.prev.next = node.next node.next.prev = node.prev node.next = self.first.next self.first.next.prev = node self.first.next = node node.prev = self.first def delete_node(self, node: LRUNode) -&gt; None: node.prev.next = node.next node.next.prev = node.prev del self.cache[node.key] def insert_node_to_head(self, key: int, value: int) -&gt; None: node = LRUNode(key, value) self.first.next.prev = node node.next = self.first.next node.prev = self.first self.first.next = node self.cache[key] = node collections.OrderedDict \"OrderedDict\" >folded12345678910111213141516171819202122from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict () self.capacity = capacity def get(self, key: int) -&gt; int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -&gt; None: if key not in self.cache: if len(self.cache) == self.capacity: self.cache.popitem(last=False) self.cache[key] = value else: self.cache[key] = value self.cache.move_to_end(key) 328. 奇偶链表(Medium) 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 \"c++\" >folded123456789101112131415161718class Solution {public: ListNode* oddEvenList(ListNode* head) { if (head == nullptr) { return head; } auto oddHead = head, evenHead = head-&gt;next; auto oddCur = oddHead, evenCur = evenHead; while (evenCur &amp;&amp; evenCur-&gt;next) { oddCur-&gt;next = evenCur-&gt;next; oddCur = oddCur-&gt;next; evenCur-&gt;next = oddCur-&gt;next; evenCur = evenCur-&gt;next; } oddCur-&gt;next = evenHead; return oddHead; }}; \"python\" >folded12345678910111213class Solution: def oddEvenList(self, head: ListNode) -&gt; ListNode: if not head: return head odd_head, even_head = head, head.next odd_cur, even_cur = odd_head, even_head while even_cur and even_cur.next: odd_cur.next = even_cur.next odd_cur = odd_cur.next even_cur.next = odd_cur.next even_cur = even_cur.next odd_cur.next = even_head return odd_head 148. 排序链表(Medium) 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表。 题目要求排序的时间复杂度为$O(NlogN)$，额外空间复杂度为$O(1)$。基于比较的排序中只有归并排序、快速排序、堆排序的时间复杂度为$O(NlogN)$。又因为是对链表排序，归并排序中合并有序数组的空间代价可以降为$O(1)$，因此归并排序可以满足要求。而快速排序的空间复杂度为$O(logN)$，堆排序的空间复杂度为$O(N)$。 实际上自顶向下的归并排序额外空间复杂度为$O(logN)$，不符合题意。只有自底向上的归并排序才能真正将额外空间复杂度优化为$O(1)$。 自顶向下的归并排序 \"c++\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: ListNode* sortList(ListNode* head) { return mergeSort(head); } ListNode *mergeSort(ListNode *first) { if (!first || !first-&gt;next) { return first; } // 找到链表的中点 auto mid = findMid(first); // 保存右半边链表的开始结点 ListNode *first2 = mid-&gt;next; // 断开左半边链表和右半边链表 mid-&gt;next = nullptr; ListNode *left = mergeSort(first); ListNode *right = mergeSort(first2); // 合并左半边链表和右半边链表 return mergeList(left, right); } ListNode *findMid(ListNode *first) { ListNode *slow = first, *fast = first; while (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return slow; } ListNode *mergeList(ListNode *left, ListNode *right) { ListNode preHead; ListNode *cur = &amp;preHead, *next = cur; while (left &amp;&amp; right) { if (right-&gt;val &lt; left-&gt;val) { next = right; right = right-&gt;next; } else { next = left; left = left-&gt;next; } cur-&gt;next = next; cur = next; } cur-&gt;next = left ? left : right; return preHead.next; }}; \"python\" >folded12345678910111213141516171819202122232425262728293031323334class Solution:def sortList(self, head: ListNode) -&gt; ListNode: return self.mergeSort(head)def mergeSort(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head mid = self.midNode(head) rightHead = mid.next mid.next = None head = self.mergeSort(head) rightHead = self.mergeSort(rightHead) return self.mergeList(head, rightHead)def midNode(self, head: ListNode) -&gt; ListNode: slow = fast = head while fast and fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slowdef mergeList(self, left: ListNode, right: ListNode) -&gt; ListNode: preHead = ListNode() cur = preHead while left and right: if right.val &lt; left.val: cur.next = right right = right.next else: cur.next = left left = left.next cur = cur.next cur.next = left if left else right return preHead.next 自底向上的归并排序 \"c++\" >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution {public: ListNode* sortList(ListNode* head) { int size = 0; for (auto cur = head; cur; cur = cur-&gt;next) { ++size; } ListNode preHead(0, head); // 当 subSize &gt;= size 时, 链表已经有序 for (int subSize = 1; subSize &lt; size; subSize += subSize) { // 这里的 left 不能用 head 初始化, 因为一轮归并之后, head 可能不再位于链表头部 auto prev = &amp;preHead, left = preHead.next, cur = left; while (left) { // step 1. 寻找右半边链表的起点 right for (int i = 0; cur &amp;&amp; i &lt; subSize - 1; ++i) { cur = cur-&gt;next; } // 剩下的元素不超过 subSize, 不需要归并, 已经有序 if (cur == nullptr || cur-&gt;next == nullptr) { prev-&gt;next = left; break; } auto right = cur-&gt;next; cur-&gt;next = nullptr; cur = right; // step 2. 寻找下次归并的起点 next for (int i = 0; cur &amp;&amp; i &lt; subSize - 1; ++i) { cur = cur-&gt;next; } ListNode *next = nullptr; if (cur &amp;&amp; cur-&gt;next) { next = cur-&gt;next; cur-&gt;next = nullptr; } // step 3. 开始该次归并, 让 prev 的下一个结点为归并链表的起点 prev-&gt;next = mergeList(left, right); // 修改 prev, 让它指向归并链表的最后一个元素 while (prev-&gt;next) { prev = prev-&gt;next; } left = next; cur = next; } } return preHead.next; } ListNode *mergeList(ListNode *left, ListNode *right) { ListNode preHead; ListNode *cur = &amp;preHead, *next = cur; while (left &amp;&amp; right) { if (right-&gt;val &lt; left-&gt;val) { next = right; right = right-&gt;next; } else { next = left; left = left-&gt;next; } cur-&gt;next = next; cur = next; } cur-&gt;next = left ? left : right; return preHead.next; }}; \"python\" >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution:def sortList(self, head: ListNode) -&gt; ListNode: size, cur = 0, head # 计算链表长度 while cur: size += 1 cur = cur.next subSize, preHead = 1, ListNode(0, head) # 当链表长度不超过 subSize 时, 链表已经有序 while subSize &lt; size: prev, left, cur = preHead, preHead.next, preHead.next while left: # 寻找右半边链表的起点 for i in range(0, subSize - 1): if cur: cur = cur.next else: break # 右半边链表为空, 该轮归并结束 if (not cur) or (not cur.next): prev.next = left break right = cur.next cur.next = None cur = right # 寻找下次归并的起点 for i in range(0, subSize - 1): if cur: cur = cur.next else: break next = None if cur and cur.next: next = cur.next cur.next = None # print(left.val, right.val) prev.next = self.mergeList(left, right) while prev.next: prev = prev.next # print(next.val) left = next cur = left subSize += subSize return preHead.nextdef mergeList(self, left: ListNode, right: ListNode) -&gt; ListNode: preHead = ListNode() cur = preHead while left and right: if right.val &lt; left.val: cur.next = right right = right.next else: cur.next = left left = left.next cur = cur.next cur.next = left if left else right return preHead.next 160. 相交链表(Easy)剑指 Offer II 026. 重排链表(Medium)剑指 Offer II 077. 链表排序(Medium)","link":"/2021/08/29/LeetCode/%E9%93%BE%E8%A1%A8/"},{"title":"Colab使用","text":"Google Colab。这里只是介绍一些初级的使用技巧，其它的使用技巧在后续的学习过程中记录。 1 准备工作1.1 新建Colab文件 1.2 安装pytorch1! pip install torch torchvision 1.3 挂载Goolge硬盘可以通过shell挂载硬盘，也可以通过可视化界面操作。 1.4 修改当前目录默认情况下当前目录为/content。Google硬盘装载之后的目录为/content/drive/MyDrive。根据自己的需要修改工作目录即可。 12import osos.chdir('/content/drive/MyDrive/learn') 1.4 申请GPU 当需要用到GPU的时候再申请，否则页面下方会有提示。 查看申请到的GPU。 1! nvidia-smi 2 运行代码2.1 直接运行Google Colaboratory2.2 通过Google Colaboratory运行python文件1! python test.py","link":"/2021/08/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Colab/"},{"title":"C++ 初始化方式","text":"list initialization(列表初始化) aggregate initialization(聚合初始化) value initialization(值初始化) default initialization(默认初始化) zero initialization(零值初始化) direct initialization(直接初始化) copy initialization(拷贝初始化) 参考资料What are Aggregates and PODs and how/why are they special?cppreference initializationc++初始化 1. list initialization 常见的几种用法 如果要初始化的变量是aggregate type，利用args对其中的成员逐个进行初始化，如果args不够的话，剩下的成员进行value initialization。 如果要初始化的变量不是aggregate type 用户。 选择合适的构造函数。 \"cppreference 示例\"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt; struct Foo { std::vector&lt;int&gt; mem = {1,2,3}; // list-initialization of a non-static member std::vector&lt;int&gt; mem2; Foo() : mem2{-1, -2, -3} {} // list-initialization of a member in constructor}; std::pair&lt;std::string, std::string&gt; f(std::pair&lt;std::string, std::string&gt; p){ return {p.second, p.first}; // list-initialization in return statement} int main(){ int n0{}; // value-initialization (to zero) int n1{1}; // direct-list-initialization std::string s1{'a', 'b', 'c', 'd'}; // initializer-list constructor call std::string s2{s1, 2, 2}; // regular constructor call std::string s3{0x61, 'a'}; // initializer-list ctor is preferred to (int, char) int n2 = {1}; // copy-list-initialization double d = double{1.2}; // list-initialization of a prvalue, then copy-init auto s4 = std::string{&quot;HelloWorld&quot;}; // same as above, no temporary created since C++17 std::map&lt;int, std::string&gt; m = { // nested list-initialization {1, &quot;a&quot;}, {2, {'a', 'b', 'c'} }, {3, s1} }; std::cout &lt;&lt; f({&quot;hello&quot;, &quot;world&quot;}).first // list-initialization in function call &lt;&lt; '\\n'; const int (&amp;ar)[2] = {1,2}; // binds a lvalue reference to a temporary array int&amp;&amp; r1 = {1}; // binds a rvalue reference to a temporary int// int&amp; r2 = {2}; // error: cannot bind rvalue to a non-const lvalue ref // int bad{1.0}; // error: narrowing conversion unsigned char uc1{10}; // okay// unsigned char uc2{-1}; // error: narrowing conversion Foo f; std::cout &lt;&lt; n0 &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\\n' &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; ' ' &lt;&lt; s3 &lt;&lt; '\\n'; for(auto p: m) std::cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\\n'; for(auto n: f.mem) std::cout &lt;&lt; n &lt;&lt; ' '; for(auto n: f.mem2) std::cout &lt;&lt; n &lt;&lt; ' ';} 2. aggregate initialization\"cppreference 示例\"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;string&gt;#include &lt;array&gt;#include &lt;cstdio&gt; struct S { int x; struct Foo { int i; int j; int a[3]; } b;}; int main(){ S s1 = { 1, { 2, 3, {4, 5, 6} } }; S s2 = { 1, 2, 3, 4, 5, 6}; // same, but with brace elision S s3{1, {2, 3, {4, 5, 6} } }; // same, using direct-list-initialization syntax S s4{1, 2, 3, 4, 5, 6}; // error until CWG 1270: // brace elision only allowed with equals sign int ar[] = {1,2,3}; // ar is int[3] int ab[] (1, 2, 3); // (C++20) ab is int[3]// char cr[3] = {'a', 'b', 'c', 'd'}; // too many initializer clauses char cr[3] = {'a'}; // array initialized as {'a', '\\0', '\\0'} int ar2d1[2][2] = {{1, 2}, {3, 4}}; // fully-braced 2D array: {1, 2} // {3, 4} int ar2d2[2][2] = {1, 2, 3, 4}; // brace elision: {1, 2} // {3, 4} int ar2d3[2][2] = {{1}, {2}}; // only first column: {1, 0} // {2, 0} std::array&lt;int, 3&gt; std_ar2{ {1,2,3} }; // std::array is an aggregate std::array&lt;int, 3&gt; std_ar1 = {1, 2, 3}; // brace-elision okay // int ai[] = { 1, 2.0 }; // narrowing conversion from double to int: // error in C++11, okay in C++03 std::string ars[] = {std::string(&quot;one&quot;), // copy-initialization &quot;two&quot;, // conversion, then copy-initialization {'t', 'h', 'r', 'e', 'e'} }; // list-initialization union U { int a; const char* b; }; U u1 = {1}; // OK, first member of the union// U u2 = { 0, &quot;asdf&quot; }; // error: too many initializers for union// U u3 = { &quot;asdf&quot; }; // error: invalid conversion to int [](auto...) { std::puts(&quot;Garbage unused variables... Done.&quot;); } ( s1, s2, s3, s4, ar, ab, cr, ar2d1, ar2d2, ar2d3, std_ar2, std_ar1, u1 );} // aggregatestruct base1 { int b1, b2 = 42; };// non-aggregatestruct base2 { base2() : b3(42) {} int b3;};// aggregate in C++17struct derived : base1, base2 { int d; };derived d1{ {1, 2}, { }, 4}; // d1.b1 = 1, d1.b2 = 2, d1.b3 = 42, d1.d = 4derived d2{ { }, { }, 4}; // d2.b1 = 0, d2.b2 = 42, d2.b3 = 42, d2.d = 4 3. value initialization 当使用{}对初始化聚合类型(aggreagate type)的变量 进行aggregate initailization，而不是value initialization。 内置类型 直接进行zero initialzation。 数组类型 对数组的成员逐个进行value initialization。 类类型 如果存在用户自定义的默认构造函数，直接调用默认构造函数。 如果存在编译器合成的默认构造函数，先对非静态成员进行zero initialization，再调用合成的默认构造函数。 如果不存在默认构造函数，但是存在形参为std::initialization_list的构造函数，则进行list initialization。 \"cppreference 示例\"123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt; struct T1{ int mem1; std::string mem2;}; // implicit default constructor struct T2{ int mem1; std::string mem2; T2(const T2&amp;) { } // user-provided copy constructor}; // no default constructor struct T3{ int mem1; std::string mem2; T3() { } // user-provided default constructor}; std::string s{}; // class =&gt; default-initialization, the value is &quot;&quot; int main(){ int n{}; // scalar =&gt; zero-initialization, the value is 0 double f = double(); // scalar =&gt; zero-initialization, the value is 0.0 int* a = new int[10](); // array =&gt; value-initialization of each element // the value of each element is 0 T1 t1{}; // class with implicit default constructor =&gt; // t1.mem1 is zero-initialized, the value is 0 // t1.mem2 is default-initialized, the value is &quot;&quot;// T2 t2{}; // error: class with no default constructor T3 t3{}; // class with user-provided default constructor =&gt; // t3.mem1 is default-initialized to indeterminate value // t3.mem2 is default-initialized, the value is &quot;&quot; std::vector&lt;int&gt; v(3); // value-initialization of each element // the value of each element is 0 std::cout &lt;&lt; s.size() &lt;&lt; ' ' &lt;&lt; n &lt;&lt; ' ' &lt;&lt; f &lt;&lt; ' ' &lt;&lt; a[9] &lt;&lt; ' ' &lt;&lt; v[2] &lt;&lt; '\\n'; std::cout &lt;&lt; t1.mem1 &lt;&lt; ' ' &lt;&lt; t3.mem1 &lt;&lt; '\\n'; delete[] a;} 4 default initialization \"cppreference 示例\"1234567891011121314151617181920212223242526#include &lt;string&gt; struct T1 { int mem; }; struct T2{ int mem; T2() { } // &quot;mem&quot; is not in the initializer list}; int n; // static non-class, a two-phase initialization is done: // 1) zero initialization initializes n to zero // 2) default initialization does nothing, leaving n being zero int main(){ int n; // non-class, the value is indeterminate std::string s; // class, calls default ctor, the value is &quot;&quot; (empty string) std::string a[2]; // array, default-initializes the elements, the value is {&quot;&quot;, &quot;&quot;}// int&amp; r; // error: a reference// const int n; // error: a const non-class// const T1 t1; // error: const class with implicit default ctor T1 t1; // class, calls implicit default ctor const T2 t2; // const class, calls the user-provided default ctor // t2.mem is default-initialized (to indeterminate value)} 5 zero initialization 常见的用法如下。 静态内存中的变量，使用零值初始化。 1static int i; // i = 0 作为值初始化过程的一部分。 12345678910111213141516171819202122232425 A a{}; // 调用编译器合成的默认构造函数之前，先对非静态变量进行零值初始化 ``` - 当字符数组的长度大于字符字面量的长度，剩余部分进行零值初始化。 ```c++ char arr[5] = &quot;1&quot;; // arr = {'1', '0', '0', '0', '0'} ``` ```c++ &quot;cppreference 示例&quot;#include &lt;string&gt;#include &lt;iostream&gt; struct A { int a,b,c;}; double f[3]; // 全局变量 =&gt; 零值初始化 =&gt; 数组中所有元素的值都为 0.0int* p; // 全局变量 =&gt; 零值初始化 =&gt; p == nullptrstd::string s; // step 1. 全局变量 =&gt; 零值初始化 =&gt; 类中内置类型的变量初始化为 0 // step 2. 类变量 =&gt; 默认初始化int main(int argc, char*[]){ delete p; // 因为 p == nullptr，所以是安全的 static int n = argc; // zero-initialized to 0 then copy-initialized to argc A a = A(); // 先值初始化一个临时对象，再通过拷贝创建 a (c++11)} 6. direct initialization \"cppreference 示例\"123456789101112131415161718192021222324#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;memory&gt; struct Foo { int mem; explicit Foo(int n) : mem(n) {}}; int main(){ std::string s1(&quot;test&quot;); // constructor from const char* std::string s2(10, 'a'); std::unique_ptr&lt;int&gt; p(new int(1)); // OK: explicit constructors allowed// std::unique_ptr&lt;int&gt; p = new int(1); // error: constructor is explicit Foo f(2); // f is direct-initialized: // constructor parameter n is copy-initialized from the rvalue 2 // f.mem is direct-initialized from the parameter n// Foo f2 = 2; // error: constructor is explicit std::cout &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; ' ' &lt;&lt; *p &lt;&lt; ' ' &lt;&lt; f.mem &lt;&lt; '\\n';} 7. copy initialization \"cppreference 示例\"12345678910111213141516171819202122232425262728293031323334353637#include &lt;string&gt;#include &lt;utility&gt;#include &lt;memory&gt; struct A { operator int() { return 12;}}; struct B { B(int) {}}; int main(){ std::string s = &quot;test&quot;; // OK: constructor is non-explicit std::string s2 = std::move(s); // this copy-initialization performs a move // std::unique_ptr&lt;int&gt; p = new int(1); // error: constructor is explicit std::unique_ptr&lt;int&gt; p(new int(1)); // OK: direct-initialization int n = 3.14; // floating-integral conversion const int b = n; // const doesn't matter int c = b; // ...either way A a; B b0 = 12;// B b1 = a; //&lt; error: conversion from 'A' to non-scalar type 'B' requested B b2{a}; // &lt; identical, calling A::operator int(), then B::B(int) B b3 = {a}; // &lt; auto b4 = B{a}; // &lt; // b0 = a; //&lt; error, assignment operator overload needed } 注意拷贝初始化可能被编译器优化，这时它与直接初始化的过程没有区别。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A {public: A () { cout &lt;&lt; &quot;&lt;default ctor&gt;\\n&quot;; } A (int data) : data_(data) { cout &lt;&lt; &quot;&lt;ctor&gt;\\n&quot;; } A (A const &amp;) { cout &lt;&lt; &quot;&lt;copy ctor&gt;\\n&quot;; }private: int data_; };int main() { A a(1); A a2 = A(1); return 0;} 不同的编译器参数，输出不同。C++11在这种情况下会对拷贝初始化进行优化，直接调用构造函数创建a2。通过设置编译器参数可以取消优化，但是c++17标准下，似乎拷贝构造函数被构造函数取代。 -std=c++11 12&lt;ctor&gt;&lt;ctor&gt; -std=c++11 -fno-elide-constructors 123&lt;ctor&gt;&lt;ctor&gt;&lt;copy ctor&gt; -std=c++17 12&lt;ctor&gt;&lt;ctor&gt; -std=c++17 -fno-elide-constructors 12&lt;ctor&gt;&lt;ctor&gt;","link":"/2021/04/11/Cpp/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/"},{"title":"引用本地图片","text":"在hexo博客中引用本地图片 npm hexo-asset-image --save 替换/node_modules/hexo-asset-image/index.js内容 修改_config.xml 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg 1. npm hexo-asset-image --save2. 替换/node_modules/hexo-asset-image/index.js内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) { return str.split(m, i).join(m).length;}var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function (data) { var config = hexo.config; if (config.post_asset_folder) { var link = data.permalink; if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for (var i = 0; i &lt; toprocess.length; i++) { var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function () { if ($(this).attr('src')) { // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if (!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) { // For &quot;about&quot; page, the first part of &quot;src&quot; can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function (elem) { return elem != ''; }); var srcArray = src.split('/').filter(function (elem) { return elem != '' &amp;&amp; elem != '.'; }); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + config.root + link + src); } } else { console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); } }); data[key] = $.html(); } }}); 3. 修改_config.xml4. 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg","link":"/2021/04/12/others/%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"},{"title":"博客搭建指南","text":"平台本博客网站的平台如下。 Hexo Icarus Gitee 搭建 HexoHexo 官网为了搭建 Hexo 环境, 用户需要先配置好 Node.js 以及 Git 环境。 新建一个文件夹，用来存放项目文件 进入该文件夹, 打开 Git Bash hexo init npm install npm install hexo-deployer-git --save hexo g hexo s 1npm install 可能针对某个特定的包报错, 可以先安装报错的包[npm install xxx --ignore-scripts] 切换 Icarus 主题Icarus 官方文档 Gitte Page 完成同步 创建 gitte 账户, 并添加本地主机的 ssh 公钥1234// Gittessh -T git@gitte.com// Githubssh -T git@github.com 修改_config.yml配置文件12345deploy: type: git # 可以指定多个 repo repo: git@gitee.com:chengming0313/chengming0313.git branch: master hexo d上传静态文件(.deploy_git) Gitte 新建分支 hexo hexo 设为默认分支 git clone xxx只保留.git文件夹, 删除其它所有文件夹 将博客的源文件复制过来(除了 .deploy_git)记得删除 themes 下主题里的 .git文件夹 上传源文件到 hexo 分支123git add .git commit -m &quot;init&quot;git push 更换本地主机 git clone xxx npm install npm install hexo-deployer-git --save hexo g hexo s hexo d","link":"/2021/04/06/others/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"},{"title":"字符集和字符编码","text":"Unicode与utf-8有什么联系又有什么区别？ C++与Python3内部对字符的处理方式有什么区别？ Unicode 是一个统一的字符集。最新的版本为2020年3月公布的13.0.0，已经收录超过13万个字符。 常用的字符，只需要2个字节来存储。 计算机系统内部大多直接存储字符的unicode编码，例如剪贴板保存的就是字符的unicode编码，因此从gbk编码复制文本到utf-8编码的文件，不会产生乱码。 python3中的字符串 python3没有字符类型，只有字符串类型。 python3中str代表字符流，里面的字符都保存为unicode格式。而bytes代表字节流，它对应特定的编码。 123456# 你好hello_str = '你好' # b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd' hello_str_utf8 = hello_str.encode('utf-8')# b'\\xc4\\xe3\\xba\\xc3'hello_str_gbk = hello_str.encode('gbk') python3文件中经常可以看到# -*- coding: utf-8 -*-，这句话是规定python解释器的解码格式为utf-8。注意这句话不会改变源文件本身的编码格式，它改变的只是python解释器的解码格式。例如原本是gbk编码，而python解释器却按照utf-8解读源文件。 C++中的字符串 C++中char代表1个字节，而不是1个字符。std::string中代表字节流。 123// utf-8// e4 bd a0 e5 a5 bdstd::string str{&quot;你好&quot;}; utf-8 单字节字符的最高有效比特永远为0。 多字节序列中的首个字符组的几个最高有效比特决定了序列的长度。最高有效位为110的是2字节序列，而1110的是三字节序列，如此类推。 多字节序列中其余的字节中的首两个最高有效比特为10 BOMBOM是指byte-order mark，文件头部用来指示文件字符编码的字节序。utf-8实际上不需要BOM，因为它的编码规则不会产生误解。 例如你的utf-8编码为\\xe4\\xbd\\xa0，它的二进制表示为11100100, 10111101, 10100000。不管它是大端法还是小端法保存，最终结果一定是\\xe4\\xbd\\xa0，因为其它的结果对utf-8编码来说都是非法的。 参考资料UnicodeUTF-8字节顺序标记","link":"/2021/09/01/others/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"title":"【LeetCode】二叉树","text":"二叉树结点类型 \"c++\"12345678struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}}; 遍历二叉树知识点 二叉树的深度优先搜索分为先序遍历、中序遍历以及后序遍历。 先序遍历：根结点-&gt;左子树-&gt;右子树中序遍历：左子树-&gt;根结点-&gt;右子树后序遍历：左子树-&gt;右子树-&gt;根结点 递归序遍历：1-&gt;2-&gt;4-&gt;4-&gt;4-&gt;2-&gt;5-&gt;5-&gt;5-&gt;2-&gt;1-&gt;3-&gt;6-&gt;6-&gt;6-&gt;3-&gt;7-&gt;7-&gt;7-&gt;3-&gt;1先序遍历：1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6-&gt;7中序遍历：4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7后序遍历：4-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1广度优先：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 二叉树的遍历(搜索)主要有4种。深度优先搜索需要掌握递归写法和跌倒写法。而广度优先搜索只需要掌握迭代写法。 深度优先搜索 前序遍历 中序遍历 后序遍历 广度优先搜索(层序遍历) 144. 二叉树的前序遍历(Easy) 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。最好情况下为O(logN)$。最坏情况为$O(N)$，此时二叉树呈链式分布。 递归写法 \"c++\" >folded123456789101112131415161718class Solution {public: void traversal(TreeNode *root, vector&lt;int&gt; &amp;ans) { if (root == nullptr) { return; } // 第一次访问根结点时保存它 ans.push_back(root-&gt;val); traversal(root-&gt;left, ans); traversal(root-&gt;right, ans); } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; traversal(root, ans); return ans; }}; 迭代写法 \"c++\" >folded1234567891011121314151617181920class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; stack&lt;TreeNode *&gt; nodeStack; auto cur = root; while (cur || !nodeStack.empty()) { while (cur) { ans.emplace_back(cur-&gt;val); nodeStack.emplace(cur); cur = cur-&gt;left; } auto prev = nodeStack.top(); nodeStack.pop(); cur = prev-&gt;right; } return ans; }}; 94. 二叉树的中序遍历(Easy) 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。最好情况下为O(logN)$。最坏情况为$O(N)$，此时二叉树呈链式分布。 递归写法 \"c++\" >folded123456789101112131415161718class Solution {public: void traversal(TreeNode *root, vector&lt;int&gt; &amp;ans) { if (root == nullptr) { return; } traversal(root-&gt;left, ans); // 第二次访问根结点时保存它 ans.push_back(root-&gt;val); traversal(root-&gt;right, ans); } vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; traversal(root, ans); return ans; }}; 迭代写法 \"c++\" >folded1234567891011121314151617181920class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; stack&lt;TreeNode *&gt; nodeStack; auto cur = root; while (cur || !nodeStack.empty()) { while (cur) { nodeStack.push(cur); cur = cur-&gt;left; } cur = nodeStack.top(); nodeStack.pop(); ans.emplace_back(cur-&gt;val); cur = cur-&gt;right; } return ans; }}; 145. 二叉树的后序遍历(Easy) 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。最好情况下为O(logN)$。最坏情况为$O(N)$，此时二叉树呈链式分布。 递归写法 \"c++\" >folded123456789101112131415161718class Solution {public: void traversal(TreeNode *root, vector&lt;int&gt; &amp;ans) { if (root == nullptr) { return; } traversal(root-&gt;left, ans); traversal(root-&gt;right, ans); // 第三次访问根结点时保存它 ans.push_back(root-&gt;val); } vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; traversal(root, ans); return ans; }}; 迭代写法 \"c++\" >folded12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; stack&lt;TreeNode *&gt; nodeStack; TreeNode *cur = root, *prev = nullptr; while (cur || !nodeStack.empty()) { while (cur) { nodeStack.emplace(cur); cur = cur-&gt;left; } cur = nodeStack.top(); if (cur-&gt;right == nullptr || cur-&gt;right == prev) { ans.emplace_back(cur-&gt;val); nodeStack.pop(); prev = cur; // 最近保存的结点为 cur cur = nullptr; // 不需要访问左边界 } else { // 后序遍历 cur 的右子树 cur = cur-&gt;right; } } return ans; }}; 102. 二叉树的层序遍历这里需要将二叉树的结点按层次分开保存，因此在大循环中添加了一个循环size次的小循环，对时间复杂度没有影响。 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。 \"c++\" >folded123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { if (root == nullptr) { return {}; } vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; subAns; queue&lt;TreeNode *&gt; nodeQueue; nodeQueue.emplace(root); while (!nodeQueue.empty()) { int size = nodeQueue.size(); subAns.reserve(size); for (int i = 0; i &lt; size; ++i) { auto cur = nodeQueue.front(); nodeQueue.pop(); subAns.emplace_back(cur-&gt;val); if (cur-&gt;left) { nodeQueue.emplace(cur-&gt;left); } if (cur-&gt;right) { nodeQueue.emplace(cur-&gt;right); } } ans.emplace_back(std::move(subAns)); subAns.clear(); } return ans; }}; 589. N 叉树的前序遍历(Easy)\"c++\" >folded123456789101112131415161718class Solution {public: void traversal(Node *root, vector&lt;int&gt; &amp;ans) { if (root == nullptr) { return; } ans.emplace_back(root-&gt;val); for (auto child : root-&gt;children) { traversal(child, ans); } } vector&lt;int&gt; preorder(Node* root) { vector&lt;int&gt; ans; traversal(root, ans); return ans; }}; 226. 翻转二叉树(Easy) 分析题意，该题可以从两个角度去理解。 后序遍历的变形题。翻转root树的步骤可以这样分解：先翻转root-&gt;left树，再翻转root-&gt;right树，最后交换左右子树即可。 前序遍历的变形题。翻转root树的步骤可以这样分解：先交换左右子树，再翻转root-&gt;left树，最后翻转root-&gt;right树。 时间复杂度：$O(N)$。 空间复杂度：$O(N)$。平均情况为$O(logN)$。 后序遍历 \"c++\" >folded1234567891011121314class Solution {public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) { return nullptr; } invertTree(root-&gt;right); invertTree(root-&gt;left); auto aux = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = aux; return root; }}; \"python3\" >folded12345678class Solution:def invertTree(self, root: TreeNode) -&gt; TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root 前序遍历 \"c++\" >folded1234567891011121314class Solution {public: TreeNode *invertTree(TreeNode *root) { if (root == nullptr) { return nullptr; } auto aux = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = aux; invertTree(root-&gt;left); invertTree(root-&gt;right); return root; }}; \"python3\" >folded12345678class Solution:def invertTree(self, root: TreeNode) -&gt; TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root 116. 填充每个节点的下一个右侧节点指针 暴力递归 单独的对root的左子树或者右子树进行单个结点的递归不能够完成任务。因此每次对两个节点进行递归。尽管存在部分next连接被重复建立，但不影响总体的时间复杂度。 时间复杂度：$O(N)$。 空间复杂度：$O(logN)$。 \"c++\" >folded1234567891011121314151617181920class Solution {public: Node* connect(Node* root) { if (root == nullptr) { return nullptr; } connectTwoNode(root-&gt;left, root-&gt;right); return root; } void connectTwoNode(Node *node1, Node *node2) { if (node1 == nullptr || node2 == nullptr) { return; } node1-&gt;next = node2; connectTwoNode(node1-&gt;left, node1-&gt;right); connectTwoNode(node2-&gt;left, node2-&gt;right); connectTwoNode(node1-&gt;right, node2-&gt;left); }}; 层序遍历(广度优先遍历) 该题需要建立每层结点之间的连接，因此层序遍历能够完成任务。但是这题要求$O(1)$的额外空间复杂度，因此还不够好。 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。完美二叉树的最大宽度为$(N + 1) / 2$。 \"c++\" >folded123456789101112131415161718192021222324252627class Solution {public: Node* connect(Node* root) { if (root == nullptr) { return nullptr; } queue&lt;Node *&gt; nodeQueue; nodeQueue.emplace(root); while (!nodeQueue.empty()) { int size = nodeQueue.size(); for (int i = 0; i &lt; size; ++i) { auto cur = nodeQueue.front(); nodeQueue.pop(); if (i &lt; size - 1) { cur-&gt;next = nodeQueue.front(); } if (cur-&gt;left) { nodeQueue.emplace(cur-&gt;left); } if (cur-&gt;right) { nodeQueue.emplace(cur-&gt;right); } } } return root; }}; 最优解 利用该题二叉树中存在的next指针可以优化层序遍历。 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 \"c++\" >folded12345678910111213141516171819class Solution {public: Node* connect(Node* root) { if (root == nullptr) { return root; } // 利用 next 指针遍历第 i - 1 层 for (auto start = root; start-&gt;left; start = start-&gt;left) { // 通过第 i - 1 层构建第 i 层的 next 指针 for (auto cur = start; cur; cur = cur-&gt;next) { cur-&gt;left-&gt;next = cur-&gt;right; if (cur-&gt;next) { cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; } } } return root; }}; 114. 二叉树展开为链表(Medium) 递归 时间复杂度：$O(N^2)$。 空间复杂度：$O(N)$。 \"c++\" >folded123456789101112131415161718192021class Solution {public: void flatten(TreeNode* root) { if (root == nullptr) { return; } flatten(root-&gt;left); flatten(root-&gt;right); // 如果左子树为空树，不需要将左子树插入右子树 if (root-&gt;left == nullptr) { return; } auto leftTail = root-&gt;left; while (leftTail-&gt;right) { leftTail = leftTail-&gt;right; } leftTail-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = nullptr; }}; 654. 最大二叉树(Medium) 递归 在前序遍历的模板上修改即可。 时间复杂度：$O(N^2)$。每个树结点都要调用一次constructMaximumBinaryTree来创建当前结点。平均情况下时间复杂度为$O(NlogN)$。最坏情况下为$O(N^2)$。 额外空间复杂度：$O(N)$。平均情况下为$O(logN)$。最坏情况下为$O(N)$。 \"c++\" >folded123456789101112131415161718192021class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { int n = static_cast&lt;int&gt;(nums.size()); return constructMaximumBinaryTree(nums, 0, n); } TreeNode *constructMaximumBinaryTree(vector&lt;int&gt; const &amp;nums, int first, int last) { if (first == last) { return nullptr; } int maxIndex = first; for (int i = first + 1; i &lt; last; ++i) { maxIndex = nums[i] &gt; nums[maxIndex] ? i : maxIndex; } auto root = new TreeNode(nums[maxIndex]); root-&gt;left = constructMaximumBinaryTree(nums, first, maxIndex); root-&gt;right = constructMaximumBinaryTree(nums, maxIndex + 1, last); return root; }}; 105. 从前序与中序遍历序列构造二叉树(Medium) 递归 在前序遍历的模板上修改即可。 时间复杂度：$O(N^2)$。平均情况下时间复杂度为$O(NlogN)$。最坏情况下为$O(N^2)$，此时二叉树中所有右子树为空树。 额外空间复杂度：$O(N)$。平均情况下为$O(logN)$。最坏情况下为$O(N)$。 \"c++\" >folded12345678910111213141516171819202122232425262728class Solution {public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { int n = static_cast&lt;int&gt;(preorder.size()); return buildTree(preorder, inorder, 0, n, 0, n); } TreeNode *buildTree(vector&lt;int&gt; const &amp;preorder, vector&lt;int&gt; const &amp;inorder, int preFirst, int preLast, int inFirst, int inLast) { // 前序遍历序列为空，返回空树 if (preLast == preFirst) { return nullptr; } int rootVal = preorder[preFirst]; // 确定根结点在中序遍历中的位置 int rootPos = inFirst; while (rootPos &lt; inLast &amp;&amp; inorder[rootPos] != rootVal) { ++rootPos; } // 计算左子树长度与右子树长度 int leftLen = rootPos - inFirst; int rightLen = inLast - rootPos - 1; auto root = new TreeNode(rootVal); root-&gt;left = buildTree(preorder, inorder, preFirst + 1, preFirst + leftLen + 1, inFirst, rootPos); root-&gt;right = buildTree(preorder, inorder, preLast - rightLen, preLast, rootPos + 1, inLast); return root; }}; 106. 从中序与后序遍历序列构造二叉树(Medium) 递归 在前序遍历的模板上修改即可。 时间复杂度：$O(N)$。引入哈希表取代普通的线性查找，将时间复杂度优化至$O(N)$。 额外空间复杂度：$O(N)$。包括哈希表以及递归栈，哈希表的大小为$O(N)$，递归栈的大小不会超过$O(N)$。 \"c++\" >folded123456789101112131415161718192021222324252627282930class Solution {public: static unordered_map&lt;int, int&gt; inorderNodeMap; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { int n = static_cast&lt;int&gt;(inorder.size()); // 中序遍历序列 &lt;nodeVal, index&gt; for (int i = 0; i &lt; n; ++i) { inorderNodeMap[inorder[i]] = i; } return buildTree(inorder, postorder, 0, n, 0, n); } TreeNode *buildTree(vector&lt;int&gt; const &amp;inorder, vector&lt;int&gt; const &amp;postorder, int inFirst, int inLast, int postFirst, int postLast) { if (inFirst == inLast) { return nullptr; } int rootVal = postorder[postLast - 1]; int rootIndex = inorderNodeMap[rootVal]; int leftLen = rootIndex - inFirst; int rightLen = inLast - rootIndex - 1; auto root = new TreeNode(rootVal); root-&gt;left = buildTree(inorder, postorder, inFirst, rootIndex, postFirst, postFirst + leftLen); root-&gt;right = buildTree(inorder, postorder, rootIndex + 1, inLast, postLast - 1 - rightLen, postLast - 1); return root; }};unordered_map&lt;int, int&gt; Solution::inorderNodeMap; 297. 二叉树的序列化与反序列化(Hard) 深度优先搜索 前序遍历 时间复杂度：$O(N)$。 空间复杂度：$O(N)$。 \"c++\" >folded12345678910111213141516171819202122232425262728293031323334353637383940class Codec {public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string ans; serialize(root, ans); return ans; } void serialize(TreeNode *root, string &amp;ans) { if (root == nullptr) { ans.append(&quot;nullptr &quot;); return; } ans.append(to_string(root-&gt;val) + &quot; &quot;); serialize(root-&gt;left, ans); serialize(root-&gt;right, ans); } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { stringstream ss(data); return deserialize(ss); } TreeNode *deserialize(stringstream &amp;ss) { string tmp; if (ss &gt;&gt; tmp) { if (tmp == &quot;nullptr&quot;) { return nullptr; } auto node = new TreeNode(stoi(tmp)); node-&gt;left = deserialize(ss); node-&gt;right = deserialize(ss); return node; } return nullptr; }}; 后序遍历 时间复杂度：$O(N)$。 空间复杂度：$O(N)$。 \"c++\" >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Codec {public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string ans; serialize(root, ans); return ans; } void serialize(TreeNode *root, string &amp;ans) { if (root == nullptr) { ans.append(&quot;# &quot;); return; } serialize(root-&gt;left, ans); serialize(root-&gt;right, ans); // 为了方便处理，将结点的值翻转之后再放入 auto tmp = to_string(root-&gt;val); ans.append(string(tmp.crbegin(), tmp.crend()) + &quot; &quot;); } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { // 后序遍历序列化的字符串顺序为 左子树 -&gt; 右子树 -&gt; 根节点 // 将它翻转为 根节点 -&gt; 右子树 -&gt; 左子树 stringstream ss(string(data.crbegin(), data.crend())); return deserialize(ss); } TreeNode *deserialize(stringstream &amp;ss) { string tmp; ss &gt;&gt; tmp; // 如果反序列化一个空树，直接返回 nullptr if (tmp == &quot;#&quot;) { return nullptr; } // 构造根节点 auto root = new TreeNode(stoi(tmp)); // 先反序列化右子树 root-&gt;right = deserialize(ss); // 再反序列化左子树 root-&gt;left = deserialize(ss); return root; }}; 广度优先搜索 时间复杂度：$O(N)$。 空间复杂度：$O(N)$。 \"c++\" >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Codec {public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string ans; if (root == nullptr) { ans.append(&quot;# &quot;); return ans; } queue&lt;TreeNode *&gt; nodeQueue; nodeQueue.push(root); while (!nodeQueue.empty()) { auto node = nodeQueue.front(); nodeQueue.pop(); // 将节点的值序列化 if (node == nullptr) { ans.append(&quot;# &quot;); continue; } ans.append(to_string(node-&gt;val) + &quot; &quot;); nodeQueue.push(node-&gt;left); nodeQueue.push(node-&gt;right); } return ans; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { stringstream ss(data); string nodeVal; ss &gt;&gt; nodeVal; if (nodeVal == &quot;#&quot;) { return nullptr; } auto root = new TreeNode(stoi(nodeVal)); queue&lt;TreeNode *&gt; nodeQueue; nodeQueue.push(root); while (!nodeQueue.empty()) { auto cur = nodeQueue.front(); nodeQueue.pop(); string left, right; ss &gt;&gt; left &gt;&gt; right; if (left != &quot;#&quot;) { auto leftNode = new TreeNode(stoi(left)); cur-&gt;left = leftNode; nodeQueue.push(leftNode); } if (right != &quot;#&quot;) { auto rightNode = new TreeNode(stoi(right)); cur-&gt;right = rightNode; nodeQueue.push(rightNode); } } return root; }}; 652. 寻找重复的子树(Medium) 序列化+哈希表 时间复杂度：$O(N^2)$。 空间复杂度：$O(N^2)$。 \"c++\" >folded1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: string serialize(TreeNode *root) { string ans; serialize(root, ans); return ans; } void serialize(TreeNode *root, string &amp;ans) { if (root == nullptr) { ans.append(&quot;# &quot;); return; } ans.append(to_string(root-&gt;val) + &quot; &quot;); serialize(root-&gt;left, ans); serialize(root-&gt;right, ans); } vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) { unordered_map&lt;string, int&gt; treeCountMap; vector&lt;TreeNode *&gt; ans; traverse(root, treeCountMap, ans); return ans; } void traverse(TreeNode *root,unordered_map&lt;string, int&gt; &amp;treeCountMap, vector&lt;TreeNode *&gt; &amp;ans) { if (root == nullptr) { return; } string treeStr = serialize(root); if (treeCountMap[treeStr] == 1) { ans.push_back(root); } ++treeCountMap[treeStr]; traverse(root-&gt;left, treeCountMap, ans); traverse(root-&gt;right, treeCountMap, ans); }}; 662. 二叉树最大宽度(Medium)注意完全二叉树父节点与左右孩子结点之间的序号存在关系。 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。 \"c++\" >folded12345678910111213141516171819202122232425262728class Solution {public: int widthOfBinaryTree(TreeNode* root) { if (root == nullptr) { return 0; } queue&lt;pair&lt;TreeNode *, int&gt;&gt; nodeQueue; nodeQueue.emplace(root, 0); int maxWidth = 0; while (!nodeQueue.empty()) { int size = nodeQueue.size(); int begin = nodeQueue.front().second, end = 0; for (int i = 0; i &lt; size; ++i) { auto cur = nodeQueue.front(); nodeQueue.pop(); end = cur.second; if (cur.first-&gt;left) { nodeQueue.emplace(cur.first-&gt;left, end * 2 - begin * 2); } if (cur.first-&gt;right) { nodeQueue.emplace(cur.first-&gt;right, end * 2 - begin * 2 + 1); } } maxWidth = max(maxWidth, end - begin + 1); } return maxWidth; }}; 103. 二叉树的锯齿形层序遍历(Medium) 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。 \"c++\" >folded1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { if (root == nullptr) { return {}; } vector&lt;vector&lt;int&gt;&gt; ans; deque&lt;int&gt; subAns; queue&lt;TreeNode *&gt; nodeQueue; nodeQueue.emplace(root); int curDepth = 0; while (!nodeQueue.empty()) { ++curDepth; int size = nodeQueue.size(); for (int i = 0; i &lt; size; ++i) { auto cur = nodeQueue.front(); nodeQueue.pop(); if (curDepth &amp; 1) { subAns.emplace_back(cur-&gt;val); } else { subAns.emplace_front(cur-&gt;val); } if (cur-&gt;left) { nodeQueue.emplace(cur-&gt;left); } if (cur-&gt;right) { nodeQueue.emplace(cur-&gt;right); } } ans.emplace_back(subAns.cbegin(), subAns.cend()); subAns.clear(); } return ans; }}; 104. 二叉树的最大深度(Easy) 深度优先搜索 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。 递归写法 \"c++\" >folded123456789class Solution {public: int maxDepth(TreeNode* root) { if (root == nullptr) { return 0; } return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; }}; 迭代写法 在迭代版后序遍历的基础上修改即可。 \"c++\" >folded123456789101112131415161718192021222324252627class Solution {public: int maxDepth(TreeNode* root) { stack&lt;TreeNode *&gt; nodeStack; unordered_map&lt;TreeNode *, int&gt; depthMap; TreeNode *cur = root, *prev = nullptr; while (cur || !nodeStack.empty()) { while (cur) { nodeStack.emplace(cur); cur = cur-&gt;left; } cur = nodeStack.top(); if (cur-&gt;right == nullptr || cur-&gt;right == prev) { // 计算 cur 的深度 int leftDepth = cur-&gt;left ? depthMap[cur-&gt;left] : 0; int rightDepth = cur-&gt;right ? depthMap[cur-&gt;right] : 0; depthMap[cur] = max(leftDepth, rightDepth) + 1; nodeStack.pop(); prev = cur; cur = nullptr; } else { cur = cur-&gt;right; } } return root ? depthMap[root] : 0; }}; 广度优先搜索 时间复杂度：$O(N)$。 额外空间复杂度：$O(N)$。 \"c++\" >folded1234567891011121314151617181920212223242526class Solution {public: int maxDepth(TreeNode* root) { if (root == nullptr) { return 0; } queue&lt;TreeNode *&gt; nodeQueue; nodeQueue.emplace(root); int depth = 0; while (!nodeQueue.empty()) { int size = nodeQueue.size(); ++depth; for (int i = 0; i &lt; size; ++i) { auto cur = nodeQueue.front(); nodeQueue.pop(); if (cur-&gt;left) { nodeQueue.emplace(cur-&gt;left); } if (cur-&gt;right) { nodeQueue.emplace(cur-&gt;right); } } } return depth; }}; 剑指 Offer 55 - I. 二叉树的深度(Easy)满二叉树 如何判断一棵树是否是满二叉树？ 完全二叉树 如何判断一棵二叉树是否是完全二叉树？ 层序遍历二叉树。完全二叉树中遍历到的结点一定满足以下两个条件。 二叉搜索树 如何判断一棵树是否是搜索二叉树？ 搜索二叉树中序遍历得到的序列一定是一个非下降序列。因此我们只需要在中序遍历的代码上进行修改即可完成判断。 平衡二叉树树型DP 递归获取左子树的信息以及右子树的信息，根据左子树的信息以及右子树的信息返回该树的信息。","link":"/2021/09/11/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Gitee","slug":"Gitee","link":"/tags/Gitee/"},{"name":"计算机系统","slug":"计算机系统","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"离散数学","slug":"离散数学","link":"/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"严格弱序关系","slug":"严格弱序关系","link":"/tags/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E5%85%B3%E7%B3%BB/"},{"name":"Demo","slug":"Demo","link":"/tags/Demo/"},{"name":"C++ primer","slug":"C-primer","link":"/tags/C-primer/"},{"name":"LinuxC 系统开发","slug":"LinuxC-系统开发","link":"/tags/LinuxC-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"Colab","slug":"Colab","link":"/tags/Colab/"},{"name":"SSH工具","slug":"SSH工具","link":"/tags/SSH%E5%B7%A5%E5%85%B7/"},{"name":"字符集和字符编码","slug":"字符集和字符编码","link":"/tags/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"深入理解计算机系统","slug":"深入理解计算机系统","link":"/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"C++ Primer 5th","slug":"C-Primer-5th","link":"/categories/C-Primer-5th/"},{"name":"Linux系统编程","slug":"Linux系统编程","link":"/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]}