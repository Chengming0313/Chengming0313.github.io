{"pages":[],"posts":[{"title":"ch02","text":"信息的表示和处理计算机通过有限个二进制位完成对信息的编码，当有限个二进制位不足以表示某个信息时，就会发生溢出（overflow）。 无符号编码 补码（带符号编码） 浮点数编码 整数运算和浮点数运算 整数运算是精确的，整数编码的范围较小。 浮点数运算是近似的，浮点数编码的范围较大。 12345678910// 整数运算，运算顺序不同，溢出的结果相同，是可以std::cout &lt;&lt; 500 * 400 * 300 * 200 &lt;&lt; std::endl;std::cout &lt;&lt; 500 * (400 * 300) * 200 &lt;&lt; std::endl;std::cout &lt;&lt; 500 * 400 * (300 * 200) &lt;&lt; std::endl;std::cout &lt;&lt; 200 * 300 * 400 * 500 &lt;&lt; std::endl;// 浮点数运算不可结合std::cout &lt;&lt; (3.14 + 1e20) - 1e20 &lt;&lt; std::endl;std::cout &lt;&lt; 3.14 + 1e20 - 1e20 &lt;&lt; std::endl;std::cout &lt;&lt; 3.14 + (1e20 - 1e20) &lt;&lt; std::endl; 1234567-884901888-884901888-884901888-884901888003.14","link":"/2021/07/26/CSAPP/ch02/"},{"title":"第13章 拷贝控制","text":"引言 任何类（Class、struct）都需要定义拷贝控制操作，程序员没有定义的拷贝控制操作，编译器会自动合成（定义）缺失的拷贝控制操作。 拷贝控制操作主要分为三类： 同类型的另一个对象来完成某对象的初始化：拷贝构造函数(copy ctor)以及移动构造函数(move ctor) 用同类型的另一个对象来给某对象赋值：拷贝赋值运算符(copy op=)以及移动赋值运算符(move op=) 此类型的对象销毁时：析构函数(dtor) 1 copy ctor、copy op=、dtor1.1 copy ctor1.1.1 概念与性质 copy ctor：如果一个ctor，它的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，这个ctor就是copy ctor。 一般形式：Foo(Foo const &amp;rhs); 2.1 我们可以看到它的第一个参数通常是一个T const &amp;（常量引用）。 2.2 它通常不应该被声明为explicit。 1.1.2 编译器定义的synthesized copy ctor(合成拷贝函数) 两个作用 1.1 阻止copy ctor的调用：Foo(Foo const &amp;rhs) = delete 1.2 依次将另一个对象中的非static数据成员拷贝到需要初始化的对象。 1.1.3 direct init与copy init direct init：使用()直接调用构造函数初始化。 copy init：没有直接用()初始化对象，需要把某对象拷贝正在创建的对象中。 copy init可能发生的场景 3.1 =初始化变量：Foo a = b，b可以是Foo类型，也可以是其它类型，只要能被隐式转换成Foo类型。 3.2 pass by value：将对象作为实参传递给形参为值类型的函数。 例如`STL`中使用`insert`或者`push`，容器会对参数进行拷贝初始化。 使用`emplace`则会进行直接初始化。 3.3 return by value：函数返回一个值类型的对象。 3.4 list init：用{...}初始化一个数组中的元素或者一个聚合类。 1.1.4 编译器的优化可能绕过copy ctorstd::string null_book = &quot;9-999-9999-9&quot; 优化为 std::string null_book(&quot;9-999-9999-9&quot;) 这样从copy init转变为了direct init，调用的是std::string(char const *)，而不是copy ctor。 1.2 copy op=1.2.1 概念与性质 copy op=：本质上是该类重载的赋值运算符中的一种，只是右侧对象为类本身类型。一般都是该类的成员函数。 一般形式：Foo &amp;operator=(Foo const &amp;rhs) 2.1 赋值运算符一般返回指向左侧对象的引用，这样可以完成链式赋值(a = b = c)，copy op=中通过return *this返回左侧对象的引用。 标准库的容器通常要求存储的元素类型要实现copy op=，并且返回左侧对象的引用。 2.2 当类需要手动释放资源时（不能使用synthesized copy op=），copy ctor一定要检查自我赋值是否会出问题。 1.2.2 synthesized copy op=简单的思考1. 为什么copy ctor的参数必须是引用。通常是T const &amp;。如果copy ctor的参数不是引用，而是一个值类型，当第一次调用copy ctor时，我们需要将对象作为实参再次调用copy ctor来传递给拷贝构造函数，这会导致copy ctor的循环调用。 2. 为什么copy ctor不应该被声明为explicit。123explicit Foo(Foo const &amp;rhs) = default; // 合成的 copy ctorFoo b(a); // 正确Foo c = a; // error: no matching function for call to 'Foo::Foo(Foo&amp;)' 当我们使用explicit声明一个拷贝构造函数时，我们无法使用copy init(拷贝初始化)来初始化一个对象。只能使用direct init(直接初始化)。 3. synthesized copy ctor的拷贝流程synthesized copy ctor会拷贝所有的非static数据成员，根据成员类型的不同，采用不同的拷贝方法。 内置类型成员：直接拷贝(int a = b) 类类型成员：调用成员的copy ctor进行拷贝 内置数组类型成员：因为内置数组不能直接拷贝，所以会对数组进行逐元素拷贝。 4. copy op=能够声明为全局函数(global function)吗。","link":"/2021/07/27/CppPrimer5th/ch13/"},{"title":"具名条件：compare","text":"1. 前置知识1.1. 笛卡尔积$$A \\ast B = { (x, y) | x \\in A \\land y \\in B}$$ 1.2. 二元关系二元关系R实质上是有序对的集合. $从A到B的二元关系：R \\subseteq A \\ast B$ $A上的二元关系：R \\subseteq A \\ast A$ $x对y存在二元关系R的符号表示：$$xRy$, $&lt;x, y&gt; \\in R$ 1.3. 二元关系的表示: 列举、描述、关系矩阵、关系图1.4. 特殊的二元关系 $空关系：R = \\varnothing $ $恒等关系：I_A = {&lt;x, x&gt; | x \\in A }$ $全域关系：R = A \\ast B$ 1.5. A上的二元关系的性质 自反性: $\\forall x \\in A, &lt;x, x&gt; \\in A$ 反自反性: $\\forall x \\in A, &lt;x, x&gt; \\notin A$ 对称性: $\\forall x, y \\in A, 如果 &lt;x, y&gt; \\in R, 则 &lt;y, x&gt; \\in R$ 反对称性: $\\forall x, y \\in A, 如果 &lt;x, y&gt; \\in R, &lt;y, x&gt; \\in R, 则 x = y$ 传递性: $\\forall x, y, z \\in A, 如果 &lt;x, y&gt; \\in R, &lt;y, z&gt; \\in A, 则 &lt;x, z&gt; \\in R$ ！！！对称性和反对称性并不对立, 一个A上的二元关系可以既有对称性又有反对称性, 当然也可以都没有. 1.6. 等价关系如果R为A上的二元关系，如果R具备自反性、对称性以及传递性，则R为A上的等价关系（Equivalence Relation） 等价关系中集合元素的等价性 $如果R为等价关系$ $&lt;a, b&gt;\\in R，称a等价于b，记作a\\sim b$ $因为R是对称的，所以a\\sim b即b\\sim a$ 1.7. 偏序关系（Partial order）以及偏序集次序关系: 任务之间存在先后关系 如果R为A上的二元关系，如果R具备自反性、反对称性以及传递性，则R为A上的偏序关系，简称偏序，记作$\\preceq$ A以及A上的偏序关系$\\preceq$一起称作一个偏序集，记为$&lt;A, \\preceq&gt;$ 偏序集中的元素的性质 $&lt;A, \\preceq&gt;为偏序集，\\forall x, y\\in A$ $可比（comparable）：x \\in \\preceq \\lor y \\in \\preceq$ $x小于y：x\\in \\preceq \\land x \\ne y$，即偏序关系中x为第一分量，与为第二分量 $不可比（incomparable）：x \\notin \\preceq \\land y\\notin \\preceq$ 1.8. 全序关系$&lt;A, \\preceq&gt;$为偏序关系，如果$\\forall x, y\\in A$，都有$x\\preceq y或者y\\preceq x$（任意两个元素是可比的），则称$\\preceq 为全序关系$ 1.9 严格偏序关系与（非严格的）偏序关系相比，唯一的不同在于（非严格的）偏序关系满足自反性，而严格偏序关系要求反自反性。 偏序关系与严格偏序关系不是包含与被包含的关系 2. STL 具名要求：CompareCompare要求满足严格弱序关系 严格弱序关系（strict weak order）的定义如下： compare本身是一个严格偏序关系 不可比较的关系（!compare(a, b) &amp;&amp; !compare(b, a)）是一个等价关系 2.1 Compare 的功能 compare(a, b) == true表示 a 先于 b !compare(a, b) == true表示 b 先于 a !compare(a, b) &amp;&amp; !compare(b, a) == true表示a与b等价（相等） 2.2 一个合格的 Compare为了使得compare 能够很好地表达上述含义, 要求如下 2.2.1 compare本身是一个严格偏序关系 反自反性：compare(a, a) == false 反对称性：如果compare(a, b) == true，那么compare(b, a) == false 传递性：如果comapre(a, b) &amp;&amp; compare(b, c) == true，那么compare(a, c) == true 2.2.2 equiv是一个等价关系为了表示方便，使用equiv(a, b) 表示 !compare(a, b) &amp;&amp; !compare(b, a) 自反性：equiv(a, a) == true 对称性：如果equiv(a, b) == true，那么equiv(b, a) == true 传递性：如果equiv(a, b) &amp;&amp; equiv(b, c) == true，那么equiv(a, c) == true","link":"/2021/07/23/Cpp/namedRequirementCompare/"},{"title":"C++ 初始化类型","text":"参考资料CPP Reference知乎回答 初始化类型 list initialization aggregate initialization value initialization default initialization zero initialization direct initialization copy initialization 1. list initialization [new] T [objectName] {arg1, arg2, …} list initialization 分为两种, 一种是 aggregate type，它会利用 args 对其中的成员逐个初始化, args 不够会对剩余的成员进行 value initialization。另一种是 非 aggerate type，它会调用最匹配的构造函数。 123456789101112131415161718192021// 列表初始化// 非 aggregate 类型, 直接查找匹配的构造函数std::string str1{ &quot;123&quot; };std::string str2 = { &quot;456&quot; };std::string str3 = std::string{ &quot;789&quot; };std::string *str4 = new std::string{ &quot;xxx&quot; };std::cout &lt;&lt; str1 &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; &quot; &quot; &lt;&lt; str3 &lt;&lt; &quot; &quot; &lt;&lt; *str4 &lt;&lt; '\\n';// aggregate initialization, 使用{}中的参数逐个初始化, 不足的使用 value// initializationstd::vector&lt;int&gt; c1{ 1, 2, 3, 4 };std::array&lt;int, 8&gt; c2 = { 4, 5, 6, 7 };for (auto item : c1) { std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n';for (auto item : c2) { std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;}std::cout &lt;&lt; '\\n'; 1234// 结果123 456 789 xxx1 2 3 44 5 6 7 0 0 0 0 2. value initialization 对于class 类型的变量, value initialization 会优先考虑用户自定义的默认构造函数, 否则先进行 value initialization，再调用合成的默认构造函数 对于非class类型的变量，直接进行 value initialization 123456789101112131415161718// class 类型变量，用户自定义默认构造函数class A {public: A() : _data(999) {} void Print() { std::cout &lt;&lt; _data &lt;&lt; '\\n'; }private: int _data;};A a1{};A a2 = {};A a3 = A{};A *a4 = new A{};a1.Print();a2.Print();a3.Print();a4-&gt;Print(); 12345// 结果999999999999 12345678910111213141516171819202122232425// class 类型变量，合成默认构造函数class A {public: A() = default; void Print() { std::cout &lt;&lt; _data &lt;&lt; '\\n'; }private: int _data;};// value initializationA a1{};A a2 = {};A a3 = A{};A *a4 = new A{};a1.Print();a2.Print();a3.Print();a4-&gt;Print();// default initializationA a5;A a6 = A();A *a7 = new A();a5.Print();a6.Print();a7-&gt;Print(); 1234567891011// 结果// value initialization0000// default initialization495097600 6. direct initialization7. copy initialization 注意有些时候编译器会对copy initializaiton进行优化。 例 1 12345678910111213141516// example 1class A {public: A(int data) : _data(data) { std::cout &lt;&lt; &quot;data constructor...\\n&quot;; } A(A const &amp;x) { this-&gt;_data = x._data; std::cout &lt;&lt; &quot;copy constructor...\\n&quot;; }private: int _data;};// main functionA a = 999; A a = A(999); 12345// result// 第一行 : 隐式转换 999 -&gt; A// 第二行 : 等价于 A a(999);data constructor...data constructor... 12345678// 取消 g++ 优化 : g++ -o test test.cpp -fno-elide-constructors// result// 第一行 : 先隐式转换执行 A(999)，然后调用 copy ctor// 第二行 ： 先调用 普通ctor，再调用 copy ctordata constructor...copy constructor...data constructor...copy constructor... 例 2 12345678// example 2// 返回值优化A get() { return A();}void usage03() { A a = get();} 1234567891011// usage03()// g++编译器会对函数返回值优化, 这里并不会创建临时变量来存放返回值0x79fdef constructor // a0x79fdef destructor // a 析构// -fno-elide-constructors, 取消 g++ 优化0x78fd8f constructor // get() 中的匿名对象0x78fddf copy constructor // 临时对象存储返回值0x78fd8f destructor // 匿名对象析构0x78fdde copy constructor // a0x78fddf destructor // 临时对象析构0x78fdde destructor // a 析构","link":"/2021/04/11/Cpp/CppInitializationType/"},{"title":"博客搭建指南","text":"平台本博客网站的平台如下。 Hexo Icarus Gitee 搭建 HexoHexo 官网为了搭建 Hexo 环境, 用户需要先配置好 Node.js 以及 Git 环境。 新建一个文件夹，用来存放项目文件 进入该文件夹, 打开 Git Bash hexo init npm install npm install hexo-deployer-git --save hexo g hexo s 1npm install 可能针对某个特定的包报错, 可以先安装报错的包[npm install xxx --ignore-scripts] 切换 Icarus 主题Icarus 官方文档 Gitte Page 完成同步 创建 gitte 账户, 并添加本地主机的 ssh 公钥1234// Gittessh -T git@gitte.com// Githubssh -T git@github.com 修改_config.yml配置文件12345deploy: type: git # 可以指定多个 repo repo: git@gitee.com:chengming0313/chengming0313.git branch: master hexo d上传静态文件(.deploy_git) Gitte 新建分支 hexo hexo 设为默认分支 git clone xxx只保留.git文件夹, 删除其它所有文件夹 将博客的源文件复制过来(除了 .deploy_git)记得删除 themes 下主题里的 .git文件夹 上传源文件到 hexo 分支123git add .git commit -m &quot;init&quot;git push 更换本地主机 git clone xxx npm install npm install hexo-deployer-git --save hexo g hexo s hexo d","link":"/2021/04/06/Blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"},{"title":"引用本地图片","text":"在hexo博客中引用本地图片 npm hexo-asset-image --save 替换/node_modules/hexo-asset-image/index.js内容 修改_config.xml 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg 1. npm hexo-asset-image --save2. 替换/node_modules/hexo-asset-image/index.js内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) { return str.split(m, i).join(m).length;}var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function (data) { var config = hexo.config; if (config.post_asset_folder) { var link = data.permalink; if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for (var i = 0; i &lt; toprocess.length; i++) { var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function () { if ($(this).attr('src')) { // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if (!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) { // For &quot;about&quot; page, the first part of &quot;src&quot; can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function (elem) { return elem != ''; }); var srcArray = src.split('/').filter(function (elem) { return elem != '' &amp;&amp; elem != '.'; }); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + config.root + link + src); } } else { console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); } }); data[key] = $.html(); } }}); 3. 修改_config.xml4. 使用![example](example.jpg)引用_posts与文章同名文件夹下的example.jpg","link":"/2021/04/12/Blog/%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"},{"title":"C++ const","text":"本系列参考第三方文档 C++那些事 const const 含义 定义一个 const 变量 const 的一些特性 指针与 const 函数与 const 类与 const 1. const 含义 const 用来修饰变量，表示变量的值不可改变(赋值), 是一个 只读变量 。 const 修饰的变量不一定是一个 常量表达式 , 常量表达式除了要求值不可更改之外, 还要求在编译过程中就能得到计算结果。 一般使用 constexpr 来修饰一个常量表达式, 编译器会对变量进行验证。不符合要求会报错。 声明 constexpr 的类型有所限制, 必须属于 字面值类型 。 2. 定义一个 const 变量 const 变量必须初始化 const 变量不能赋值 const 修饰的 类变量 , 只有在 构造函数 完成后才算真正具有 const 属性。 123const int i1; // error: uninitialized const 'i1'const int i = 0;i = 1; // error: assignment of read-only variable 'i' 3. const 的一些特性 用 const 代替 #define如下, #define 定义的 SIZE_NUM, 在 预处理过程 就已经被 10 替换, 不会进入 符号表。程序出现问题时不好定位。 12#define SIZE_NUM = 10const int SIZE_NUM = 10; const 变量默认为文件局部变量 非 const 变量不同文件访问 123456789101112131415// g++ -o main main.cpp other.cpp// other.cppint i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;extern int i;int main() { std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} const 变量不同文件访问 const 变量需要显式使用 extern 定义, 才能跨文件访问 1234567891011121314151617// other.cppextern const int i = 100;// main.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;// 这里不用 const 声明也能够通过, i = 200 不会报错, 但是// 程序运行时会出错extern const int i;int main() { // i = 200; std::cout &lt;&lt; i + 10 &lt;&lt; '\\n'; system(&quot;pause&quot;); return 0;} 4. 指针与 const const 总是优先与它左侧的符号配对 12345const char * a; // pointer to const charchar const char * a; // 同上char *const a; // const pointer to charchar const *const a; // const pointer to const charconst char *const a; // 同上 指向常量的指针（底层 const） 可以不用初始化, 不能通过指针解引用去修改它的值 12345char const * a; // 底层 const 可以不用初始化char ch = 'a';a = &amp;ch;*a = 'x'; // error, 不能通过指针修改它的值 可以指向非 const 的变量 12345int i = 10;int const *pi = &amp;i;std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n';std::cout &lt;&lt; ++i &lt;&lt; &quot; &quot; &lt;&lt; *pi &lt;&lt; '\\n'; 1210 1011 11 不能用 void * 指向 const 变量, 必须使用 const void * 123const int a = 10;void const *ptr1 = &amp;a;void * ptr2 = &amp;a; // error 常量指针（顶层 const） 必须初始化, 指针不能修改 1234int a = 10;int *const ptr = &amp;a;int *const ptr2; // error: uninitialized const 'ptr2'ptr = nullptr; // error: assignment of read-only variable 'ptr' error: const T * —-&gt; T * const 12int const a = 10;int *const ptr = &amp;a; // error: invalid conversion from 'const int*' to 'int*' 5. const 变量的拷贝操作 顶层 const 对象可以拷贝给非顶层 const 对象 1234const int ci = 100;int i = ci; // i: 100int *const p1 = &amp;i;int * p2 = p1; 非顶层 const 对象也可以拷给顶层 const 对象 12345// -&gt; 顶层 constint j = 200;const int cj = j;int * ptr1 = &amp;j;int *const ptr2 = ptr1; 底层 const 对象不能拷给非底层 const 对象 1234567891011int const &amp;cr1 = 100;int &amp;r1 = cr1; // error: binding reference of type 'int&amp;' to 'const int' discards qualifiersint const *p3 = &amp;ci;int * p4 = p3; // error: invalid conversion from 'const int*' to 'int*'// T const * const -&gt;int const *const p5 = &amp;ci;int * p6 = p5; // error: invalid conversion from 'const int*' to 'int*'int const * p7 = p5;int *const p8 = p5; // error: invalid conversion from 'const int*' to 'int*' 非底层 const 对象可以拷给底层 const 对象 1234567int &amp; r2 = j;int const &amp;cr2 = r2;int * ptr3 = &amp;j;int const *ptr4 = ptr3;int const *const ptr5 = ptr3; 6. 函数与 const6.1 修饰返回值 return by const value，一般情况下,，没有意义。一些特殊情况下是有意义的, 详见Effective C++ 条款21。 123const int get() {return 1;} // 无意义// 这是有意义的, 防止出现 (a * b) = c;const Rational operator*(Rational const &amp;lhs, Rational const &amp;rhs); return by const reference 返回普通引用, 可以修改返回值, 可以作为左值使用 1234567891011121314std::string &amp;Get(std::string &amp;a) { return a;}int main() { std::string str = &quot;123456&quot;; // 这里要用 &amp;, 不然不是引用 std::string &amp;str2 = Get(str); str2 = &quot;xxxxxx&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; Get(str) = &quot;hello world&quot;; std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; return 0;} 12xxxxxx xxxxxxhello world hello world 返回常量引用，不能修改 12345678int main() { std::string str = &quot;123456&quot;; // 这里要用 const &amp; std::string const &amp;str2 = GetConst(str); std::cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; str2 &lt;&lt; std::endl; std::cout &lt;&lt; GetConst(str).length() &lt;&lt; std::endl; return 0;} return by T const * 1234567int const *Get(int *p) { return p;}int a = 10;int const *p1 = Get(&amp;a);int * p2 = Get(&amp;a); // error return by T * const1234567int *const Get2(int *p) { return p;}int a = 10;int *const p3 = Get2(&amp;a);int * p4 = Get2(&amp;a); 6.2 修饰参数 普通的 顶层 const (不是 T const &amp;)使用普通的 顶层 const 作为函数参数，没有意义, 函数收到的是一个副本。 12void fun1(int const val);void fun2(int *const ptr); 底层 const通过传入 T const * 的方式, 使得函数能够通过指针访问函数体外的对象, 又保证了数据的不可修改。 1void fun1(int const *p); T const &amp;pass by const reference 能让函数直接通过变量名访问作用域外的对象, 还能保证数据的 read only 1void fun1(std::string const &amp;str); 对于类类型的变量来说, 使用pass by value 的方式传值, 在拷贝过程中对象的拷贝构造以及析构都会消耗时间, 效率较低。我们可以使用 pass by pointer to const 以及 pass by const reference 来提高效率, 同时保证数据的安全性。 7. 类与 const const member function 普通的member function 中的 this pointer 类型为 T *, 而 const member function 中的 this pointer 类型为 T const *。 对于 const object来说, 它不能用来给普通的this pointer初始化, 它只能给const member function中T const *类型的this pointer初始化。 对于普通的 object, 它即可以使用const member function, 又可以使用普通的 member function。因为T * 既可以给 T * 初始化, 又可以给 T const * 初始化。 除了函数参数列表, 是否是 const member function, 也可以进行重载. 普通的 object 默认调用 非 const member function. 12345678910111213class A {public: void print() const { std::cout &lt;&lt; &quot;const print()\\n&quot;; } void print() { std::cout &lt;&lt; &quot;print()\\n&quot;; }};int main() { A a; A const ca; a.print(); ca.print(); return 0;} 123// 结果print()const print() const 成员 这里讨论一下类内初始值与初始值列表的优先级。初始值列表的优先级比类内初始值要高。只有没有为该成员设定初始值列表时, 它才会使用类内初始值进行初始化。 1234567891011121314class A {public: A() : _a(1) {} void Print() { std::cout &lt;&lt; _a &lt;&lt; &quot;\\n&quot;; }private: int _a = 0;};int main() { A a; a.Print(); return 0;} 12// 结果1 类中的 const 成员可以使用类内初始值的方式初始化 1const int _a = 999; 类中的 const 成员可以使用初始值列表的方式初始化 12const int _a;A() : _a(999) {} 不能在构造函数中用赋值表达式初始化 const 成员, 在进入构造函数体之前, 成员的初始化过程已经结束。 12const int _a;A() { _a = 999; } // error 当要表示类中共享的常量时, 通常使用 static const 修饰 使用类内初始值的方式定义 static const 1static const int _a = 999; // 类内初始值的方式初始化 static const 变量 采用与一般 static 变量一样的方法, 类内声明, 类外定义 1234// in classstatic const int _a;// 类的实现文件const int A::_a = 999; // 需要去除 static 符号","link":"/2021/04/11/Cpp/C-const/"},{"title":"Linux C 系统开发 I&#x2F;O 篇","text":"I/O (input &amp; output)I/O 是一切实现的基础。它分为 stdio (标准IO) 和 sysio (文件IO、系统调用IO)。优先使用 stdio。sysio 取决于操作系统内核，windows 和 linux 提供的文件 io 是不一致的。而 stdio 是 c 中提供的，stdio 依赖于底层的 sysio。windosw 和 linux 是兼容的，例如 fopen linux 环境中依赖于 open，windows 环境下依赖于 openfile。 stdioman 手册第三章 类型FILE 函数stream open &amp; close functions12345678910111213#include &lt;stdio.h&gt;FILE *fopen(const char *pathname, const char *mode);FILE *fdopen(int fd, const char *mode);FILE *freopen(const char *pathname, const char *mode, FILE *stream);Feature Test Macro Requirements for glibc (see feature_test_macros(7)):fdopen(): _POSIX_C_SOURCEint fclose(FILE *stream); fopen 中的 mode 如果使用 r、r+, 则指定的文件必须存在。同时 linux 没有二进制流和文本流的区别。 fopen 返回的 FILE 指针指向的内存在堆上，通过 fclose 释放堆空间。 1234567891011121314151617181920212223#include &lt;stdio.h&gt; // perror#include &lt;stdlib.h&gt;#include &lt;errno.h&gt; // errno#include &lt;string.h&gt; // strerrorint main() { FILE *fp; fp = fopen(&quot;tmp&quot;, &quot;r&quot;); if (fp == NULL) { // fprintf(stderr, &quot;fopen() failed! errno = %d\\n&quot;, errno); // perror(&quot;fopen()&quot;); fprintf(stderr, &quot;fopen(): %s\\n&quot;, strerror(errno)); exit(1); } puts(&quot;OK&quot;); fclose(fp); exit(0);} 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main() { FILE *fp = NULL; int count = 0; while (1) { fp = fopen(&quot;tmp&quot;, &quot;w&quot;); if (fp == NULL) { perror(&quot;fopen(): &quot;); break; } ++count; } fprintf(stdout, &quot;count = %d\\n&quot;, count); exit(0);} 每个进程默认最多能够打开 1024 个文件，默认已经打开了三个文件：stdin, stdout, stderr 12fopen(): : Too many open filescount = 1021 文件权限默认公式：0666 &amp; ~umask，umask 越大，生成的文件权限越小。 input of characters and strings123456789101112#include &lt;stdio.h&gt;int fgetc(FILE *stream);int getc(FILE *stream);int getchar(void);int ungetc(int c, FILE *stream);// 缺点：只能读取指定大小的内容。char *fgets(char *s, int size, FILE *stream); fgetc 读取失败返回 EOF，fgets 读取失败返回 NULL。 fgets - 读取 `size - 1` 个字符，例如 `abcde`，size 为 5, s 为 `abcd\\0` - 读取到 `\\n`，例如 `abc`, size 为 5, s 为 `abc\\n\\0` output of characters and strings123456789int fputc(int c, FILE *stream);int putc(int c, FILE *stream);int putchar(int c);int fputs(const char *s, FILE *stream);int puts(const char *s); binary stream input/output12345#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 1234// afread(buffer, 1, 10, fp);// bfread(buffer, 10, 1, fp); fp 指向的数据量不小于10个字节 - a 返回 10， 读取到 10 个字节. - b 返回 1，读取到 10 个字节. fp 指向的数据量只有 10 个字节. - a: 返回 5, 读取到 5 个字节. - b：返回 0, 这时不知道自己读取了几个字节. 建议 fread 以及 fwrite 中的 size 设定为 1, 即块大小永远设定为 1. formatted output conversion123456789101112#include &lt;stdio.h&gt;// 标准输出int printf(const char *format, ...);// 文件输出int fprintf(FILE *stream, const char *format, ...);// 文件描述符int dprintf(int fd, const char *format, ...);// 字符串int sprintf(char *str, const char *format, ...);// 指定大小的字符串, 防止数组越界int snprintf(char *str, size_t size, const char *format, ...); formatted input conversion缺点：读取字符串时，不知道目标字符串的大小。 12345#include &lt;stdio.h&gt;int scanf(const char *format, ...);int fscanf(FILE *stream, const char *format, ...);int sscanf(const char *str, const char *format, ...); reposition a streamfseek 以及 ftell 缺点：参数类型以及返回类型为 long，32 位平台下，只能支持 2GB 左右大小的文件。 1234567#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence);long ftell(FILE *stream);void rewind(FILE *stream); fflush() 问题man fopen 显示 no manual entry123// 安装标准 c 的帮助文档sudo apt-get install libc-devsudo apt-get install glibc-doc 执行文件时，需要加 ./执行文件时不会在当前目录查找。","link":"/2021/05/28/LinuxC/linux-c-io/"},{"title":"Windows terminal ssh 免密登录 Linux","text":"1. 修改设置- 打开 windows terminal 的 配置文件(json)- 找到 profiles 属性- powershell中通过 new_guid 生成新的 guid- 添加代码123456{ &quot;guid&quot;: &quot;{3a4f3a4b-f4bc-46c6-9b65-94a3a223f3f9}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;UbuntuDesktop&quot;, &quot;commandline&quot;: &quot;ssh cmtang@192.168.29.128&quot;} 2. Linux 存储 windows 公钥- sudo apt install openssh-server- windows 生成 ssh 密钥，C:\\Users\\Chengming\\.ssh- ~/.ssh/authorized_keys 中添加 windows 公钥 id_rsa.pub","link":"/2021/05/28/others/WindowsTerminal-ssh-linux/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Gitee","slug":"Gitee","link":"/tags/Gitee/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Windows Terminal","slug":"Windows-Terminal","link":"/tags/Windows-Terminal/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"LinuxC 系统开发","slug":"LinuxC-系统开发","link":"/tags/LinuxC-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"},{"name":"离散数学","slug":"离散数学","link":"/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"严格弱序关系","slug":"严格弱序关系","link":"/tags/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E5%85%B3%E7%B3%BB/"},{"name":"深入理解计算机系统","slug":"深入理解计算机系统","link":"/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"C++那些事","slug":"C-那些事","link":"/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Linux系统编程","slug":"Linux系统编程","link":"/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"深入理解计算机系统","slug":"深入理解计算机系统","link":"/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"Cpp Primer 5th","slug":"Cpp-Primer-5th","link":"/categories/Cpp-Primer-5th/"}]}