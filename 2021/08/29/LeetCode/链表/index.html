<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>【LeetCode】链表 - 个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="个人博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="个人博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="单链表结点定义如下 1234567struct ListNode &amp;amp;#123;    int val;    ListNode *next;    ListNode() : val(0), next(nullptr) &amp;amp;#123;&amp;amp;#125;    ListNode(int x) : val(x), next(nullptr) &amp;amp;#123;&amp;amp;#125;    ListNode(int x, Lis"><meta property="og:type" content="blog"><meta property="og:title" content="【LeetCode】链表"><meta property="og:url" content="http://example.com/2021/08/29/LeetCode/%E9%93%BE%E8%A1%A8/"><meta property="og:site_name" content="个人博客"><meta property="og:description" content="单链表结点定义如下 1234567struct ListNode &amp;amp;#123;    int val;    ListNode *next;    ListNode() : val(0), next(nullptr) &amp;amp;#123;&amp;amp;#125;    ListNode(int x) : val(x), next(nullptr) &amp;amp;#123;&amp;amp;#125;    ListNode(int x, Lis"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/cover/2021-8-29.jpg"><meta property="article:published_time" content="2021-08-29T01:56:48.000Z"><meta property="article:modified_time" content="2021-09-10T06:52:14.440Z"><meta property="article:author" content="Tang Chengming"><meta property="article:tag" content="链表"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/cover/2021-8-29.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/08/29/LeetCode/%E9%93%BE%E8%A1%A8/"},"headline":"【LeetCode】链表","image":["http://example.com/cover/2021-8-29.jpg"],"datePublished":"2021-08-29T01:56:48.000Z","dateModified":"2021-09-10T06:52:14.440Z","author":{"@type":"Person","name":"Tang Chengming"},"publisher":{"@type":"Organization","name":"个人博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"单链表结点定义如下 1234567struct ListNode &amp;#123;    int val;    ListNode *next;    ListNode() : val(0), next(nullptr) &amp;#123;&amp;#125;    ListNode(int x) : val(x), next(nullptr) &amp;#123;&amp;#125;    ListNode(int x, Lis"}</script><link rel="canonical" href="http://example.com/2021/08/29/LeetCode/%E9%93%BE%E8%A1%A8/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/cover/2021-8-29.jpg" alt="【LeetCode】链表"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-29T01:56:48.000Z" title="2021/8/29 上午9:56:48">2021-08-29</time>发表</span><span class="level-item"><time dateTime="2021-09-10T06:52:14.440Z" title="2021/9/10 下午2:52:14">2021-09-10</time>更新</span><span class="level-item"> Tang Chengming </span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a></span><span class="level-item">44 分钟读完 (大约6659个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">【LeetCode】链表</h1><div class="content"><p>单链表结点定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><ul>
<li><p>笔试和面试的区别</p>
<ul>
<li><p>对于笔试(追求快速通过)，不用太在意额外空间复杂度，一切为了时间复杂度。这样写出来的代码往往需要借助额外的数据结构，代码较为简单，编写速度快，通常不是最优解。</p>
</li>
<li><p>对于面试(要求最优解)，时间复杂度依然放在第一位，但是一定要找到额外空间复杂度最优的方法。</p>
</li>
</ul>
</li>
<li><p>链表题的重要技巧</p>
<ul>
<li><p>额外数据结构记录(哈希表、数组)</p>
</li>
<li><p>快慢指针</p>
</li>
</ul>
</li>
<li><p>基础题(主要考察基础的代码实现能力),往往只需要简单模拟 所有的操作步骤。</p>
<ul>
<li><p>翻转链表(单链表以及双链表)</p>
</li>
<li><p>公共元素</p>
</li>
</ul>
</li>
<li><p>技巧题(时间复杂度或者空间复杂度可以进一步优化)</p>
<ul>
<li><p>回文单链表</p>
  <figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1.</span> 额外数据结构：栈</span><br><span class="line"></span><br><span class="line">方法<span class="number">2.</span> 优化额外空间复杂度为$<span class="built_in">O</span>(<span class="number">1</span>)$。</span><br><span class="line">    <span class="number">1.</span> 找到链表中点</span><br><span class="line">    <span class="number">2.</span> 翻转右半边链表</span><br><span class="line">    <span class="number">3.</span> 比较左半边链表和右半边链表</span><br><span class="line">    <span class="number">4.</span> 复原右半边链表</span><br></pre></td></tr></table></figure></li>
<li><p>单链表中的环</p>
  <figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1.</span> 额外数据结构：哈希表</span><br><span class="line"></span><br><span class="line">方法<span class="number">2.</span> 快慢指针</span><br></pre></td></tr></table></figure></li>
<li><p>单链表的荷兰国旗(partition)问题</p>
  <figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1.</span> 额外数据结构：数组</span><br><span class="line"></span><br><span class="line">方法<span class="number">2.</span> 链表可以随意插入，不需要额外的空间复杂度。</span><br><span class="line">    <span class="number">1.</span> 建立<span class="number">3</span>个分区链表</span><br><span class="line">    <span class="number">2.</span> 循环遍历链表，在对应分区链表尾部插入结点</span><br><span class="line">    <span class="number">3.</span> 重连<span class="number">3</span>个分区链表(注意某个分区可能为空)</span><br></pre></td></tr></table></figure></li>
<li><p>复制带有随机指针的单链表</p>
  <figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1.</span> 额外数据结构：哈希表</span><br><span class="line"></span><br><span class="line">方法<span class="number">2.</span> 将复制出来的新结点插入旧结点的后面</span><br></pre></td></tr></table></figure></li>
<li><p>两个单链表(可能有环)相交</p>
  <figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根据链表是否有环分情况讨论。</span><br><span class="line"><span class="number">1.</span> 一个有环，一个没有环，两个链表不可能相交。</span><br><span class="line"><span class="number">2.</span> 两个单链表都没有环。</span><br><span class="line"><span class="number">3.</span> 两个都有环。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h1><h2 id="206-反转链表-Easy"><a href="#206-反转链表-Easy" class="headerlink" title="206. 反转链表(Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>(Easy)</h2><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *cur = head, *next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II-Medium"><a href="#92-反转链表-II-Medium" class="headerlink" title="92. 反转链表 II(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>(Medium)</h2><blockquote>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>, head)</span></span>;</span><br><span class="line">        ListNode *cur = head, *prev = &amp;preHead;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &gt; <span class="number">1</span> &amp;&amp; cur; i--) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = <span class="built_in">reverseKNode</span>(cur, right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseKNode</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *cur = head, *next;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = next;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="61-旋转链表-Medium"><a href="#61-旋转链表-Medium" class="headerlink" title="61. 旋转链表(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a>(Medium)</h2><blockquote>
<p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>, head)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode *slow = &amp;preHead, *fast = &amp;preHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cur = head; cur; cur = cur-&gt;next) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k % n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// k 为 0时，不需要旋转</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast-&gt;next = preHead.next;</span><br><span class="line">        preHead.next = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="25-K-个一组翻转链表-Hard"><a href="#25-K-个一组翻转链表-Hard" class="headerlink" title="25. K 个一组翻转链表(Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>(Hard)</h2><blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">        ListNode *prev = &amp;preHead, *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="built_in">reverse</span>(cur, k);</span><br><span class="line">            prev-&gt;next = p.first;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = p.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回反转后链表的头指针以及下一次反转的头指针</span></span><br><span class="line">    pair&lt;ListNode *, ListNode*&gt; reverse(ListNode *head, int size) &#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *cur = head, *next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cnt &lt; size) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长度不够 size，撤销反转</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reverse</span>(prev, cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head-&gt;next = cur;</span><br><span class="line">        <span class="keyword">return</span> &#123;prev, cur&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="2-两数相加-Medium"><a href="#2-两数相加-Medium" class="headerlink" title="2. 两数相加(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>(Medium)</h2><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单地模拟加法运算的过程即可。注意链表长度不相等的情况以及处理最后的进位。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        ListNode *prev = &amp;preHead;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;  <span class="comment">// 加法进位</span></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = a + b + carry;</span><br><span class="line">            ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            prev-&gt;next = node;</span><br><span class="line">            prev = node;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">            prev-&gt;next = node;</span><br><span class="line">            prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="86-分隔链表-Medium"><a href="#86-分隔链表-Medium" class="headerlink" title="86. 分隔链表(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a>(Medium)</h2><blockquote>
<p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模拟法，定义<span class="number">2</span>条链表分别保存左右分区结点，最后将两条链表连接在一起即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode left(-1), right(-1);</span><br><span class="line">        ListNode *leftPrev = &amp;left, *rightPrev = &amp;right;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &lt; x) &#123;</span><br><span class="line">                leftPrev-&gt;next = cur;</span><br><span class="line">                leftPrev = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightPrev-&gt;next = cur;</span><br><span class="line">                rightPrev = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        leftPrev-&gt;next = right.next;</span><br><span class="line">        rightPrev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> left.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="83-删除排序链表中的重复元素-Easy"><a href="#83-删除排序链表中的重复元素-Easy" class="headerlink" title="83. 删除排序链表中的重复元素(Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a>(Easy)</h2><blockquote>
<p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次。返回同样按升序排列的结果链表。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单模拟链表删除重复元素的操作即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>, head)</span></span>;</span><br><span class="line">        ListNode *prev = &amp;preHead, *cur = head, *next;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 如果 next 的值与 cur 的值不一致，prev 的下一个结点应该是 cur</span></span><br><span class="line">            <span class="comment">// 特别地，当 cur 为 链表末尾时，prev 的下一个结点也应该是 cur</span></span><br><span class="line">            <span class="keyword">if</span> (!next || next-&gt;val != cur-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = cur;</span><br><span class="line">                prev = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="82-删除排序链表中的重复元素-II-Medium"><a href="#82-删除排序链表中的重复元素-II-Medium" class="headerlink" title="82. 删除排序链表中的重复元素 II(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a>(Medium)</h2><blockquote>
<p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现的数字。返回同样按升序排列的结果链表。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"解题思路" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模拟法，与上一题的区别在于只保留没有重复出现过的元素，处理上存在差异。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>, head)</span></span>;</span><br><span class="line">        ListNode *prev = &amp;preHead, *cur = head, *next;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (next &amp;&amp; cur-&gt;val == next-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">while</span> (next &amp;&amp; cur-&gt;val == next-&gt;val) &#123;</span><br><span class="line">                    cur = next;</span><br><span class="line">                    next = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下次检查 next 是否没有重复出现</span></span><br><span class="line">                cur = next;</span><br><span class="line">                <span class="comment">// 从链表中删除重复出现的结点</span></span><br><span class="line">                prev-&gt;next = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = cur;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="19-删除链表的倒数第-N-个结点-Medium"><a href="#19-删除链表的倒数第-N-个结点-Medium" class="headerlink" title="19. 删除链表的倒数第 N 个结点(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>(Medium)</h2><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>, head)</span></span>;</span><br><span class="line">        ListNode *slow = &amp;preHead, *fast = &amp;preHead;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="24-两两交换链表中的节点-Medium"><a href="#24-两两交换链表中的节点-Medium" class="headerlink" title="24. 两两交换链表中的节点(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>(Medium)</h2><blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>, head)</span></span>;</span><br><span class="line">        ListNode *prev = &amp;preHead, *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            prev-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            prev-&gt;next-&gt;next = cur;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="138-复制带随机指针的链表-Medium"><a href="#138-复制带随机指针的链表-Medium" class="headerlink" title="138. 复制带随机指针的链表(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a>(Medium)</h2><blockquote>
<p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node *, Node *&gt; nodeMap;</span><br><span class="line">        <span class="keyword">for</span> (Node *cur = head; cur; cur = cur-&gt;next) &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            nodeMap[cur] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node *cur = head; cur; cur = cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = nodeMap[cur];</span><br><span class="line">            <span class="keyword">auto</span> nextNode = cur-&gt;next ? nodeMap[cur-&gt;next] : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">auto</span> randomNode = cur-&gt;random ? nodeMap[cur-&gt;random] : <span class="literal">nullptr</span>;</span><br><span class="line">            node-&gt;next = nextNode;</span><br><span class="line">            node-&gt;random = randomNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head ? nodeMap[head] : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node *cur = head; cur; cur = cur-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            <span class="comment">// 将新结点插入到原结点后</span></span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建新链表中的 random 关系</span></span><br><span class="line">        <span class="keyword">for</span> (Node *cur = head; cur; cur = cur-&gt;next-&gt;next) &#123;</span><br><span class="line">            cur-&gt;next-&gt;random = cur-&gt;random ? cur-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node *newList = head ? head-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 构建新链表中的 next 关系</span></span><br><span class="line">        <span class="keyword">for</span> (Node *cur = head; cur; cur = cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = tmp-&gt;next ? tmp-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表-Easy"><a href="#141-环形链表-Easy" class="headerlink" title="141. 环形链表(Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a>(Easy)</h2><blockquote>
<p>给定一个链表，判断链表中是否有环。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>"python" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast <span class="keyword">is</span> slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表-II-Medium"><a href="#142-环形链表-II-Medium" class="headerlink" title="142. 环形链表 II(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>(Medium)</h2><blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><figcaption><span>"python" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow <span class="keyword">is</span> fast:</span><br><span class="line">                fast = head</span><br><span class="line">                <span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> fast:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="876-链表的中间结点-Easy"><a href="#876-链表的中间结点-Easy" class="headerlink" title="876. 链表的中间结点(Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a>(Easy)</h2><blockquote>
<p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 空链表</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 奇数结点</span></span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        <span class="comment">// 偶数结点    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><figcaption><span>"python" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> slow.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="143-Reorder-List-Medium"><a href="#143-Reorder-List-Medium" class="headerlink" title="143. Reorder List(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">143. Reorder List</a>(Medium)</h2><blockquote>
<p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：L0 → L1 → … → Ln-1 → Ln 请将其重新排列后变为：L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;ListNode *&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cur = head; cur; cur = cur-&gt;next) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(vec.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high - <span class="number">1</span>) &#123;</span><br><span class="line">            vec[high]-&gt;next = vec[low]-&gt;next;</span><br><span class="line">            vec[low]-&gt;next = vec[high];</span><br><span class="line">            ++low;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[high]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><figcaption><span>"python" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node_list = []</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            node_list.append(cur)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(node_list) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high - <span class="number">1</span>:</span><br><span class="line">            node_list[high].<span class="built_in">next</span> = node_list[low].<span class="built_in">next</span></span><br><span class="line">            node_list[low].<span class="built_in">next</span> = node_list[high]</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        node_list[high].<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 找到链表中点</span></span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *rightHead = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转右半边链表</span></span><br><span class="line">        ListNode *cur = rightHead, *prev = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        rightHead = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 合并左半边链表和右半边链表</span></span><br><span class="line">        <span class="keyword">auto</span> left = head, right = rightHead;</span><br><span class="line">        <span class="keyword">while</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> nextLeft = left-&gt;next, nextRight = right-&gt;next;</span><br><span class="line">            right-&gt;next = nextLeft;</span><br><span class="line">            left-&gt;next = right;</span><br><span class="line">            left = nextLeft;</span><br><span class="line">            right = nextRight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 链表长度为奇数时，为左半边最后1个结点设置 next </span></span><br><span class="line">        <span class="keyword">if</span> (left) &#123;</span><br><span class="line">            left-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><figcaption><span>"python" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 找到链表的中点</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        rightHead = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 翻转右半边链表</span></span><br><span class="line">        prev, cur = <span class="literal">None</span>, rightHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        rightHead = prev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 合并左半边链表和右半边链表</span></span><br><span class="line">        left, right = head, rightHead</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            nextLeft = left.<span class="built_in">next</span></span><br><span class="line">            nextRight = right.<span class="built_in">next</span></span><br><span class="line">            right.<span class="built_in">next</span> = left.<span class="built_in">next</span></span><br><span class="line">            left.<span class="built_in">next</span> = right</span><br><span class="line">            left = nextLeft</span><br><span class="line">            right = nextRight</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            left.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="146-LRU-缓存机制-Medium"><a href="#146-LRU-缓存机制-Medium" class="headerlink" title="146. LRU 缓存机制(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a>(Medium)</h2><p><code>LRU(least recently used)</code>意义为最近最少使用。优先缓存最近访问过的资源，当缓存区即将溢出的时候，删除缓存中最久没有访问的资源。<code>LRU Cache</code>要求资源的查询、更新以及插入的时间复杂度为$O(1)$。</p>
<ul>
<li><p>一般都是通过双链表加上哈希表来实现。链表头部保存最近访问的资源，链表尾部保存最久没有访问的资源，从链表头部到链表尾部，资源的优先级依次降低。哈希表保存资源的键以及资源存储的位置(结点)。</p>
</li>
<li><p>为什么说双链表加上哈希表可以实现<code>LRU Cache</code>。首先<code>LRU Cache</code>支持两种操作。</p>
<ul>
<li><code>get(int key)</code>。<ul>
<li>如果缓存中不存在对应的资源，利用哈希表能够在$O(1)$时间内得到结果。</li>
<li>如果缓存中存在对应的资源，步骤如下。总的时间复杂度依然为$O(1)$。<ul>
<li>利用哈希表查询到对应的链表结点，从而获取对应的资源。时间消耗为$O(1)$。</li>
<li>因为该资源目前的优先级最高，因此需要将对应的结点移动到双链表头部，更新哈希表的记录。时间消耗为$O(1)$。</li>
</ul>
</li>
</ul>
</li>
<li><code>put(int key, int value)</code>。<ul>
<li>如果缓存中存在对应的资源，更新资源。时间消耗为$O(1)$。<ul>
<li>利用哈希表查询到对应的链表结点，从而修改对应的资源。时间消耗为$O(1)$。</li>
<li>将该结点移动到双链表头部, 更新哈希表中的记录。时间消耗为$O(1)$。</li>
</ul>
</li>
<li>如果缓存中不存在对应的资源。<ul>
<li>如果缓存即将溢出，需要删除最久未访问的资源。无论是从双链表尾部删除结点还是从哈希表中删除记录的时间消耗都是$O(1)$。</li>
<li>创建新的结点，将节点插入双链表头部，更新哈希表的记录。时间消耗为$O(1)$。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么不能使用<code>deque</code>代替双链表。因为<code>LRU Cache</code>中需要将中间的某个元素移动到头部。而<code>deque</code>底层通过<code>vector</code>来保存元素，对于这个操作，它的时间复杂度不是$O(1)$。</p>
</li>
<li><p>双链表的结点为什么需要同时保存<code>key</code>以及<code>value</code>。根据哈希表不是能够直接查询到<code>key</code>对应的结点。因为删除尾部结点时，哈希表不知道对应的<code>key</code>，如果链表结点不保存对应的<code>key</code>，哈希表无法删除记录。</p>
</li>
</ul>
<h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><ul>
<li><p><code>list</code>+<code>unordered_map</code></p>
  <figure class="highlight c++"><figcaption><span>"list+unordered_map" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">capacity_</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = mp_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="comment">// 如果 key 不存在, 返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> (iter == mp_.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在</span></span><br><span class="line">        <span class="keyword">int</span> value = iter-&gt;second-&gt;second;</span><br><span class="line">        <span class="comment">// 将最近访问的结点移动到双链表最前面</span></span><br><span class="line">        lst_.<span class="built_in">erase</span>(iter-&gt;second);</span><br><span class="line">        lst_.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        mp_[key] = lst_.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 返回对应的 value</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = mp_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="comment">// 如果缓存中没有对应的 key</span></span><br><span class="line">        <span class="keyword">if</span> (iter == mp_.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存满了的话，删除双链表末尾的结点</span></span><br><span class="line">            <span class="keyword">if</span> (capacity_ == lst_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                mp_.<span class="built_in">erase</span>(lst_.<span class="built_in">back</span>().first);</span><br><span class="line">                lst_.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 链表头部插入新的结点</span></span><br><span class="line">            lst_.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">            mp_[key] = lst_.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 如果缓存中已经存在对应的 key    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将对应的结点移动到链表头部</span></span><br><span class="line">            lst_.<span class="built_in">erase</span>(iter-&gt;second);</span><br><span class="line">            lst_.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">            mp_[key] = lst_.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; lst_;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; mp_;</span><br><span class="line">    <span class="keyword">int</span> capacity_;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>自己实现双链表</p>
<p>  使用标准库中的<code>list</code>有一点不方便，将某个结点移动到链表头部时，需要先删除该结点，再在头部插入新结点。</p>
<ul>
<li>自己实现的双链表，可以在头部以及尾部添加两个哨兵结点。可以减少边界判断。</li>
</ul>
  <figure class="highlight c++"><figcaption><span>"自己实现双链表" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    LRUNode *prev;</span><br><span class="line">    LRUNode *next;</span><br><span class="line">    <span class="built_in">LRUNode</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value, LRUNode *prev = <span class="literal">nullptr</span>, LRUNode *next = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">prev</span>(prev), <span class="built_in">next</span>(next)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUList</span> &#123;</span></span><br><span class="line">    LRUNode *preHead;</span><br><span class="line">    LRUNode *afterTail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">LRUList</span>() : <span class="built_in">size</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        preHead = <span class="keyword">new</span> <span class="built_in">LRUNode</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        afterTail = <span class="keyword">new</span> <span class="built_in">LRUNode</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        preHead-&gt;next = afterTail;</span><br><span class="line">        afterTail-&gt;prev = preHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(LRUNode *node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">        node-&gt;next = preHead-&gt;next;</span><br><span class="line">        preHead-&gt;next-&gt;prev = node;</span><br><span class="line">        preHead-&gt;next = node;</span><br><span class="line">        node-&gt;prev = preHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteTailNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tail = afterTail-&gt;prev;</span><br><span class="line">        <span class="keyword">auto</span> prev = tail-&gt;prev;</span><br><span class="line">        prev-&gt;next = afterTail;</span><br><span class="line">        afterTail-&gt;prev = prev;</span><br><span class="line">        <span class="keyword">int</span> key = tail-&gt;key;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">        --size;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">LRUNode</span>(key, value);</span><br><span class="line">        node-&gt;prev = preHead;</span><br><span class="line">        node-&gt;next = preHead-&gt;next;</span><br><span class="line">        preHead-&gt;next-&gt;prev = node;</span><br><span class="line">        preHead-&gt;next = node;</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">capacity_</span>(capacity) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 查询哈希表, 如果key不存在, 返回 -1</span></span><br><span class="line">    <span class="comment">// 2. 查询哈希表, 如果key存在, 将对应的结点移动到链表头部, 返回对应的值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = mp_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (iter == mp_.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> node = iter-&gt;second;</span><br><span class="line">        lst_.<span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 查询哈希表, 如果 key 存在, 将对应的结点移动到头部</span></span><br><span class="line">    <span class="comment">// 2. 查询哈希表, 如果 key 不存在, 判断缓存是否会溢出，如果会溢出，</span></span><br><span class="line">    <span class="comment">//          先删除链表末尾的结点并从哈希表中移除对应的记录</span></span><br><span class="line">    <span class="comment">//          如果不会溢出，创建新的结点，并在链表头部插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = mp_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (iter != mp_.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = iter-&gt;second;</span><br><span class="line">            <span class="comment">// LRU中已经存在相同的 key, 将对应的值用 value 覆盖，并将节点移动到头部</span></span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            lst_.<span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lst_.size == capacity_) &#123;</span><br><span class="line">                <span class="keyword">int</span> tailKey = lst_.<span class="built_in">deleteTailNode</span>();</span><br><span class="line">                mp_.<span class="built_in">erase</span>(tailKey);</span><br><span class="line">            &#125;</span><br><span class="line">            lst_.<span class="built_in">addNode</span>(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        mp_[key] = lst_.preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LRUList lst_;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, LRUNode *&gt; mp_;</span><br><span class="line">    <span class="keyword">int</span> capacity_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><ul>
<li><p>自己实现双链表</p>
  <figure class="highlight python"><figcaption><span>"python 自己实现双链表" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = <span class="built_in">dict</span>()</span><br><span class="line">        self.first = LRUNode(-<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        self.last = LRUNode(-<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        self.first.<span class="built_in">next</span> = self.last</span><br><span class="line">        self.last.prev = self.first</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果缓存中不存在相同的 key, 返回 - 1</span></span><br><span class="line">    <span class="comment"># 如果缓存中存在相同的 key, 将对应的结点移动到链表头部, 返回 value</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.move_to_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果缓存中不存在相同的 key, 判断缓存是否会溢出，有必要的话，删除链表末尾的结点，同时从哈希表中删除记录</span></span><br><span class="line">    <span class="comment">#       在链表头部插入新结点, 哈希表插入新的记录</span></span><br><span class="line">    <span class="comment"># 如果缓存中存在相同的 key, 修改对应结点的值，同时将其移动到链表头部</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) == self.capacity:</span><br><span class="line">                self.delete_node(self.last.prev)</span><br><span class="line">            self.insert_node_to_head(key, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cache[key].value = value</span><br><span class="line">            self.move_to_head(self.cache[key])</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span>(<span class="params">self, node: LRUNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">        node.<span class="built_in">next</span> = self.first.<span class="built_in">next</span></span><br><span class="line">        self.first.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.first.<span class="built_in">next</span> = node</span><br><span class="line">        node.prev = self.first</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_node</span>(<span class="params">self, node: LRUNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">        <span class="keyword">del</span> self.cache[node.key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_node_to_head</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        node = LRUNode(key, value)</span><br><span class="line">        self.first.<span class="built_in">next</span>.prev = node</span><br><span class="line">        node.<span class="built_in">next</span> = self.first.<span class="built_in">next</span></span><br><span class="line">        node.prev = self.first</span><br><span class="line">        self.first.<span class="built_in">next</span> = node</span><br><span class="line">        self.cache[key] = node</span><br></pre></td></tr></table></figure></li>
<li><p><code>collections.OrderedDict</code></p>
  <figure class="highlight python"><figcaption><span>"OrderedDict" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = OrderedDict ()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        self.cache.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self.cache[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) == self.capacity:</span><br><span class="line">                self.cache.popitem(last=<span class="literal">False</span>)</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">            self.cache.move_to_end(key)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="328-奇偶链表-Medium"><a href="#328-奇偶链表-Medium" class="headerlink" title="328. 奇偶链表(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a>(Medium)</h2><blockquote>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> oddHead = head, evenHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">auto</span> oddCur = oddHead, evenCur = evenHead;</span><br><span class="line">        <span class="keyword">while</span> (evenCur &amp;&amp; evenCur-&gt;next) &#123;</span><br><span class="line">            oddCur-&gt;next = evenCur-&gt;next;</span><br><span class="line">            oddCur = oddCur-&gt;next;</span><br><span class="line">            evenCur-&gt;next = oddCur-&gt;next;</span><br><span class="line">            evenCur = evenCur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        oddCur-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> oddHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><figcaption><span>"python" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        odd_head, even_head = head, head.<span class="built_in">next</span></span><br><span class="line">        odd_cur, even_cur = odd_head, even_head</span><br><span class="line">        <span class="keyword">while</span> even_cur <span class="keyword">and</span> even_cur.<span class="built_in">next</span>:</span><br><span class="line">            odd_cur.<span class="built_in">next</span> = even_cur.<span class="built_in">next</span></span><br><span class="line">            odd_cur = odd_cur.<span class="built_in">next</span></span><br><span class="line">            even_cur.<span class="built_in">next</span> = odd_cur.<span class="built_in">next</span></span><br><span class="line">            even_cur = even_cur.<span class="built_in">next</span></span><br><span class="line">        odd_cur.<span class="built_in">next</span> = even_head</span><br><span class="line">        <span class="keyword">return</span> odd_head</span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表-Medium"><a href="#148-排序链表-Medium" class="headerlink" title="148. 排序链表(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a>(Medium)</h2><blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表。</p>
</blockquote>
<p>题目要求排序的时间复杂度为$O(NlogN)$，额外空间复杂度为$O(1)$。基于比较的排序中只有<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>的时间复杂度为$O(NlogN)$。又因为是对链表排序，归并排序中合并有序数组的空间代价可以降为$O(1)$，因此<strong>归并排序</strong>可以满足要求。而<strong>快速排序</strong>的空间复杂度为$O(logN)$，<strong>堆排序</strong>的空间复杂度为$O(N)$。</p>
<p>实际上自顶向下的归并排序额外空间复杂度为$O(logN)$，不符合题意。只有自底向上的归并排序才能真正将额外空间复杂度优化为$O(1)$。</p>
<ul>
<li><p>自顶向下的归并排序</p>
  <figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeSort</span><span class="params">(ListNode *first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!first || !first-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到链表的中点</span></span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">findMid</span>(first);</span><br><span class="line">        <span class="comment">// 保存右半边链表的开始结点</span></span><br><span class="line">        ListNode *first2 = mid-&gt;next;</span><br><span class="line">        <span class="comment">// 断开左半边链表和右半边链表</span></span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *left = <span class="built_in">mergeSort</span>(first);</span><br><span class="line">        ListNode *right = <span class="built_in">mergeSort</span>(first2);</span><br><span class="line">        <span class="comment">// 合并左半边链表和右半边链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeList</span>(left, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">findMid</span><span class="params">(ListNode *first)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = first, *fast = first;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeList</span><span class="params">(ListNode *left, ListNode *right)</span> </span>&#123;</span><br><span class="line">        ListNode preHead;</span><br><span class="line">        ListNode *cur = &amp;preHead, *next = cur;</span><br><span class="line">        <span class="keyword">while</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right-&gt;val &lt; left-&gt;val) &#123;</span><br><span class="line">                next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = left ? left : right;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><figcaption><span>"python" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">return</span> self.mergeSort(head)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    mid = self.midNode(head)</span><br><span class="line">    rightHead = mid.<span class="built_in">next</span></span><br><span class="line">    mid.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    head = self.mergeSort(head)</span><br><span class="line">    rightHead = self.mergeSort(rightHead)</span><br><span class="line">    <span class="keyword">return</span> self.mergeList(head, rightHead)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">midNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    slow = fast = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeList</span>(<span class="params">self, left: ListNode, right: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    preHead = ListNode()</span><br><span class="line">    cur = preHead</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> right.val &lt; left.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = right</span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = left</span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">    <span class="keyword">return</span> preHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></li>
<li><p>自底向上的归并排序</p>
  <figure class="highlight c++"><figcaption><span>"c++" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cur = head; cur; cur = cur-&gt;next) &#123;</span><br><span class="line">        ++size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">        <span class="comment">// 当 subSize &gt;= size 时, 链表已经有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> subSize = <span class="number">1</span>; subSize &lt; size; subSize += subSize) &#123;</span><br><span class="line">            <span class="comment">// 这里的 left 不能用 head 初始化, 因为一轮归并之后, head 可能不再位于链表头部</span></span><br><span class="line">            <span class="keyword">auto</span> prev = &amp;preHead, left = preHead.next, cur = left;</span><br><span class="line">            <span class="keyword">while</span> (left) &#123;</span><br><span class="line">                <span class="comment">// step 1. 寻找右半边链表的起点 right</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cur &amp;&amp; i &lt; subSize - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 剩下的元素不超过 subSize, 不需要归并, 已经有序</span></span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="literal">nullptr</span> || cur-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    prev-&gt;next = left;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">auto</span> right = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                cur = right;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// step 2. 寻找下次归并的起点 next</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cur &amp;&amp; i &lt; subSize - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode *next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">                    next = cur-&gt;next;</span><br><span class="line">                    cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// step 3. 开始该次归并, 让 prev 的下一个结点为归并链表的起点</span></span><br><span class="line">                prev-&gt;next = <span class="built_in">mergeList</span>(left, right);</span><br><span class="line">                <span class="comment">// 修改 prev, 让它指向归并链表的最后一个元素</span></span><br><span class="line">                <span class="keyword">while</span> (prev-&gt;next) &#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                left = next;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeList</span><span class="params">(ListNode *left, ListNode *right)</span> </span>&#123;</span><br><span class="line">        ListNode preHead;</span><br><span class="line">        ListNode *cur = &amp;preHead, *next = cur;</span><br><span class="line">        <span class="keyword">while</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right-&gt;val &lt; left-&gt;val) &#123;</span><br><span class="line">                next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = left ? left : right;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><figcaption><span>"python" >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    size, cur = <span class="number">0</span>, head</span><br><span class="line">    <span class="comment"># 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        size += <span class="number">1</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    subSize, preHead = <span class="number">1</span>, ListNode(<span class="number">0</span>, head)</span><br><span class="line">    <span class="comment"># 当链表长度不超过 subSize 时, 链表已经有序</span></span><br><span class="line">    <span class="keyword">while</span> subSize &lt; size:</span><br><span class="line">        prev, left, cur = preHead, preHead.<span class="built_in">next</span>, preHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            <span class="comment"># 寻找右半边链表的起点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, subSize - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> cur:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 右半边链表为空, 该轮归并结束</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> cur) <span class="keyword">or</span> (<span class="keyword">not</span> cur.<span class="built_in">next</span>):</span><br><span class="line">                prev.<span class="built_in">next</span> = left</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            right = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            cur = right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 寻找下次归并的起点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, subSize - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> cur:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># print(left.val, right.val)</span></span><br><span class="line">            prev.<span class="built_in">next</span> = self.mergeList(left, right)</span><br><span class="line">            <span class="keyword">while</span> prev.<span class="built_in">next</span>:</span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># print(next.val)</span></span><br><span class="line">            left = <span class="built_in">next</span></span><br><span class="line">            cur = left</span><br><span class="line">        subSize += subSize</span><br><span class="line">    <span class="keyword">return</span> preHead.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeList</span>(<span class="params">self, left: ListNode, right: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    preHead = ListNode()</span><br><span class="line">    cur = preHead</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> right.val &lt; left.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = right</span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = left</span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">    <span class="keyword">return</span> preHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="160-相交链表-Easy"><a href="#160-相交链表-Easy" class="headerlink" title="160. 相交链表(Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>(Easy)</h2><h2 id="剑指-Offer-II-026-重排链表-Medium"><a href="#剑指-Offer-II-026-重排链表-Medium" class="headerlink" title="剑指 Offer II 026. 重排链表(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/LGjMqU/">剑指 Offer II 026. 重排链表</a>(Medium)</h2><h2 id="剑指-Offer-II-077-链表排序-Medium"><a href="#剑指-Offer-II-077-链表排序-Medium" class="headerlink" title="剑指 Offer II 077. 链表排序(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/7WHec2/">剑指 Offer II 077. 链表排序</a>(Medium)</h2></div><div class="article-licensing box"><div class="licensing-title"><p>【LeetCode】链表</p><p><a href="http://example.com/2021/08/29/LeetCode/链表/">http://example.com/2021/08/29/LeetCode/链表/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Tang Chengming</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-08-29</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-09-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%93%BE%E8%A1%A8/">链表</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/08/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Colab/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Colab使用</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/27/CppPrimer5th/ch14/"><span class="level-item">第14章【C++ Primer】：操作重载与类型转换</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#方法论"><span class="level-left"><span class="level-item">方法论</span></span></a></li><li><a class="level is-mobile" href="#翻转链表"><span class="level-left"><span class="level-item">翻转链表</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#206-反转链表-Easy"><span class="level-left"><span class="level-item">206. 反转链表(Easy)</span></span></a></li><li><a class="level is-mobile" href="#92-反转链表-II-Medium"><span class="level-left"><span class="level-item">92. 反转链表 II(Medium)</span></span></a></li><li><a class="level is-mobile" href="#61-旋转链表-Medium"><span class="level-left"><span class="level-item">61. 旋转链表(Medium)</span></span></a></li><li><a class="level is-mobile" href="#25-K-个一组翻转链表-Hard"><span class="level-left"><span class="level-item">25. K 个一组翻转链表(Hard)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#练习"><span class="level-left"><span class="level-item">练习</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-两数相加-Medium"><span class="level-left"><span class="level-item">2. 两数相加(Medium)</span></span></a></li><li><a class="level is-mobile" href="#86-分隔链表-Medium"><span class="level-left"><span class="level-item">86. 分隔链表(Medium)</span></span></a></li><li><a class="level is-mobile" href="#83-删除排序链表中的重复元素-Easy"><span class="level-left"><span class="level-item">83. 删除排序链表中的重复元素(Easy)</span></span></a></li><li><a class="level is-mobile" href="#82-删除排序链表中的重复元素-II-Medium"><span class="level-left"><span class="level-item">82. 删除排序链表中的重复元素 II(Medium)</span></span></a></li><li><a class="level is-mobile" href="#19-删除链表的倒数第-N-个结点-Medium"><span class="level-left"><span class="level-item">19. 删除链表的倒数第 N 个结点(Medium)</span></span></a></li><li><a class="level is-mobile" href="#24-两两交换链表中的节点-Medium"><span class="level-left"><span class="level-item">24. 两两交换链表中的节点(Medium)</span></span></a></li><li><a class="level is-mobile" href="#138-复制带随机指针的链表-Medium"><span class="level-left"><span class="level-item">138. 复制带随机指针的链表(Medium)</span></span></a></li><li><a class="level is-mobile" href="#141-环形链表-Easy"><span class="level-left"><span class="level-item">141. 环形链表(Easy)</span></span></a></li><li><a class="level is-mobile" href="#142-环形链表-II-Medium"><span class="level-left"><span class="level-item">142. 环形链表 II(Medium)</span></span></a></li><li><a class="level is-mobile" href="#876-链表的中间结点-Easy"><span class="level-left"><span class="level-item">876. 链表的中间结点(Easy)</span></span></a></li><li><a class="level is-mobile" href="#143-Reorder-List-Medium"><span class="level-left"><span class="level-item">143. Reorder List(Medium)</span></span></a></li><li><a class="level is-mobile" href="#146-LRU-缓存机制-Medium"><span class="level-left"><span class="level-item">146. LRU 缓存机制(Medium)</span></span></a></li><li><a class="level is-mobile" href="#328-奇偶链表-Medium"><span class="level-left"><span class="level-item">328. 奇偶链表(Medium)</span></span></a></li><li><a class="level is-mobile" href="#148-排序链表-Medium"><span class="level-left"><span class="level-item">148. 排序链表(Medium)</span></span></a></li><li><a class="level is-mobile" href="#160-相交链表-Easy"><span class="level-left"><span class="level-item">160. 相交链表(Easy)</span></span></a></li><li><a class="level is-mobile" href="#剑指-Offer-II-026-重排链表-Medium"><span class="level-left"><span class="level-item">剑指 Offer II 026. 重排链表(Medium)</span></span></a></li><li><a class="level is-mobile" href="#剑指-Offer-II-077-链表排序-Medium"><span class="level-left"><span class="level-item">剑指 Offer II 077. 链表排序(Medium)</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2021 Tang Chengming</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>